[{"title":"java基础复习之计网","date":"2020-07-05T07:39:30.000Z","path":"2020/07/05/秋招复习之计网/","text":"java基础复习之计网OSI模型7 层模型主要包括： 物理层：设备之间的比特流传输。 数据链路层：主要将从物理层接收的数据进行 MAC 地址（网卡的地址）的封装与解封装。在这一层工作的设备是交换机，数据通过交换机来传输。 主要协议为ARP协议，提供IP 地址到对应的硬件地址提供动态映射 网络层：主要将从下层接收到的数据进行 IP 地址（例 192.168.0.1)的封装与解封装。在这一层工作的设备是路由器，常把这一层的数据叫做数据包。 传输层：定义了一些传输数据的协议和端口号（WWW 端口 80 等），如：TCP，UDP协议。 主要是将从下层接收的数据进行分段进行传输，到达目的地址后在进行重组。 常常把这一层数据叫做段。 会话层：通过传输层（端口号：传输端口与接收端口）建立数据传输的通路。主要在你的系统之间发起会话或或者接受会话请求（设备之间需要互相认识可以是IP也可以是 MAC 或者是主机名） 表示层：主要是进行对接收的数据进行解释、加密与解密、压缩与解压缩等（也就是把计算机能够 识别的东西转换成人能够能识别的东西（如图片、声音等）） 应用层：主要是一些终端的应用，比如说FTP（各种文件下载），WEB（IE浏览），QQ之类的（你 就把它理解成我们在电脑屏幕上可以看到的东西．就 是终端应用）。 TCP/IP协议TCP三次握手四次挥手三次握手 过程第一次握手：主机 A 发送位码为 syn＝1,随机产生seq序列号的数据包到服务器，第二次握手：主机B收到请求后要确认联机信息，同样向A发送syn=1，以及确认请求ACK=1，B的seq序列号，以及A的序列号+1的确认号，第三次握手：主机A收到后检查返回的确认号是否正确以及确认请求ACK是否为1，若正确，主机A会再发送确认请求ACK=1以及服务器B的序列号+1的确认号，主机B收到后确认确认序列号值与确认请求 Ack=1 则连接建立成功。 为什么要三次握手？即为什么A还要发送一次确认请求给服务器B，这是为了防止已经失效的连接请求突然又传送到了B。存在这样的一种情况，当A发送连接请求给B，此时由于网络拥堵造成服务器B没有及时收到连接请求，因此A又重新发送了一个请求给B，正常建立连接后，拥堵的第一次请求又传送到了服务器B，如果不采用三次握手，那么B又会发送确认连接的请求给B，又会建立一个新的连接，会浪费许多资源 syn攻击在第一次握手后，服务器向客户端发送确认请求信息后需要等待客户端的再次确认信息，如果此时客户端掉线，服务器会一直尝试发送5次请求信息，会浪费大量资源，可能导致正常的syn请求无法完成。 那么如何防护呢？ 当syn队列满后，通过tcp_syncookies参数回发syn_cookie给客户端，如果正常连接，客户端会回发这个syn_cookie给服务器，此时即使syn队列满了，依然可以正常建立连接 建立连接后客户端出现问题怎么办？服务器会发送保持会话报文，若一直没有响应一定次数，服务器会中断此次会话 四次挥手 过程首先由客户端发送一个FIN=1，以及seq=a的请求码给服务器，此时客户端进入等待关闭状态1，服务器收到客户端的关闭请求后，会立即发送一个确认关闭的ACK=1，以及a+1的确认码，和seq=b的序列号给客户端，告诉客户端我收到你关闭的请求了，客户端收到请求后会进入等待关闭状态2，当服务器传送玩最后的数据给客户端后，会发送一个确认关闭FIN=1，确认请求ACK=1确认序列a+1的确认号给客户端，意思是我传送玩所有的数据了，你可以关闭了。客户端在收到服务器第二次关闭请求后回回发最终确认ACK=1，以及第二次的确认序列+1的确认号给服务器，服务器收到后关闭连接，客户端在2MSL时间后关闭连接。 为什么要四次挥手？因为TCP是全双工的，客户端给服务器发送信息的同时，服务器也可以给客户端发送，之所以需要四次挥手，是因为在客户端发送结束请求后，可能服务器的数据还没有传输完毕，因此需要2个等待关闭的状态确保所有数据传输完毕，因此需要四次挥手 为什么客户端还要等待2msl？因为服务器给客户端发送的第二次FIN请求后，客户端回发给服务器的最终确认可能丢失，如果服务器没有收到最终确认，则会再次发送FIN请求给客户端，那么在客户端等待关闭的这2MSL里再次收到请求后，会再次发送最终请求，使得服务器能够正常准确的关闭 如何理解IP协议的不可靠和无连接？不可靠：指的是不能保证数据报能成功地到达目的地。 发生错误时候，丢弃该数据包，发送 ICMP 消息给信源端，可靠性由上层提供。 无状态：IP 不维护关于后续数据报的状态信息。 体现在，IP 数据可以不按顺序发送和接收。A 发送连续的数据报，到达B不一定是连续的， 来回路由选择可能不一样，路线也不一样，到达先后顺序也不一样。 TCP如何保证可靠性？1） 确认机制，发送报文后，等待确认。 2） 重发机制，没有收到确认，将重发数据段。 3） 拥塞控制：慢启动（逐渐增大窗口）、快速重传（收到失序报文立刻重传）、快速恢复（收到重复确认可能没有拥堵，因此不执行慢启动而是快速恢复）、拥塞避免（门限设为一般后开始慢启动算法） 4） 排序，有专门的序列号字段 5） 流量控制，通过滑动窗口实现 TCP与UDP区别 tcp对应的协议有：FTP、HTTP udp对应的协议有：DNS HTTP协议http请求报文和响应报文http请求报文由请求行（get/post方法，url的path路径，http版本）、请求头（键值对）、请求体（body） get/post区别1、get请求是通过URL传参，而post请求被放在请求体中，因此决定了get不能代替post发送大量数据 2、get请求的安全性不如post，是由于get请求在url中会被看到 3、get请求是幂等的，post不幂等（幂等就是多次操作结果一样，get查询多次肯定一样，post是改肯定不一样） http响应报文由状态码（Status Code）、HTTP头部（编码格式，过期时间）、响应体（响应的内容） 状态码1XX：请求已接受一部分，正等待剩余部分 2XX：正常接收 3XX：重定向，进一步操作 4XX：客户端请求出错 5XX：服务端出错 http请求过程1、DNS域名解析器解析出IP地址 2、TCP连接（三次握手） 3、浏览器发送HTTP请求 4、服务器处理请求并返回HTTP响应 5、浏览器解析渲染页面 6、释放连接（四次挥手） http长连接，短连接，无状态，HTTP/1.0，HTTP/1.1，HTTP/2.0无状态无状态：HTTP 协议是无状态的，指的是协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。也就是说，打开一个服务器上的网页和上一次打开这个服务器上的网 页之间没有任何联系。HTTP 是一个无状态的面向连接的协议，无状态不代表 HTTP 不能保 持 TCP 连接，更不能代表 HTTP 使用的是 UDP 协议（无连接）。 长短连接HTTP/1.0 短连接：客户端和服务器每进行一次 HTTP 操作，就建立一次连接，任务结束就中断连接。适用于而像 WEB 网站的http服务 HTTP/1.1 默认使用长连接：在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输 HTTP 数据 的 TCP 连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。适用于于操作频繁，点对点的通讯，而且连接数不能太多情况。 HTTP/1.1和HTTP/2.0区别1.1管道传输与2.0的多路复用HTTP/1.1使用管道传输，即客户端与服务器建立连接后不用每次等待服务器响应就可发送新的请求，但是服务器仍然会顺序响应。如果某一请求出现问题，那么后面的请求都无法加载，这就会出现队头阻塞的问题。 在HTTP/2.0中通过多路复用解决了这个问题，即将一个TCP连接分为若干个流（Stream），每个流中可以传输若干消息（Message），这样即使一个请求被阻塞了，也不会影响其他请求 头部数据压缩在HTTP1.1中，消息主体都会经过gzip压缩，但状态行和头部却没有经过任何压缩，直接以纯文本传输。 HTTP2.0对header的数据进行压缩，这样数据体积小了，在网络上传输就会更快。 传输格式2.0采用二进制格式而非文本格式 HTTP和HTTPS的区别1、HTTP是超文本传输协议，是明文传输，而HTTPS则是具有安全协议SSL的加密传输 2、http是无状态的，而https是有可以进行加密传输，身份认证的 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://xulilei.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"十次方微服务复习","date":"2020-07-01T08:17:02.000Z","path":"2020/07/01/十次方微服务复习/","text":"利用SpringDataJPA完成问答、文章、招聘、交友、吐槽、用户、管理员的增删改以及模糊分页查询1、IdWorker：采用推特开源的雪花算法工具类，每秒能产生26W的id，而不产生id碰撞 SpringDataJpa用法：Dao层接口继承JpaRepository,JpaSpecifationExecutor（复杂查询使用）接口 模糊分页查询 实现条件查询： ​ 3种方式 ：一种是通过在dao层通过nativeQuery编写模糊查询语句，第二种是在dao层通过findBy**Like 另一种通过service层new Specification构造动态查询语句 public List&lt;Label&gt; findSearch(Label label) { return labelDao.findAll(new Specification&lt;Label&gt;() { @Override public Predicate toPredicate(Root&lt;Label&gt; root, CriteriaQuery&lt;?&gt; query, CriteriaBuilder cb) { List&lt;Predicate&gt; list=new ArrayList&lt;&gt;(); //相当于 ****** where labelname like \"%label.getLabelname()%\" if(label.getLabelname()!=null&amp;&amp;!\"\".equals(label.getLabelname())){ //通过root拿到字段名 Predicate predicate = cb.like(root.get(\"labelname\").as(String.class), \"%\" + label.getLabelname() + \"%\"); //一个条件，添加到cb中 list.add(predicate); } //将条件链表转化为数组 Predicate[] parr=new Predicate[list.size()]; list.toArray(parr); //合并所有条件，一起查询 return cb.and(parr); }); } 实现分页查询 dao层构建查询方法时传入pageable对象 service层调用JPA封装的方法时传入page和size，通过PageRequest生成Pgeable对象，service层返回Page对象 controller调用service方法，并通过之前定义好的分页类，返回给前端 //dao层public Page&lt;Label&gt; findAll(Pagealbe pageable){}//service层public Page&lt;Label&gt; findAll(int page,int size){ Pageable pageable=PageRequest.of(page-1,size); return labelDao.findAll(pageable);}//controller@RequestMapping(value = \"/{page}/{size}\",method = RequestMethod.GET) public Result findAll(@PathVariable int page,@PathVariable int size){ Page&lt;Label&gt; all = labelService.findAll(page,size); return new Result(true, StatusCode.OK,\"查询成功\",new PageResult&lt;&gt;(all.getTotalElements(),all.getContent())); }//pageResult类public class PageResult&lt;T&gt; { private long total; private List&lt;T&gt; rows; public long getTotal() { return total; } public void setTotal(long total) { this.total = total; } public List&lt;T&gt; getRows() { return rows; } public void setRows(List&lt;T&gt; rows) { this.rows = rows; } public PageResult() { } public PageResult(long total, List&lt;T&gt; rows) { this.total = total; this.rows = rows; }} 问答模块主要业务主要包含两个个表问题表，回答表 问题表包含：问题id，问题标题，内容，发布日期，最新回复时间、最新回复人，发布人id，点赞数，是否解决 回答表包含：回答id，问题id，回答内容，回答日期，回答人id等 完成的主要业务有 1、最新回答列表：最新回复的问题显示在上方， 按回复时间降序排序 2、热门回答列表：按回复数降序排序 3、等待回答列表： 回复数为0按时间升序排序 在问题展示，会将每个问题的回复通过分页查询的形式返回给前端 招聘模块主要业务招聘微服务主要有两块：企业信息和招聘信息 企业表包含：id，name，summary，address，ishot等字段 招聘信息表包含：jobid，jobname，salary，企业id，发布日期，截止日期，状态（0表关闭，1表开启，2表推荐），关注人数等字段 完成的主要业务有 1、展示热门企业列表（通过findByIshot查询） 2、推荐职业列表（通过findTop4ByStateOrderByCreatetimeDesc：查询状态为2并以创建日期降序排序，查询前4条记录） 3、最新职位列表（findTop12ByStateNotOrderByCreatetimeDesc：查询状态不为0并以创建日期降序排序，查询前12条记录） 文章模块主要业务文章表包含：文章id，类别，用户id，文章标题，内容，发布日期，审核状态（0，1），点赞数，是否热门等 完成的主要业务有 1、管理员审核文章：状态改为1 2、用户对文章进行评论 3、通过springdataredis对热门文章缓存,可设置缓存时间 public Article findById(String id) { //先从缓存中查询当前对象 Article article= (Article) redisTemplate.opsForValue().get(\"article_\"+id); //如果没有渠道 if(article==null){ article = articleDao.findById(id).get(); //如果热门存入缓存 if(article.getIshot()==1){ redisTemplate.opsForValue().set(\"article_\"+id,article); } } return article;} 4、利用Elasticsearch和ik分词器完成文章的搜索功能，利用logstash同步mysql至elasticsearch //创建新的实体类，这里只需要一些必须的字段@Document(indexName = \"articleindex\",type = \"article\")public class Article implements Serializable { @Id private String id; //@Field注解作用 //是否能被搜索到 //是否分词，整体匹配还是分词匹配 //是否在页面上显示，即数据库中在该实体类中的字段，就是要显示的 //analyzer,分词 //searchAnalyzer，搜索 @Field(index = true,analyzer=\"ik_max_word\",searchAnalyzer=\"ik_max_word\") private String title; @Field(index = true,analyzer=\"ik_max_word\",searchAnalyzer=\"ik_max_word\") private String content; public String getId() { return id; } public void setId(String id) { this.id = id; } public String getTitle() { return title; } public void setTitle(String title) { this.title = title; } public String getContent() { return content; } public void setContent(String content) { this.content = content; }}//dao层public interface ArticleDao extends ElasticsearchRepository&lt;Article,String&gt; { public Page&lt;Article&gt; findByTitleOrContentLike(String title, String content, Pageable pageable);}//service层 public Page&lt;Article&gt; findByKey(String key, int page, int size) { Pageable pageable= PageRequest.of(page-1,size); return articleDao.findByTitleOrContentLike(key,key,pageable); }//controller层@RequestMapping(value = \"/{key}/{page}/{size}\",method = RequestMethod.GET) public Result findByKey(@PathVariable String key,@PathVariable int page,@PathVariable int size){ Page&lt;Article&gt;pageData=articleService.findByKey(key,page,size); return new Result(true,StatusCode.OK,\"搜索成功\",new PageResult&lt;Article&gt;(pageData.getTotalElements(),pageData.getContent())); } 吐槽模块吐槽表：_id，内容content，发布时间，用户id，点赞数，上级吐槽id 使用springdataMongoDB完成的主要业务有 1、发布吐槽，如果是在别人下面吐槽需要将上级吐槽回复数加1 if(spit.getParentid()!=null&amp;&amp;!\"\".equals(spit.getParentid())){//表示是在别人下面回复 Query query=new Query(); query.addCriteria(Criteria.where(\"_id\").is(spit.getParentid())); Update update=new Update(); update.inc(\"thumbup\",1); mongoTemplate.updateFirst(query,update,\"spit\");} 2、根据上级id查询吐槽列表 3、吐槽点赞，并通过redis使其不能重复点赞 //使用mongoDB原生方式实现自增public void thumbUp(String id){ //方式一,与数据库多次交互性能较低 //Spit spit=spitDao.findById(id).get(); //spit.setThumbup((spit.getThumbup()==null?0:spit.getThumbup())+1); //spitDao.save(spit); //相当于使用原生mongo命令实现自增：db.spit.update({\"_id\":\"1\"},{$inc:{thumbup:NumberInt(1)}}) Query query=new Query(); query.addCriteria(Criteria.where(\"_id\").is(\"id\")); Update update=new Update(); update.inc(\"thumbup\",1); mongoTemplate.updateFirst(query,update,\"spit\"); }@RequestMapping(value = \"/thumbup/{spitId}\",method = RequestMethod.PUT)public Result thumbUp(@PathVariable String spitId){ //由于没有做登陆认证，因此暂时写死ID，实现一个用户只能点赞一次 String userid=\"111\"; if(redisTemplate.opsForValue().get(\"thumbup_\"+userid)!=null){ return new Result(false,StatusCode.REPERROR,\"不能重复点赞\"); }; spitService.thumbUp(spitId); redisTemplate.opsForValue().set(\"thumbup_\"+userid,1); return new Result(true,StatusCode.OK,\"点赞成功\");} 管理员模块管理员登陆，JWT鉴权，在完成鉴权后通过feign可以操作其他模块的业务 1、在招聘模块对关注人数超过一定值的招聘信息可以设置为推荐，删除超过截止日期的招聘信息 2、手动设置热门企业 3、对用户进行管理 4、审核为通过审核文章，删除违规的文章 用户中心模块用户登陆，JWT鉴权，在完成鉴权后通过feign可以操作其他模块的业务 完成的主要业务有 1、用户注册：本地生成6位验证码，redis缓存一份，向rabbitmq发送一份，在处理短信的模块中，监听mq的短信队列拿到想换验证码和手机号，通过阿里云的短信API实现发送短信的功能（处理短信的模块是自动完成的，只需向mq发送相关信息即可） 2、用户登录：通过spring security的BCryptPasswordEncoder实现密码的加密解密，完成用户登录，登录成功通过JWT向用户发送token，以后请求服务需要在头信息中添加token信息 交友模块分为好友表和非好友表 好友表包含：用户id，朋友id，islike（0表单向喜欢，1表双向喜欢） 非好友表包含：用户id，朋友id 完成的业务： 1、当A点击喜欢B，好友表增加记录，非好友表删除A不喜欢B，当B喜欢A，修改islike为1 2、当A点击拉黑B，非好友表增加记录，好友表删除A-B的记录，若B喜欢A，则修改为单向喜欢 3、于此同时，A喜欢B，A的关注数加1，B的粉丝数加1 public int addFriend(String userid, String friendid) { //先判断userid到friendid是否有数据，有就是重复添加好友，返回0 Friend friend=friendDao.findByUseridAndFriendid(userid,friendid); if(friend!=null){ return 0; } //再判断以前是否不喜欢 if(noFriendDao.findByUseridAndFriendid(userid, friendid)!=null){ noFriendDao.deleteByUseridAndFriendid(userid,friendid); } //直接添加好友，让好友表中的userid到friendid方向的type为0 friend=new Friend(); friend.setUserid(userid); friend.setFriendid(friendid); friend.setIslike(\"0\"); friendDao.save(friend); //再判断friendid到userid是否有数据，如果有则把双方的状态都改为1 if(friendDao.findByUseridAndFriendid(friendid,userid)!=null){ //把双方islike都改为1 friendDao.updateIslike(\"1\",userid,friendid); friendDao.updateIslike(\"1\",friendid,userid); }; return 1;}public int addNoFriend(String userid,String friendid) { //先判断是否已经是非好友 NoFriend noFriend=noFriendDao.findByUseridAndFriendid(userid, friendid); if(noFriend!=null){ return 0; } //如果之前是好友，现在单方面删除 if(friendDao.findByUseridAndFriendid(userid,friendid)!=null){ friendDao.deleteByUseridAndFriendid(userid,friendid); if(friendDao.findByUseridAndFriendid(friendid,userid)!=null) friendDao.updateIslike(\"0\",friendid,userid); } //删完再添加到noFriend表 noFriend=new NoFriend(); noFriend.setUserid(userid); noFriend.setFriendid(friendid); noFriendDao.save(noFriend); return 1; } 完成项目的微服务化 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[]},{"title":"使用jekins完成项目部署于Docker容器","date":"2020-06-30T07:52:28.000Z","path":"2020/06/30/使用jekins完成项目部署/","text":"使用jekins完成项目部署于Docker容器创建Docker私有仓库创建私有仓库容器拉去镜像，创建容器docker pull registrydocker run ‐di ‐‐name=registry ‐p 5000:5000 registry 打开浏览器 输入地址http://192.168.xxx.xxx:5000/v2/_catalog 看到 {“repositories”:[]} 表示私有仓库搭建成功并且内容为空 修改daemon.json让docker信任私有仓库 vi /etc/docker/daemon.json{\"insecure‐registries\":[\"192.168.xxx.xxx:5000\"]} maven插件自动部署修改宿主机docker配置使其可以远程访问vi /lib/systemd/system/docker.service其中ExecStart=后添加配置 ‐H tcp://0.0.0.0:2375 ‐H unix:///var/run/docker.sock 发布的项目pom文件引入插件&lt;build&gt; &lt;finalName&gt;tensquare_config&lt;/finalName&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;!--docker的maven插件，官网： https://github.com/spotify/docker‐maven‐plugin --&gt; &lt;plugin&gt; &lt;groupId&gt;com.spotify&lt;/groupId&gt; &lt;artifactId&gt;docker-maven-plugin&lt;/artifactId&gt; &lt;version&gt;0.4.13&lt;/version&gt; &lt;configuration&gt; &lt;!--上传私有仓库--&gt; &lt;imageName&gt;192.168.152.xx:5000/${project.artifactId}:${project.version}&lt;/imageName&gt; &lt;!--基础镜像，意味着docker容器中已经存在jdk8的镜像--&gt; &lt;baseImage&gt;jdk8&lt;/baseImage&gt; &lt;!--打包命令--&gt; &lt;entryPoint&gt;[\"java\", \"-jar\", \"/${project.build.finalName}.jar\"]&lt;/entryPoint&gt; &lt;resources&gt; &lt;resource&gt; &lt;targetPath&gt;/&lt;/targetPath&gt; &lt;directory&gt;${project.build.directory} &lt;/directory&gt; &lt;include&gt;${project.build.finalName}.jar&lt;/include&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;dockerHost&gt;http://192.168.152.xx:2375&lt;/dockerHost&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 进入该工程所在目录执行命令mvn clean package docker:build -DpushImage 代码管理服务gogs安装gogsdocker pull gogs/gogsdocker run -d --name=gogs -p 10022:22 -p 3000:3000 -v /var/gogsdata:/data gogs/gogs 配置gogs在地址栏输入http://192.168.xxx.xxx:3000 会进入首次运行安装程序页面，我们可以选择一种数据库作为gogs数据的存储，最简单的是选择SQLite3。如果对于规模较大的公司，可以选择MySQL 页面展示idea上传至gogs仓库 jekins持续继承配置jekins下载安装完后需要配置用户和端口号JENKINS_USER=\"root\"JENKINS_PORT=\"8888\" 首次进入，安装插件主要的插件有两个一个是maven一个是git 全局工具配置服务器安装maven，JDK JDK配置git配置（一般服务器都已经安装）maven配置持续继承创建一个maven项目 源码管理选gitURL填写gogs仓库的地址 Buildpom要填写生成容器的子项目 执行任务 结果展示docker镜像 私有仓库 运行后可以成功展示！ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"jekins","slug":"jekins","permalink":"https://xulilei.github.io/tags/jekins/"},{"name":"gogs","slug":"gogs","permalink":"https://xulilei.github.io/tags/gogs/"}]},{"title":"集中配置组件SpringCloudConfig","date":"2020-06-26T07:58:27.000Z","path":"2020/06/26/集中配置组件SpringCloudConfig/","text":"集中配置组件SpringCloudConfigSpring Cloud Config简介在分布式系统中，由于服务数量巨多，为了方便服务配置文件统一管理，实时更新，所 以需要分布式配置中心组件。在Spring Cloud中，有分布式配置中心组件spring cloud config ，它支持配置服务放在配置服务的内存中（即本地），也支持放在远程Git仓库 中。在spring cloud config 组件中，分两个角色，一是config server，二是config client。 config server它用于集中管理应用程序各个 环境下的配置，默认使用Git存储配置文件内容 导入config-server依赖&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-config-server&lt;/artifactId&gt;&lt;/dependency&gt; 启动类添加@EnableConfigServer@SpringBootApplication@EnableConfigServerpublic class ConfigApplication { public static void main(String[] args) { SpringApplication.run(ConfigApplication.class); }} 修改配置文件这里如果uri使用的是http，则会出现不能clone仓库内容的错误，因此要换成ssh，并添加private-key，该配置文件不需要上传至云端 server: port: 12000spring: application: name: tensquare-config rabbitmq: host: 192.168.152.** cloud: config: server: git: uri: git@gitee.com:***/tensquare.git ignore-local-ssh-settings: true private-key: | -----BEGIN RSA PRIVATE KEY----- MIIEowIBAAKCAQEAxawgOKaig29oj/OqSVY9njJMnIYmedq4A7wvKEpg3Q/wYRl0 DO1QOl13ilyj20MyXUEUKON4dKWoBl+2/zhTtyI5cCDhcnISYAp9JSkYSzm8DTDp E+1Zwmq2yYE68mr5/UaRbhOHBPGr1GwrTNuraqnOtNDjUXm25E4HiCmHoc395RpA -----END RSA PRIVATE KEY----- config clientConfig Client是Config Server的客户端，用于操作存储在Config Server中的配置内容。 微服务在启动时会请求Config Server获取配置文件的内容，请求到后再启动容器。 导入config client依赖&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt;&lt;/dependency&gt; 上传配置文件application.yml至gitee文件命名规则： {application}-{profile}.yml或{application}-{profile}.properties 其中application为应用名称，profile指的开发环境（用于区分开发环境，测试环境、生产环境等） 更换配置文件为bootstrap.ymlspring: cloud: config: #这个对应gitee配置文件的命名规则 name: base profile: dev label: master uri: http://127.0.0.1:12000 消息总线组件SpringCloudBusSpringCloudBus简介当云端修改配置文件后，本地不用修改和再次编译，只需向消息中间件发送一条修改提醒即可使得配置文件即时生效 配置服务端config-server导入SpringCloudBus和rabbitmq依赖&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-bus&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-stream-binder-rabbit&lt;/artifactId&gt;&lt;/dependency&gt; 修改配置文件spring: rabbitmq: host: 192.168.152.128#暴露触发消息总线的地址，management: endpoints: web: exposure: include: bus-refresh 配置客户端功能子模块导入依赖&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-bus&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-stream-binder-rabbit&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt; 云端配置文件添加rabbitmq地址rabbitmq: host: 192.168.184. document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"SpringCloudConfig","slug":"SpringCloudConfig","permalink":"https://xulilei.github.io/tags/SpringCloudConfig/"}]},{"title":"微服务网关Zuul","date":"2020-06-26T07:40:35.000Z","path":"2020/06/26/微服务网关Zuul/","text":"微服务网关Zuul相关概念为什么使用网关不同的微服务一般有不同的网络地址，而外部的客户端可能需要调用多个服务的接口才 能完成一个业务需求。 如果客户端直接和微服务进行通信，会存在一下问题： 1、客户端会多次请求不同微服务，增加客户端的复杂性 2、存在跨域请求，在一定场景下处理相对复杂 3、认证复杂，每一个服务都需要独立认证 上述问题，都可以借助微服务网关解决。微服务网关是介于客户端和服务器端之间的中间层，所有的外部请求都会先经过微服务网关。 什么是zuulZuul是Netflix开源的微服务网关，他可以和Eureka,Ribbon,Hystrix等组件配合使用。 Zuul组件的核心是一系列的过滤器，这些过滤器可以完成以下功能： 1、身份认证和安全: 识别每一个资源的验证要求，并拒绝那些不符的请求 2、动态路由：动态将请求路由到不同后端集群 Zuul使用网关模块导入相关依赖zuul是依赖eureka实现的，通过微服务的name在eureka的服务器上寻找到对应的路径 &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-zuul&lt;/artifactId&gt;&lt;/dependency&gt; 配置application,ymlserver: port: 9011spring: application: name: tensquare-managereureka: client: service-url: defaultZone: http://127.0.0.1:6868/eureka/ instance: prefer‐ip‐address: truezuul: routes: tensquare-base: path: /base/** serviceId: tensquare-base tensquare-user: path: /user/** serviceId: tensquare-user tensquare-qa: path: /qa/** serviceId: tensquare-qa 修改启动类@SpringBootApplication@EnableEurekaClient@EnableZuulProxypublic class ManagerApplication { public static void main(String[] args) { SpringApplication.run(ManagerApplication.class); } @Bean public JwtUtil jwtUtil(){ return new JwtUtil(); }} 实例：通过ZuulFilter实现身份验证功能创建Filter类继承ZuulFilter，并实现其中的方法，具体细节请看注释 @Componentpublic class ManagerFilter extends ZuulFilter { @Autowired private JwtUtil jwtUtil; //过滤器类型 //“pre”执行之前，“post”执行时 @Override public String filterType() { return \"pre\"; } //排序，0表示优先执行 @Override public int filterOrder() { return 0; } //表示当前过滤器是否开启，true为开启 @Override public boolean shouldFilter() { return true; } //过滤器内执行的操作，return任何object表示继续执行， //setSendZullResponse(false)表示不再继续执行 @Override public Object run() throws ZuulException { //通过com.netflix.zuul得到request上下文 RequestContext currentContext =RequestContext.getCurrentContext(); //得到request域 HttpServletRequest request = currentContext.getRequest(); // 第一次转发始终放行，因为是根据配置文件中的路径去找其他服务 if(request.getMethod().equals(\"OPTIONS\")){ return null; } //登陆放行 if(request.getRequestURI().indexOf(\"login\")&gt;0){ return null; } //得到头信息 String header = request.getHeader(\"Authorization\"); if(header!=null&amp;&amp;!\"\".equals(header)){ if(header.startsWith(\"Bearer \")){ String token=header.substring(7); try { Claims claims = jwtUtil.parseJWT(token); String role= (String) claims.get(\"roles\"); if(role.equals(\"admin\")){ //把头信息继续往下传 currentContext.addZuulRequestHeader(\"Authorization\",header); return null; } }catch (Exception e){ //终止运行 currentContext.setSendZuulResponse(false); } } } //header为空返回错误信息 currentContext.setSendZuulResponse(false); currentContext.setResponseStatusCode(403); return null; }} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"zuul","slug":"zuul","permalink":"https://xulilei.github.io/tags/zuul/"}]},{"title":"Hystrix入门","date":"2020-06-25T13:58:25.000Z","path":"2020/06/25/Hystrix“入门/","text":"Hystrix熔断器相关概念为什么要使用熔断器在微服务架构中通常会有多个服务层调用，基础服务的故障可能会导致级联故障， 进而造成整个系统不可用的情况，这种现象被称为服务雪崩效应。而熔断器的产生，则有效规避了雪崩效应 熔断器工作机制当服务的某个API接口的失败次数在一定时间内小于设定的阈值时，熔断器处于关闭状态，该API接口正常提供服务。当该API接口处理请求的失败次数大于设定的阈值时，Hystrix判定该API接口出现了故障，打开熔断器，这时该API接口会执行快速失败的逻辑，不执行业务逻辑，请求的线程不会处于阻塞状态。处于打开状态的熔断器在一定时间后会处于半打开状态，并将一定数量的请求执行正常逻辑，剩余的请求会执行快速失败。若执行正常逻辑的请求失败了，则熔断器继续打开，若成功了，则熔断器关闭。这样熔断器就具有了自我修复的功能。 使用配置文件开启hystrix支持Feign本身支持Hystrix，因此不需要导入额外依赖 feign: hystrix: enabled: true 创建实现feign接口的实现类在声明式接口中的@FeignClient注解上添加fallback属性来配置快速失败的处理类。该处理类作为Feign熔断器的逻辑处理类，必须实现被@FeignClient修饰的接口 @FeignClient(value = \"tensquare-base\",fallback = BaseClientImpl.class)public interface BaseClient { @RequestMapping(value = \"/label/{labelId}\",method = RequestMethod.GET) public Result findById(@PathVariable(\"labelId\") String labelId);}@Componentpublic class BaseClientImpl implements BaseClient { @Override public Result findById(String labelId) { return new Result(false, StatusCode.ERROR,\"失败\"); }} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Hystrix","slug":"Hystrix","permalink":"https://xulilei.github.io/tags/Hystrix/"}]},{"title":"SpringCloud架构模型","date":"2020-06-25T13:54:19.000Z","path":"2020/06/25/cloud常见模块/","text":"Spring Cloud架构模型 服务发现组件EurekaEureka是Netflix开发的服务发现框架，SpringCloud将它集成在自己的子项目spring-cloud-netflix中，实现SpringCloud的服务发现功能。Eureka包含两个组件：Eureka Server和Eureka Client。 Eureka Server提供服务注册服务，各个节点启动后，会在Eureka Server中进行注册，这样EurekaServer中的服务注册表中将会存储所有可用服务节点的信息，服务节点的信息可以在界面中直观的看到。 详见：https://xulilei.github.io/2020/06/21/eureka%E5%85%A5%E9%97%A8/ 服务间调用Feignfeign是声明式的web service客户端，它让微服务之间的调用变得更简单了，类似controller调用service。Spring Cloud集成了Ribbon和Eureka，可在使用Feign时提供负载均衡的http客户端 详见：https://xulilei.github.io/2020/06/21/eureka%E5%85%A5%E9%97%A8/ 熔断器Hystrix在微服务架构中通常会有多个服务层调用，基础服务的故障可能会导致级联故障， 进而造成整个系统不可用的情况，这种现象被称为服务雪崩效应。而熔断器的产生，则有效规避了雪崩效应 当服务的某个API接口的失败次数在一定时间内小于设定的阈值时，熔断器处于关闭状态，该API接口正常提供服务。当该API接口处理请求的失败次数大于设定的阈值时，Hystrix判定该API接口出现了故障，打开熔断器，这时该API接口会执行快速失败的逻辑，不执行业务逻辑，请求的线程不会处于阻塞状态。处于打开状态的熔断器在一定时间后会处于半打开状态，并将一定数量的请求执行正常逻辑，剩余的请求会执行快速失败。若执行正常逻辑的请求失败了，则熔断器继续打开，若成功了，则熔断器关闭。这样熔断器就具有了自我修复的功能。 详见：","tags":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://xulilei.github.io/tags/SpringCloud/"}]},{"title":"daySeven-eureka","date":"2020-06-21T15:04:08.000Z","path":"2020/06/21/十次方daySeven/","text":"交友服务搭建主要业务添加喜欢业务逻辑有两张表分别为tb_friend和tb_nofriend，当A添加喜欢B，先在tb_friend表中查询有无数据，如果有则代表已经添加喜欢了，回复不可重复添加，然后在tb_nofriend中查询是否之前A不喜欢B，如果有记录，则删除该记录。并在tb_friend中添加一条从A-B的记录，且状态为0，代表单向喜欢。如果在添加记录时，恰哈发现B-A已经有数据了，那么则将二者的状态都改为1，代表双向喜欢 业务实现，service层public int addFriend(String userid, String friendid) { //先判断userid到friendid是否有数据，有就是重复添加好友，返回0 Friend friend=friendDao.findByUseridAndFriendid(userid,friendid); if(friend!=null){ return 0; } //再判断以前是否不喜欢 if(noFriendDao.findByUseridAndFriendid(userid, friendid)!=null){ noFriendDao.deleteByUseridAndFriendid(userid,friendid); } //直接添加好友，让好友表中的userid到friendid方向的type为0 friend=new Friend(); friend.setUserid(userid); friend.setFriendid(friendid); friend.setIslike(\"0\"); friendDao.save(friend); //再判断friendid到userid是否有数据，如果有则把双方的状态都改为1 if(friendDao.findByUseridAndFriendid(friendid,userid)!=null){ //把双方islike都改为1 friendDao.updateIslike(\"1\",userid,friendid); friendDao.updateIslike(\"1\",friendid,userid); }; return 1;} 添加不喜欢业务逻辑当A添加B为不喜欢，首先查询tb_nofriend中是否已经有数据，如果有则提示不可重复拉黑。然后再去tb_friend中查询是否有A-B的喜欢，如果有则删除该记录，同时查询B-A是否也有记录，有则代表之前是双向喜欢，此时应将B-A的状态改为0，最后在tb_nofriend中添加一行A-B数据。 业务实现，service层public int addNoFriend(String userid,String friendid) { //先判断是否已经是非好友 NoFriend noFriend=noFriendDao.findByUseridAndFriendid(userid, friendid); if(noFriend!=null){ return 0; } //如果之前是好友，现在单方面删除 if(friendDao.findByUseridAndFriendid(userid,friendid)!=null){ friendDao.deleteByUseridAndFriendid(userid,friendid); //如果之前双向喜欢，则改为单向喜欢 if(friendDao.findByUseridAndFriendid(friendid,userid)!=null) friendDao.updateIslike(\"0\",friendid,userid); } //删完再添加到noFriend表 noFriend=new NoFriend(); noFriend.setUserid(userid); noFriend.setFriendid(friendid); noFriendDao.save(noFriend); return 1;} 上述功能用到的Dao层FriendDaopublic interface FriendDao extends JpaRepository&lt;Friend,String&gt; { public Friend findByUseridAndFriendid(String userid,String friendid); @Modifying @Query(value =\"update tb_friend SET islike=? where userid=? and friendid=?\",nativeQuery = true) public void updateIslike(String islike,String userid,String friendid); public void deleteByUseridAndFriendid(String userid,String friendid);} NoFriendDaopublic interface NoFriendDao extends JpaRepository&lt;NoFriend,String&gt; { public NoFriend findByUseridAndFriendid(String userid, String friendid); public void deleteByUseridAndFriendid(String userid,String friendid);} feign调用user模块业务业务逻辑当A添加B为喜欢时，在tb_user表中，userA的关注数+1，B的粉丝数+1。当A添加B为不喜欢时，userA的关注数-1，B的粉丝数-1。 User模块中粉丝关注业务实现Dao层public interface UserDao extends JpaRepository&lt;User,String&gt;,JpaSpecificationExecutor&lt;User&gt;{ @Modifying @Query(value =\"update tb_user set fanscout=fanscount+? where id=?\" ,nativeQuery = true) public void updateFans(int x, String friendid); @Modifying @Query(value =\"update tb_user set followcount=followcount+? where id=?\" ,nativeQuery = true) public void updateFollows(int x, String userid);} Service层@Transactionalpublic void updateFansAndFollowCounts(int x, String userid, String friendid) { //friendB粉丝数+1，userA的关注数+1 userDao.updateFans(x,friendid); userDao.updateFollows(x,userid);} Controller层//不返回result是因为这个业务是服务之间的调用，不涉及前台@RequestMapping(value = \"/{userid}/{friendid}/x\",method = RequestMethod.PUT)public void updateFansAndFollowCounts(@PathVariable int x,@PathVariable String userid,@PathVariable String friendid){ userService.updateFansAndFollowCounts(x,userid,friendid);} 交友模块中调用上述业务启动类添加相应注解@SpringBootApplication@EnableEurekaClient@EnableDiscoveryClient@EnableFeignClientspublic class FriendApplication { public static void main(String[] args) { SpringApplication.run(FriendApplication.class); }} 创建client@FeignClient(\"tensquare-user\")public interface UserClient { @RequestMapping(value = \"/user/{userid}/{friendid}/x\",method = RequestMethod.PUT) public void updateFansAndFollowCounts (@PathVariable(\"x\") int x, @PathVariable(\"userid\") String userid, @PathVariable(\"friendid\") String friendid);} controller层调用//添加喜欢if(flag==1){ userClient.updateFansAndFollowCounts(1,userid,friendid); return new Result(true, StatusCode.OK,\"添加成功\");}//添加不喜欢if(flag==1){ userClient.updateFansAndFollowCounts(-1,userid,friendid); return new Result(true, StatusCode.OK,\"添加成功\");} 交友服务controller层整合@RequestMapping(value = \"/like/{friendid}/{type}\",method = RequestMethod.PUT )public Result addFriend(@PathVariable String friendid,@PathVariable String type){ //验证是否登陆，并拿到ID Claims claims = (Claims) request.getAttribute(\"user_claims\"); if(claims==null){ return new Result(false, StatusCode.LOGINERROR,\"权限不足\"); } String userid = claims.getId(); System.out.println(userid); //判断是添加好友还是非好友，直接传进来一个类型type，当type为1时，表示添加，2时表示拉黑 if(type!=null){ if(type.equals(\"1\")){ int flag=friendService.addFriend(userid,friendid); if(flag==0){ return new Result(false, StatusCode.ERROR,\"不能重复添加好友\"); } if(flag==1){ //后文介绍的添加粉丝与关注 userClient.updateFansAndFollowCounts(1,userid,friendid); return new Result(true, StatusCode.OK,\"添加成功\"); } //添加好友 }else if(type.equals(\"2\")) { //添加黑名单 int flag= friendService.addNoFriend(userid,friendid); if(flag==0){ return new Result(false, StatusCode.ERROR,\"不能重复拉黑好友\"); } if(flag==1){ //后文介绍的减少粉丝与关注 userClient.updateFansAndFollowCounts(-1,userid,friendid); return new Result(true, StatusCode.OK,\"添加成功\"); } } } return new Result(false, StatusCode.ERROR,\"参数异常\");} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"项目","slug":"项目","permalink":"https://xulilei.github.io/tags/%E9%A1%B9%E7%9B%AE/"},{"name":"Eureka","slug":"Eureka","permalink":"https://xulilei.github.io/tags/Eureka/"},{"name":"交友业务","slug":"交友业务","permalink":"https://xulilei.github.io/tags/%E4%BA%A4%E5%8F%8B%E4%B8%9A%E5%8A%A1/"}]},{"title":"eureka入门","date":"2020-06-21T07:50:02.000Z","path":"2020/06/21/eureka入门/","text":"服务发现组件Eureka相关概念Eureka简介Eureka是Netflix开发的服务发现框架，SpringCloud将它集成在自己的子项目spring-cloud-netflix中，实现SpringCloud的服务发现功能。Eureka包含两个组件：Eureka Server和Eureka Client。 Eureka ServerEureka Server提供服务注册服务，各个节点启动后，会在Eureka Server中进行注册，这样EurekaServer中的服务注册表中将会存储所有可用服务节点的信息，服务节点的信息可以在界面中直观的看到。 服务端开发第一步，在父工程中锁定版本，每一个版本的springboot都对应一个版本的springcloud &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;Finchley.M9&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 第二步，Eureka子模块添加eureka-server &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 第三步，添加application.yml server: port: 6868eureka: client: register-with-eureka: false #是否将自己注册到Eureka服务中，本身就是所有无需注册 fetch-registry: false service-url: #Eureka客户端与Eureka服务端进行交互的地址 defaultZone: http://127.0.0.1:${server.port}/eureka/ 第四步，启动类 @SpringBootApplication@EnableEurekaServerpublic class EurekaServer { public static void main(String[] args) { SpringApplication.run(EurekaServer.class); }} Eureka ClientEureka Client是一个java客户端，用于简化与Eureka Server的交互，客户端同时也 就别一个内置的、使用轮询(round-robin)负载算法的负载均衡器。 客户端开发第一步，客户端模块添加eureka-client &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt; 第二步，修改每个微服务的application.yml，添加注册eureka服务的配置 eureka: client: service-url: defaultZone: http://127.0.0.1:6868/eureka/ instance: prefer‐ip‐address: true #跨域 第三步，启动类 @SpringBootApplication@EnableEurekaClient public class UserApplication { public static void main(String[] args) { SpringApplication.run(UserApplication.class, args); }} Feign实现服务间的调用谁调用别人就在谁的模块中搭建环境第一步，添加openfeign依赖&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;&lt;/dependency&gt; 第二步，启动类@SpringBootApplication@EnableEurekaClient//Eureka客户端@EnableDiscoveryClient//可以发现服务@EnableFeignClients//通过feign调用其他服务的业务public class QaApplication { public static void main(String[] args) { SpringApplication.run(QaApplication.class, args); }} 第三步，创建client包，创建要调用目标的接口默认采用的是ribbon的轮询负载均衡算法 //调用目标的名字，注意这里不能使用下划线，这也是其他模块的application.yml中名字不加下划线的原因@FeignClient(\"tensquare-base\")//调用目标controller层的方法public interface BaseClient { @RequestMapping(value = \"/label/{labelId}\",method = RequestMethod.GET) //这里的 @PathVariable 后面要加上具体的参数名称(\"labelId\")不然会找不到 public Result findById(@PathVariable(\"labelId\") String labelId);} 相关实践详见：https://xulilei.github.io/2020/06/21/%E5%8D%81%E6%AC%A1%E6%96%B9daySeven/ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"eureka","slug":"eureka","permalink":"https://xulilei.github.io/tags/eureka/"}]},{"title":"daySix-JWT-BCryptPasswordEncoder","date":"2020-06-18T02:27:02.000Z","path":"2020/06/18/十次方daySix/","text":"管理员登陆验证与删除鉴权 利用Spring Security的BCryptPasswordEncoder与JWT实现 登陆验证签发tokenservice层public Admin login(Admin admin) { //想根据用户名查询对象 Admin adminLogin=adminDao.findByLoginname(admin.getLoginname()); //然后拿数据库中的密码和用户输入的密码匹配是否相同 if(adminLogin!=null&amp;&amp;encoder.matches(admin.getPassword(),adminLogin.getPassword())){ return adminLogin; } //登陆失败 return null;} controller层@RequestMapping(value = \"/login\",method = RequestMethod.POST)public Result login(@RequestBody Admin admin){ Admin adminLoginResult=adminService.login(admin); if(adminLoginResult==null){ return new Result(false,StatusCode.LOGINERROR,\"登陆失败\"); } //做一系列前后端通话的工作，用JWT来实现 //生成token并返回给客户端 String token=jwtUtil.createJWT(adminLoginResult.getId(),adminLoginResult.getLoginname(),\"admin\"); Map&lt;String,Object&gt;map=new HashMap&lt;&gt;(); map.put(\"token\",token); map.put(\"role\",\"admin\"); return new Result(true,StatusCode.OK,\"登陆成功\",map);} 返回给前端的token 利用拦截器解析token拦截器只是为了将请求头中的token解析成user和admin解析后将气保存在域对象中，等需要鉴权时，直接通过获取这个域对象的值来分别是user还是admin @Componentpublic class JwtInterceptor implements HandlerInterceptor { @Autowired private JwtUtil jwtUtil; public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { //无论如何都放行，具体能不能操作要在具体的操作中去判断 //拦截器只是负责把请求头中包含的token令牌解析成user和admin String header=request.getHeader(\"Authorization\"); if(header!=null&amp;&amp;header.startsWith(\"Bearer \")){ String token=header.substring(7); try { Claims claims = jwtUtil.parseJWT(token); if(claims!=null){ if(\"admin\".equals(claims.get(\"roles\"))){ request.setAttribute(\"admin_claims\",token); } if(\"user\".equals(claims.get(\"roles\"))){ request.setAttribute(\"user_claims\",token); } } }catch (Exception e){ //过期 throw new RuntimeException(\"token错误\"); } } return true; }} 注册拦截器当然不用拦截登陆请求了 @Configurationpublic class InterceptorConfig extends WebMvcConfigurationSupport { @Autowired private JwtInterceptor jwtInterceptor; @Override protected void addInterceptors(InterceptorRegistry registry) { //注册拦截器要声明的拦截器对象和要拦截的请求 registry.addInterceptor(jwtInterceptor) .addPathPatterns(\"/**\") .excludePathPatterns(\"/**/login\"); }} 管理员删除用户直接从域对象中获取admin_claims，如果有则说明该登陆用户为管理员，则可以删除用户，否则提示权限不足 @Autowired private HttpServletRequest request;public void deleteById(String id) { String token = (String) request.getAttribute(\"admin_claims\"); if(token==null||\"\".equals(token)){ throw new RuntimeException(\"权限不足\"); } userDao.deleteById(id);} 当header中的token无法解析时 当header中的token正确时 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"项目","slug":"项目","permalink":"https://xulilei.github.io/tags/%E9%A1%B9%E7%9B%AE/"},{"name":"Spring Security","slug":"Spring-Security","permalink":"https://xulilei.github.io/tags/Spring-Security/"},{"name":"BCryptPasswordEncoder","slug":"BCryptPasswordEncoder","permalink":"https://xulilei.github.io/tags/BCryptPasswordEncoder/"},{"name":"JWT","slug":"JWT","permalink":"https://xulilei.github.io/tags/JWT/"},{"name":"鉴权","slug":"鉴权","permalink":"https://xulilei.github.io/tags/%E9%89%B4%E6%9D%83/"},{"name":"密码加密","slug":"密码加密","permalink":"https://xulilei.github.io/tags/%E5%AF%86%E7%A0%81%E5%8A%A0%E5%AF%86/"}]},{"title":"Spring Security加密与JWT鉴权","date":"2020-06-18T02:26:39.000Z","path":"2020/06/18/SpringSecurity加密与JWT鉴权/","text":"SpringSecurity加密与JWT鉴权Spring Security的BCryptPasswordEncoder使用过程引入依赖&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;&lt;/dependency&gt; 添加配置类如果只是使用BCryptPasswordEncoder，这个配置可以直接拿来用 @Configuration@EnableWebSecuritypublic class WebSecurityConfig extends WebSecurityConfigurerAdapter{ @Override protected void configure(HttpSecurity http) throws Exception { //authorizeRequests是所有security全注解配置实现的开端 //需要的权限分两部分，第一部分是拦截的路径，第二部分是访问该路径需要的权限 //antMatchers，表示拦截的路径，permitAll表示任何权限都可以访问，直接放行所有 //这里主要是用security的加密功能，拦截功能用的是jwt //anyRequest()任何的请求，authenticated()认证后访问 //and().csrf().disable()表示使csrf攻击失效 http .authorizeRequests() .antMatchers(\"/**\").permitAll() .anyRequest().authenticated() .and().csrf().disable(); }} 配置BCryptPasswordEncoder交给容器@Beanpublic BCryptPasswordEncoder bCryptPasswordEncoder(){ return new BCryptPasswordEncoder();} 密码加密service层 public void add(User user) { user.setId( idWorker.nextId()+\"\" ); //密码加密 user.setPassword(encoder.encode(user.getPassword())); userDao.save(user);} 密码验证service层 public User login(String mobile,String password) { //先通过前台传过来的电话查询出user User user=userDao.findByMobile(mobile); //再比对user的密码，用encoder.match(原密码,加密后的密码) if(user!=null&amp;&amp;encoder.matches(password,user.getPassword())){ return user; } return null;} JWT鉴权常见的鉴权方式Cookie认证Cookie认证机制就是为一次请求认证在服务端创建一个Session对象，同时在客户端 的浏览器端创建了一个Cookie对象；通过客户端带上来Cookie对象来与服务器端的 session对象匹配来实现状态管理的。 Token认证使用基于 Token 的身份验证方法，在服务端不需要存储用户的登录记录。大概的流程是 这样的： 客户端使用用户名跟密码请求登录 服务端收到请求，去验证用户名与密码 验证成功后，服务端会签发一个 Token，再把这个 Token 发送给客户端 客户端收到 Token 以后可以把它存储起来，比如放在 Cookie 里 客户端每次向服务端请求资源的时候需要带着服务端签发的 Token 服务端收到请求，然后去验证客户端请求里面带着的 Token，如果验证成功，就向 客户端返回请求的数据 两者对比Token的优势 支持跨域访问: Cookie是不允许垮域访问的，这一点对Token机制是不存在的，前提 是传输的用户认证信息通过HTTP头传输. 无状态:Token机制在服务端不需要存储session信息，因为 Token 自身包含了所有登录用户的信息，只需要在客户端的cookie或本地介质存储状态信息. 去耦: 不需要绑定到一个特定的身份验证方案。Token可以在任何地方生成，只要在 你的API被调用的时候，你可以进行Token生成调用即可. 一次网络往返时间（通过数据库查询session信息）总比做一次HMACSHA256计算的Token验证和解析要费时得多. 基于标准化:你的API可以采用标准化的 JSON Web Token (JWT) JWT介绍一个JWT实际上就是一个字符串，它由三部分组成，头部、载荷与签名，且生成后都会采用base64进行编码。 头部（Header）头部用于描述关于该JWT的最基本的信息，例如其类型以及签名所用的算法等。这也可以 被表示成一个JSON对象，如下指明了采用了JWT的算法为HS256 {\"typ\":\"JWT\",\"alg\":\"HS256\"} base64编码后：eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9 载荷（playload）一般包含ID，用户SUB，身份roles，比如 {\"id\":\"1234567890\",\"sub\":\"John Doe\",\"roles\":\"admin\"} 会再次进行base64编码 签证（signature）包含头部，载荷，以及定义的salt，同样进行base编码 最终JWT会将三部分连接成一个字符串，以.连接 eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6I kpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ JJWT：Java JWT添加依赖&lt;dependency&gt; &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt; &lt;artifactId&gt;jjwt&lt;/artifactId&gt; &lt;version&gt;0.6.0&lt;/version&gt;&lt;/dependency&gt; 在common包下的util包中创建JWT工具类这个工具类，需要提供ID,SUB,ROLE作为claims @ConfigurationProperties(\"jwt.config\")public class JwtUtil { private String key ; private long ttl ;//一个小时 public String getKey() { return key; } public void setKey(String key) { this.key = key; } public long getTtl() { return ttl; } public void setTtl(long ttl) { this.ttl = ttl; } /** * 生成JWT * @param id * @param subject * @return */ public String createJWT(String id, String subject, String roles) { long nowMillis = System.currentTimeMillis(); Date now = new Date(nowMillis); JwtBuilder builder = Jwts.builder().setId(id) .setSubject(subject) .setIssuedAt(now) .signWith(SignatureAlgorithm.HS256, key).claim(\"roles\", roles); if (ttl &gt; 0) { builder.setExpiration( new Date( nowMillis + ttl)); } return builder.compact(); } /** * 解析JWT * @param jwtStr * @return */ public Claims parseJWT(String jwtStr){ return Jwts.parser() .setSigningKey(key) .parseClaimsJws(jwtStr) .getBody(); }} jwt.config哪里用到了这个工具类，哪里的application.yml添加jwt定义，哪里传入jwtUtil @Bean public JwtUtil jwtUtil(){ return new util.JwtUtil(); } jwt: config: key: itcast ttl: 360000 以admin的登陆与删除鉴权为例详见：https://xulilei.github.io/2020/06/18/%E5%8D%81%E6%AC%A1%E6%96%B9daySix/ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Spring Security","slug":"Spring-Security","permalink":"https://xulilei.github.io/tags/Spring-Security/"},{"name":"BCryptPasswordEncoder","slug":"BCryptPasswordEncoder","permalink":"https://xulilei.github.io/tags/BCryptPasswordEncoder/"},{"name":"JWT","slug":"JWT","permalink":"https://xulilei.github.io/tags/JWT/"},{"name":"鉴权","slug":"鉴权","permalink":"https://xulilei.github.io/tags/%E9%89%B4%E6%9D%83/"},{"name":"密码加密","slug":"密码加密","permalink":"https://xulilei.github.io/tags/%E5%AF%86%E7%A0%81%E5%8A%A0%E5%AF%86/"}]},{"title":"dayFive-rabbitmq","date":"2020-06-15T10:53:31.000Z","path":"2020/06/15/十次方dayFive/","text":"用户注册模块搭建在user模块添加发送短信业务service层public void sendMsg(String mobile) { //生成六位随机数 String checkCode = RandomStringUtils.randomNumeric(6); //向缓存中放一份 redisTemplate.opsForValue().set(\"checkCode\"+mobile,checkCode,6, TimeUnit.HOURS); //给用户发一份，先存放至rabbitmq中 Map&lt;String,String&gt;map=new HashMap&lt;&gt;(); map.put(\"mobile\",mobile); map.put(\"checkCode\",checkCode); rabbitTemplate.convertAndSend(\"sms\",map);} controller层@RequestMapping(value =\"/sendsms/{mobile}\",method = RequestMethod.POST)public Result sendMsg(@PathVariable String mobile){ userService.sendMsg(mobile); return new Result(true,StatusCode.OK,\"发送成功\");} 在rabbitmq短信监听模块通过阿里云实施发送短信导入阿里云依赖&lt;dependency&gt; &lt;groupId&gt;com.aliyun&lt;/groupId&gt; &lt;artifactId&gt;aliyun-java-sdk-core&lt;/artifactId&gt; &lt;version&gt;4.5.0&lt;/version&gt;&lt;/dependency&gt; 根据阿里云官网API创建工具类@Componentpublic class SmsUtil { private static final String accessKeyId=\"LTAI4GCjWSbTHQzGTaavF**\"; private static final String accessKeySecret=\"sDiW0PSXaAKXfNfwCI8vaG4spE4**\"; private static final String signName=\"******\"; private static final String templateCode=\"SMS_1932477**\"; public void sendSms(String mobile,String checkCode) { DefaultProfile profile = DefaultProfile.getProfile(\"default\", accessKeyId, accessKeySecret); IAcsClient client = new DefaultAcsClient(profile); CommonRequest request = new CommonRequest(); request.setSysMethod(MethodType.POST); request.setSysDomain(\"dysmsapi.aliyuncs.com\"); request.setSysVersion(\"2017-05-25\"); request.setSysAction(\"SendSms\"); request.putQueryParameter(\"PhoneNumbers\", mobile); request.putQueryParameter(\"SignName\", signName); request.putQueryParameter(\"TemplateCode\", templateCode); //这里使用通配符，code要与在阿里云注册的模版相同 request.putQueryParameter(\"TemplateParam\", \"{\\\"code\\\":\"+checkCode+\"}\"); try { CommonResponse response = client.getCommonResponse(request); System.out.println(response.getData()); } catch (ServerException e) { e.printStackTrace(); } catch (ClientException e) { e.printStackTrace(); } }} 创建rabbitmq监听器类@Component@RabbitListener(queues = \"sms\")public class SmsListener { @Autowired private SmsUtil smsUtil; @RabbitHandler public void executeSms(Map&lt;String,String&gt; map){ String mobile = map.get(\"mobile\"); String checkCode = map.get(\"checkCode\"); smsUtil.sendSms(mobile,checkCode); }} 自此短信功能部署成功 用户注册业务@RequestMapping(value =\"/register/{code}\",method = RequestMethod.POST)public Result register(@PathVariable String code,@RequestBody User user){ //先从缓存中拿到先前发送短信时存放的数据 String checkCodeRedis= (String) redisTemplate.opsForValue().get(\"checkCode\"+user.getMobile()); //比对数据 if(checkCodeRedis.isEmpty()){ return new Result(false,StatusCode.ERROR,\"未发送验证码\"); } if(!checkCodeRedis.equals(code)){ return new Result(false,StatusCode.ERROR,\"验证码错误\"); } //比对成功，注册用户 userService.add(user); return new Result(true,StatusCode.OK,\"注册成功\");} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"项目","slug":"项目","permalink":"https://xulilei.github.io/tags/%E9%A1%B9%E7%9B%AE/"},{"name":"rabbitmq","slug":"rabbitmq","permalink":"https://xulilei.github.io/tags/rabbitmq/"},{"name":"短信验证","slug":"短信验证","permalink":"https://xulilei.github.io/tags/%E7%9F%AD%E4%BF%A1%E9%AA%8C%E8%AF%81/"},{"name":"用户注册","slug":"用户注册","permalink":"https://xulilei.github.io/tags/%E7%94%A8%E6%88%B7%E6%B3%A8%E5%86%8C/"}]},{"title":"RabbitMQ入门","date":"2020-06-15T10:53:09.000Z","path":"2020/06/15/RabbitMQ/","text":"消息中间件RabbitMQRabbitMQ简介消息队列中间件是分布式系统中重要的组件，主要解决应用耦合，异步消息，流量削锋和消息通讯等问题，实现高性能，高可用，可伸缩和最终一致性的架构 架构图通过交换机再进入到队列中 主要概念RabbitMQ Server也叫broker server，它是一种传输服务。 他的角色就是维护一条 从Producer到Consumer的路线，保证数据能够按照指定的方式进行传输。 Producer消息生产者，如图A、B、C，数据的发送方。消息生产者连接RabbitMQ服 务器然后将消息投递到Exchange。 Consumer消息消费者，如图1、2、3，数据的接收方。消息消费者订阅队列， RabbitMQ将Queue中的消息发送到消息消费者。 Exchange生产者将消息发送到Exchange（交换器），由Exchange将消息路由到一个 或多个Queue中（或者丢弃）。Exchange并不存储消息。RabbitMQ中的Exchange有 direct、fanout、topic、headers四种类型，每种类型对应不同的路由规则。 Queue队列是RabbitMQ的内部对象，用于存储消息。消息消费者就是通过订阅 队列来获取消息的，RabbitMQ中的消息都只能存储在Queue中，生产者生产消息并最终 投递到Queue中，消费者可以从Queue中获取消息并消费。多个消费者可以订阅同一个 Queue，这时Queue中的消息会被平均分摊给多个消费者进行处理，而不是每个消费者 都收到所有的消息并处理。 RoutingKey生产者在将消息发送给Exchange的时候，一般会指定一个routing key， 来指定这个消息的路由规则，而这个routing key需要与Exchange Type及binding key联 合使用才能最终生效。在Exchange Type与binding key固定的情况下（在正常使用时一 般这些内容都是固定配置好的），我们的生产者就可以在发送消息给Exchange时，通过 指定routing key来决定消息流向哪里。 Docker安装需要注意的是要配置多个接口 docker run ‐di ‐‐name=tensquare_rabbitmq ‐p 5671:5617 ‐p 5672:5672 ‐p 4369:4369 ‐p 15671:15671 ‐p 15672:15672 ‐p 25672:25672 rabbitmq:management 主要知识点Exchange类型direct模式 1、将消息发给唯一一个节点时使用这种模式，这是最简单的一种形式 2、这种模式下不需要将Exchange进行任何绑定(binding)操作 3、消息传递时需要一个“RouteKey”，可以简单的理解为要发送到的队列名字 首先创建一个test队列 以direct模式发送 @RunWith(SpringRunner.class)@SpringBootTest(classes = RabApplication.class)public class ProductTest { @Autowired private RabbitTemplate rabbitTemplate; @Test public void sendMsg(){ //这里的test就是queue的名字 rabbitTemplate.convertAndSend(\"test\",\"测试直接模式\"); }} 创建消费者接受 @Component@RabbitListener(queues = \"test\")public class Customer { @RabbitHandler public void getMsg(String msg){ System.out.println(\"直接模式消费消息\"+msg); }} 运行结果 该模式下，默认采用了负载均衡，即消费者从队列获取消息是均衡的 分列模式 任何发送到Fanout Exchange的消息都会被转发到与该Exchange绑定(Binding)的所有 Queue上。 1、这种模式不需要RouteKey 2、这种模式需要提前将Exchange与Queue进行绑定，一个Exchange可以绑定多个 Queue，一个Queue可以同多个Exchange进行绑定。 3、如果接受到消息的Exchange没有与任何Queue绑定，则消息会被抛弃。+ 主题模式 任何发送到Topic Exchange的消息都会被转发到所有关心RouteKey中指定话题的 Queue上 1、这种模式较为复杂，简单来说，就是每个队列都有其关心的主题，所有的消息都带有一 个“标题”(RouteKey)，Exchange会将消息转发到所有关注主题能与RouteKey模糊匹配的 队列。 2、这种模式需要RouteKey，也许要提前绑定Exchange与Queue。 3、在进行绑定时，要提供一个该队列关心的主题，如“#.log.#”表示该队列关心所有涉及 log的消息(一个RouteKey为”MQ.log.error”的消息会被转发到该队列)。 4、“#”表示0个或若干个关键字，“”表示一个关键字。如“log.”能与“log.warn”匹配，无法 与“log.warn.timeout”匹配；但是“log.#”能与上述两者匹配。 5、同样，如果Exchange没有发现能够与RouteKey匹配的Queue，则会抛弃此消息 配合阿里云实现发送短信功能详见 https://xulilei.github.io/2020/06/15/%E5%8D%81%E6%AC%A1%E6%96%B9dayFive/ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"rabbitmq","slug":"rabbitmq","permalink":"https://xulilei.github.io/tags/rabbitmq/"},{"name":"短信验证","slug":"短信验证","permalink":"https://xulilei.github.io/tags/%E7%9F%AD%E4%BF%A1%E9%AA%8C%E8%AF%81/"}]},{"title":"DayFour-elasticsearch","date":"2020-06-14T10:34:44.000Z","path":"2020/06/14/十次方DayFour/","text":"搜索微服务搭建使用spring-data-elasticsearch操作导入依赖&lt;dependency&gt; &lt;groupId&gt;org.springframework.data&lt;/groupId&gt; &lt;artifactId&gt;spring-data-elasticsearch&lt;/artifactId&gt;&lt;/dependency&gt; Pojo实体类@Document(indexName = \"articleindex\",type = \"article\")public class Article implements Serializable { @Id private String id; //是否能被搜索到 //是否分词，整体匹配还是分词匹配 //是否在页面上显示，即数据库中在该实体类中的字段，就是要显示的,比如该例中的id title content state //analyzer,分词 //searchAnalyzer，搜索 @Field(index = true,analyzer=\"ik_max_word\",searchAnalyzer=\"ik_max_word\") private String title; @Field(index = true,analyzer=\"ik_max_word\",searchAnalyzer=\"ik_max_word\") private String content; private String state;} Dao层public interface ArticleDao extends ElasticsearchRepository&lt;Article,String&gt; { public Page&lt;Article&gt; findByTitleOrContentLike(String title, String content, Pageable pageable);} Service层@Servicepublic class ArticleService { @Autowired private ArticleDao articleDao; @Autowired private IdWorker idWorker; public void save(Article article){ articleDao.save(article); } //springdata系列分页的写法都是这个 public Page&lt;Article&gt; findByKey(String key, int page, int size) { Pageable pageable= PageRequest.of(page-1,size); return articleDao.findByTitleOrContentLike(key,key,pageable); }} controller层@RestController@RequestMapping(\"/article\")@CrossOriginpublic class ArticleController { @Autowired private ArticleService articleService; @RequestMapping(method = RequestMethod.POST) public Result save(@RequestBody Article article){ articleService.save(article); return new Result(true, StatusCode.OK,\"存储成功\"); } @RequestMapping(value = \"/{key}/{page}/{size}\",method = RequestMethod.GET) public Result findByKey(@PathVariable String key,@PathVariable int page,@PathVariable int size){ Page&lt;Article&gt;pageData=articleService.findByKey(key,page,size); return new Result(true,StatusCode.OK,\"搜索成功\",new PageResult&lt;Article&gt;(pageData.getTotalElements(),pageData.getContent())); }} docker部署elasticsearchhttps://xulilei.github.io/2020/06/12/elasticSearch%E5%85%A5%E9%97%A8/ 连接服务器，并测试存储到服务器的索引库application.yml配置server: port: 9007spring: application: name: tensquare-search data: elasticsearch: cluster-nodes: 192.168.152.128:9300 postMan测试成功 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"项目","slug":"项目","permalink":"https://xulilei.github.io/tags/%E9%A1%B9%E7%9B%AE/"},{"name":"elasticsearch","slug":"elasticsearch","permalink":"https://xulilei.github.io/tags/elasticsearch/"},{"name":"搜索功能","slug":"搜索功能","permalink":"https://xulilei.github.io/tags/%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD/"}]},{"title":"ElasticSearch从认识到发布","date":"2020-06-12T07:54:05.000Z","path":"2020/06/12/elasticSearch入门/","text":"分布式搜索引擎ElasticSearch概念与mysql数据库对比 Elasticsearch 关系型数据库Mysql 索引(index) 数据库(databases) 类型(type) 表(table) 文档(document) 行(row) restful风格操作ElasticSearch新建索引如果需要创建一个叫articleindex的索引 ,就以put方式提交 http://127.0.0.1:9200/articleindex/ 新建文档新建类型，在索引后追加类型： 以post方式提交 http://127.0.0.1:9200/articleindex/article 查询文档查询全部_search，以get方式请求 http://127.0.0.1:9200/articleindex/article/_search 按ID查询以GET方式请求 http://127.0.0.1:9200/articleindex/article/1 匹配查询根据title=aa进行查询，get方式提交下列地址： http://127.0.0.1:9200/articleindex/article/_search?q=title:aa 模糊查询以*用代表任意字符： http://192.168.184.134:9200/articleindex/article/_search?q=title:*s* 修改以put形式提交以下地址,如果ID存在则修改，否则添加 http://127.0.0.1:9200/articleindex/article/1 删除文档根据ID删除文档,删除ID为1的文档 DELETE方式提交 http://192.168.184.134:9200/articleindex/article/1 head插件操作ElasticSearch安装步骤步骤1： 下载head插件：https://github.com/mobz/elasticsearch-head 步骤2： 将grunt安装为全局命令npm install ‐g grunt‐cli 步骤3：解决跨域问题修改elasticsearch配置文件：elasticsearch.yml，增加以下两句命令： http.cors.enabled: true http.cors.allow‐origin: \"*\" 步骤4： 安装依赖并启动cnpm installgrunt server 图形化界面 Logstash概念Logstash是一款轻量级的日志搜集处理框架，可以方便的把分散的、多样化的日志搜集 起来，并进行自定义的处理，然后传输到指定的位置，比如某个服务器或者文件。 基本用法命令行参数: -e ：执行（很少用） -f：路径，后跟参数类型可以是一个字符串的配置或全路径文件名或全路径 如：/etc/logstash.d/，logstash会自动读取/etc/logstash.d/目录下所有*.conf 的文 本文件，然后在自己内存里拼接成一个完整的大配置文件再去执行 使用Logstash将数据库的内容同步到索引库模版，用到时直接填写input { jdbc { # mysql jdbc connection string to our backup databse jdbc_connection_string =&gt; \"jdbc:mysql://192.168.xx.xx:3306/aaaaa?characterEncoding=UTF8\" # the user we wish to excute our statement as jdbc_user =&gt; \"root\" jdbc_password =&gt; \"root\" # the path to our downloaded jdbc driver jdbc_driver_library =&gt; \"C:\\Users\\xu\\Desktop\\tensquare\\logstash-5.6.8\\mysqletc\\mysql-connector-java-5.1.46.jar\" # the name of the driver class for mysql jdbc_driver_class =&gt; \"com.mysql.jdbc.Driver\" jdbc_paging_enabled =&gt; \"true\" jdbc_page_size =&gt; \"50\" #以下对应着要执行的sql的绝对路径。 #statement_filepath =&gt; \"\" #这个是要直接执行的sql语句 statement =&gt; \"\"select id,title,content,state from tb_article\" #定时字段 各字段含义（由左至右）分、时、天、月、年，全部为*默认含义为每分钟都更新（测试结果，不同的话请留言指出） schedule =&gt; \"* * * * *\" }}output { elasticsearch { #ESIP地址与端口 hosts =&gt; \"127.0.0.1:9200\" #ES索引名称（自己定义的） index =&gt; \"articleindex\" #自增ID编号 document_id =&gt; \"%{id}\" document_type =&gt; \"article\" } stdout { #以JSON格式输出 codec =&gt; json_lines }} 再通过一下命令执行该文件logstash ‐f ../mysqletc/mysql.conf 结果返回{\"@version\":\"1\",\"id\":\"1\",\"state\":\"1\",\"@timestamp\":\"2020-06-15T03:35:00.106Z\",\"title\":\"xu测试\",\"content\":\"测试\"}{\"@version\":\"1\",\"id\":\"1\",\"state\":\"1\",\"@timestamp\":\"2020-06-15T03:34:01.671Z\",\"title\":\"xu测试\",\"content\":\"测试\"} 注意事项删除数据库中的文件并不会导致索引库中的数据删除，可以约定一个state，当需要删除的时候更改state的值，在索引库中，查询约定state的值即可实现 docker安装ES安装ES容器第一步，安装容器docker run ‐di ‐‐name=tensquare_elasticsearch ‐p 9200:9200 ‐p 9300:9300 elasticsearch:5.6.8 第二步，允许其他ip地址访问#进入elasticsearch容器的目录docker exec ‐it tensquare_elasticsearch /bin/bash#拷贝容器中的配置文件到宿主机docker cp tensquare_elasticsearch:/usr/share/elasticsearch/config/elasticsearch.yml /usr/share/elasticsearch.yml#停止删除原来的容器docker stop tensquare_elasticsearch docker rm tensquare_elasticsearch#重新安装容器，并挂载配置文件为/usr/share/elasticsearch.ymldocker run ‐di ‐‐name=tensquare_elasticsearch ‐p 9200:9200 ‐p 9300:9300 ‐v /usr/share/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch .yml elasticsearch:5.6.8#修改/usr/share/elasticsearch.yml 将#transport.host:0.0.0.0前的#去掉后保存文件退出。其作用是允许任何ip地址访问elasticsearch，并指定可以跨域transport.host:0.0.0.0http.cors.enabled: true http.cors.allow‐origin: \"*\"#重启容器docker restart tensquare_elasticsearch 第三部，如果遇到容器启动自动关闭，则需要优化配置(每个机器不同优化也不同)可以参考 https://blog.csdn.net/qq_34756221/article/details/105550037 https://www.cnblogs.com/jasonzeng/p/11584754.html 安装ik分词器先通过xftp将ik分词文件传送至服务器，再拷贝至es容器目录的plugins中 docker cp ik tensquare_elasticsearch:/usr/share/elasticsearch/plugins/ 安装headerdocker run ‐di ‐‐name=myhead ‐p 9100:9100 docker pull mobz/elasticsearch‐ head:5 成功页面展示head插件展示 ik分词器展示 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"ElasticSearch","slug":"ElasticSearch","permalink":"https://xulilei.github.io/tags/ElasticSearch/"},{"name":"Logstash","slug":"Logstash","permalink":"https://xulilei.github.io/tags/Logstash/"},{"name":"ik分词器","slug":"ik分词器","permalink":"https://xulilei.github.io/tags/ik%E5%88%86%E8%AF%8D%E5%99%A8/"},{"name":"docker","slug":"docker","permalink":"https://xulilei.github.io/tags/docker/"}]},{"title":"DayThree-mongoDB","date":"2020-06-09T08:25:22.000Z","path":"2020/06/09/十次方项目第三天/","text":"Day03什么是MongoDB​ MongoDB 是一个跨平台的，面向文档的数据库，是当前 NoSQL 数据库产品中最热 门 的一种。它介于关系数据库和非关系数据库之间，是非关系数据库当中功能最丰富，最像关系数据库的产品。它支持的数据结构非常松散，是类似 JSON 的 BSON 格式，因此可以存储比较复杂的数据类型。 MongoDB适用场景​ 适用于场景数据量大，数据价值相对低的情况 MongoDB体系结构（1）MongoDB 的文档（document），相当于关系数据库中的一行记录。 （2）多个文档组成一个集合（collection），相当于关系数据库的表。 （3）多个集合（collection），逻辑上组织在一起，就是数据库（database）。 服务器创建Docker MongoDB容器[root@pinyoyougou-docker ~]# docker run -di --name=tensquare_mongo -p 27017:27017 mongo MongoDB语法创建表use 数据库名称//如果不存在则自动创建 插入数据db.集合名称.insert(数据);//插入文档的语法格式比如db.spit.insert({content:\"听说十次方课程很给力呀\",userid:\"1011\",nickname:\"小雅\",visits:NumberInt(902)}) 查询数据db.集合名称.find()//查询所有db.spit.find().limit(3)//限定返回3条db.spit.find({userid:'1013'})//查询userid=1013的文档 修改与删除数据db.集合名称.update(条件,修改后的数据)//如果我们想修改_id为1的记录，浏览量为1000，输入以下语句：db.spit.update({_id:\"1\"},{visits:NumberInt(1000)})执行后，我们会发现，这条文档除了visits字段其它字段都不见了，为了解决这个问题，我们需要使用修改器$set来实现，命令如下：db.spit.update({_id:\"2\"},{$set:{visits:NumberInt(2000)}})//删除指定文档db.集合名称.remove(条件) 模糊查询MongoDB的模糊查询是通过正则表达式的方式实现的格式为：db.集合名称.find({content:/aaa/})例如，我要查询吐槽内容包含“流量”的所有文档，代码如下：db.spit.find({content:/流量/})如果要查询吐槽内容中以“加班”开头的，代码如下：db.spit.find({content:/^加班/}) 大于 小于 不等于db.集合名称.find({ \"field\" : { $gt: value }}) // 大于: field &gt; valuedb.集合名称.find({ \"field\" : { $lt: value }}) // 小于: field &lt; valuedb.集合名称.find({ \"field\" : { $gte: value }}) // 大于等于: field &gt;= valuedb.集合名称.find({ \"field\" : { $lte: value }}) // 小于等于: field &lt;= valuedb.集合名称.find({ \"field\" : { $ne: value }}) // 不等于: field != value 包含与不包含包含使用$in操作符。示例：查询吐槽集合中userid字段包含1013和1014的文档db.spit.find({userid:{$in:[\"1013\",\"1014\"]}})不包含使用$nin操作符。示例：查询吐槽集合中userid字段不包含1013和1014的文档db.spit.find({userid:{$nin:[\"1013\",\"1014\"]}}) 条件连接我们如果需要查询同时满足两个以上条件，需要使用$and操作符将条件进行关联。（相当于SQL的and）格式为：$and:[{ },{ },{ }]示例：查询吐槽集合中visits大于等于1000 并且小于2000的文档db.spit.find({$and:[ {visits:{$gte:1000}} ,{visits:{$lt:2000}}]})如果两个以上条件之间是或者的关系，我们使用 操作符进行关联，与前面and的使用方式相同格式为：$or:[{ },{ },{ }]示例：查询吐槽集合中userid为1013，或者浏览量小于2000的文档记录db.spit.find({$or:[ {userid:\"1013\"} ,{visits:{$lt:2000} }]}) 列值增长如果我们想实现对某列值在原有值的基础上进行增加或减少，可以使用$inc运算符来实现db.spit.update({_id:\"2\"},{$inc:{visits:NumberInt(1)}}) JAVA操作MongoDBpublic class MongoDemo { public static void main(String[] args) { MongoClient client=new MongoClient(\"192.168.184.134\");//创建连接 MongoDatabase spitdb = client.getDatabase(\"spitdb\");//打开数据库 MongoCollection&lt;Document&gt; spit = spitdb.getCollection(\"spit\");//获取集合 //条件查询 //BasicDBObject bson=new BasicDBObject(\"userid\",\"1013\");// 构建查询条件 //BasicDBObject bson=new BasicDBObject(\"visits\",newBasicDBObject(\"$gt\",1000) ); //FindIterable&lt;Document&gt; documents = spit.find(bson);//查询记录获取结果集合 FindIterable&lt;Document&gt; documents = spit.find();//查询记录获取文档集合 for(Document document:documents){ // System.out.println(\"内容：\"+ document.getString(\"content\")); System.out.println(\"用户ID:\"+document.getString(\"userid\")); System.out.println(\"浏览量：\"+document.getInteger(\"visits\")); } //插入数据 Map&lt;String,Object&gt; map=new HashMap(); map.put(\"content\",\"我要吐槽\"); map.put(\"userid\",\"9999\"); map.put(\"visits\",123); map.put(\"publishtime\",new Date()); Document document=new Document(map); spit.insertOne(document); client.close();//关闭连接 }} SpringDataMongoDB增删改查与SpringDataJPA几乎一样，详细用法参考https://xulilei.github.io/2020/06/08/%E5%8D%81%E6%AC%A1%E6%96%B9%E9%A1%B9%E7%9B%AEDay2/ 通过MongoTemplate原生方式实现数据自增public void thumbUp(String id){ //方式一,与数据库多次交互性能较低 Spit spit=spitDao.findById(id).get(); spit.setThumbup((spit.getThumbup()==null?0:spit.getThumbup())+1); spitDao.save(spit); //相当于使用原生mongo命令实现自增：db.spit.update({\"_id\":\"1\"},{$inc:{thumbup:NumberInt(1)}}) Query query=new Query(); query.addCriteria(Criteria.where(\"_id\").is(\"id\")); Update update=new Update(); update.inc(\"thumbup\",1); mongoTemplate.updateFirst(query,update,\"spit\"); } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"MongoDB","slug":"MongoDB","permalink":"https://xulilei.github.io/tags/MongoDB/"},{"name":"项目","slug":"项目","permalink":"https://xulilei.github.io/tags/%E9%A1%B9%E7%9B%AE/"}]},{"title":"DayTwo-SpringDataJpa","date":"2020-06-08T07:23:13.000Z","path":"2020/06/08/十次方项目Day2/","text":"SpringDataJpa通过new Specification实现条件查询//service层public List&lt;Label&gt; findSearch(Label label) { return labelDao.findAll(new Specification&lt;Label&gt;() { /** * 采用内部类，方式实现 * @param root 根对象，也就是说要把条件封装到哪个对象中去 * @param query 查询关键字，比如groupBy，orderBy等 * @param cb 用来封装条件对象的 * @return 如果返回null，则代表不需要任何条件 */ @Override public Predicate toPredicate(Root&lt;Label&gt; root, CriteriaQuery&lt;?&gt; query, CriteriaBuilder cb) { List&lt;Predicate&gt; list=new ArrayList&lt;&gt;(); //相当于 where labelname like \"%小明%\" if(label.getLabelname()!=null&amp;&amp;!\"\".equals(label.getLabelname())){ Predicate predicate = cb.like(root.get(\"labelname\").as(String.class), \"%\" + label.getLabelname() + \"%\"); list.add(predicate); } if(label.getState()!=null&amp;&amp;!\"\".equals(label.getState())){ Predicate predicate = cb.equal(root.get(\"state\").as(String.class), label.getState()); list.add(predicate); } Predicate[] parr=new Predicate[list.size()]; list.toArray(parr); //相当于查询where condition A and condition B return cb.and(parr); } }); }//controller层 @RequestMapping(value = \"/search\",method = RequestMethod.POST) public Result findSearch(@RequestBody Label label){ List&lt;Label&gt;list=labelService.findSearch(label); return new Result(true,StatusCode.OK,\"查询成功\",list); } 分页与条件查询//service层public Page&lt;Label&gt; findSearchAndPageQuery(Label label, int page, int size) { //封装一个分页对象 Pageable pageable=PageRequest.of(page-1,size); return labelDao.findAll(new Specification&lt;Label&gt;() { /** * * @param root 根对象，也就是说要把条件封装到哪个对象中去 * @param query 查询关键字，比如groupBy，orderBy等 * @param cb 用来封装条件对象的 * @return 如果返回null，则代表不需要任何条件 */ @Override public Predicate toPredicate(Root&lt;Label&gt; root, CriteriaQuery&lt;?&gt; query, CriteriaBuilder cb) { List&lt;Predicate&gt; list=new ArrayList&lt;&gt;(); //相当于 where labelname like \"%小明%\" if(label.getLabelname()!=null&amp;&amp;!\"\".equals(label.getLabelname())){ Predicate predicate = cb.like(root.get(\"labelname\").as(String.class), \"%\" + label.getLabelname() + \"%\"); list.add(predicate); } if(label.getState()!=null&amp;&amp;!\"\".equals(label.getState())){ Predicate predicate = cb.equal(root.get(\"state\").as(String.class), label.getState()); list.add(predicate); } Predicate[] parr=new Predicate[list.size()]; list.toArray(parr); return cb.and(parr); } },pageable); }//controller层 @RequestMapping(value = \"/search/{page}/{size}\",method = RequestMethod.POST) public Result findSearchAndPageQuery(@RequestBody Label label,@PathVariable int page,@PathVariable int size){ Page&lt;Label&gt; pageData=labelService.findSearchAndPageQuery(label,page,size); return new Result(true,StatusCode.OK,\"查询成功\",new PageResult&lt;Label&gt;(pageData.getTotalElements(),pageData.getContent())); }//用来封装pageResult的类public class PageResult&lt;T&gt; { private long total; private List&lt;T&gt; rows; public long getTotal() { return total; } public void setTotal(long total) { this.total = total; } public List&lt;T&gt; getRows() { return rows; } public void setRows(List&lt;T&gt; rows) { this.rows = rows; } public PageResult() { } public PageResult(long total, List&lt;T&gt; rows) { this.total = total; this.rows = rows; }} 在Dao层通过方法命名方式生成sql语句public interface EnterpriseDao extends JpaRepository&lt;Enterprise,String&gt;,JpaSpecificationExecutor&lt;Enterprise&gt;{ //相当于where ishot=? public List&lt;Enterprise&gt; findByIshot(String ishot); }public interface RecruitDao extends JpaRepository&lt;Recruit,String&gt;,JpaSpecificationExecutor&lt;Recruit&gt;{ //相当于where state=？ order by Createtime，并且取前6个 public List&lt;Recruit&gt; findTop6ByStateOrderByCreatetimeDesc(String state); //相当于where state！=？order by createtime。并且取前6个 public List&lt;Recruit&gt; findTop6ByStateNotOrderByCreatetimeDesc(String state);} 具体命名规则参考https://www.cnblogs.com/oxygenG/p/10057525.html。 处理多对多关系在数据库端处理多对多的关系，必须需要借助中间表。而在java端，只需要在一个对象中放入另一个对象的list集合即可。如果不创建实体类，则需要通过原生的sql语句执行 //通过这个查询语句，才能够实现pageable的分页功能@Query(value=\"SELECT * FROM tb_problem,tb_pl WHERE id=problemid AND labelid=:labelid ORDER BY ?#{#pageable}\", countQuery = \"select count(*) from tb_problem ,tb_pl where id=problemid AND labelid=:labelid\",nativeQuery = true)public Page&lt;Problem&gt; newList(@Param(\"labelid\") String labelid, Pageable pageable); 参考：https://blog.csdn.net/tt____tt/article/details/81027269?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase 事务支持1、Dao层，在可能产生线程问题的语句上添加@Modifying @Modifying@Query(value = \"update tb_article set state='1' where id=?1\",nativeQuery = true)public void updateState(String id); 2、Service层开启注解支持@Transactional @Service@Transactionalpublic class ArticleService {} 缓存的应用Redis–有过期时间限制1、添加SpringDataRedis依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt; 2、服务端Docker开启Redis镜像，生成redis容器 [root@pinyoyougou-docker ~]# docker run -di --name=tensquare_redis -p 6379:6379 redis 3、application.ymal配置host redis: host: 192.168.*.* 4、业务逻辑调用 public class ArticleService { @Autowired private ArticleDao articleDao; @Autowired private RedisTemplate redisTemplate; public Article findById(String id) { //先从缓存中查询当前对象 Article article= (Article) redisTemplate.opsForValue().get(\"article_\"+id); //如果没有渠道 if(article==null){ article = articleDao.findById(id).get(); //存入缓存 redisTemplate.opsForValue().set(\"article_\"+id,article); } return article; } public void deleteById(String id) { //删除缓存 redisTemplate.delete(\"article_\"+id); articleDao.deleteById(id); }} redisTemplate用法 stringRedisTemplate.opsForValue().set(\"test\", \"100\",60*10,TimeUnit.SECONDS);//向redis里存入数据和设置缓存时间stringRedisTemplate.opsForValue().get(\"test\")//根据key获取缓存中的valstringRedisTemplate.delete(\"test\");//根据key删除缓存stringRedisTemplate.hasKey(\"546545\");//检查key是否存在，返回boolean值 SpringCache–无过期时间限制1、SpringApplication开启SpringCache @SpringBootApplication@EnableCachingpublic class GatApplication {} 2、业务层调用，@Cacheable为存，@CacheEvict为删 @Cacheable(value = \"gathering\",key = \"#id\")public Gathering findById(String id) { return gatheringDao.findById(id).get();}@CacheEvict(value = \"gathering\",key = \"#gathering.id\")public void update(Gathering gathering) { gatheringDao.save(gathering);} 第二天总结掌握了条件与分页查询，Dao层方法命名规则，事务支持，缓存 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"SpringDataJPA","slug":"SpringDataJPA","permalink":"https://xulilei.github.io/tags/SpringDataJPA/"},{"name":"项目","slug":"项目","permalink":"https://xulilei.github.io/tags/%E9%A1%B9%E7%9B%AE/"}]},{"title":"Docker入门篇","date":"2020-06-05T07:57:43.000Z","path":"2020/06/05/Docker入门/","text":"Docker入门Dokcer为什么会出现？一款产品从开发到上线，一般都需要两套环境。而环境的配置十分麻烦，Docker给出了解决方案 步骤：java–jar（环境）–打包项目带上环境（即Docker镜像）–Docker仓库–下载我们发布的镜像–直接运行即可。 虚拟机技术特点1、资源占用十分多 2、冗余步骤多 3、启动很慢 如下图所示，多个APP共享一个lib环境，可能会造成端口冲突等环境冲突的问题 容器化技术如下图所示，每个模块拥有独属于自己运行的环境，各个模块之间相互隔离 Docker的相关概念Docker架构图 相关术语镜像：images​ 通过这个模版来创建容器服务，比如Mysql镜像–通过Docker运行后，便成为了一个提供服务的容器,一个镜像可以创建多个容器 容器：container​ 提供服务，可以启动、停止、删除等，可类比为一个简单的linux系统 仓库：repository​ 存放镜像的地方，分为共有仓库和私有仓库 Docker安装Nginx1、search：可在命令行和dockerHub上搜索对应版本 2、pull：拉去下载该镜像 3、docker images：查看本机上的镜像 3、运行该镜像 docker run -d --name nginx01 -p 3344:80 nginx #新建一个名字为nginx01的nginx镜像，公网访问地址为3344，内部地址为80，并运行该镜像#-d 后台运行、--name 命名、-p 端口号 4、内部测试 ​ curl localhost:3344 容器数据卷结构示意图如下 防止容器删除后数据丢失，通过实现容器间数据共享，并将产生的数据备份到linux的文件系统上 总结一句话就是：容器的持久化和容器间的同步操作。 使用数据卷​ -v 主机目录:容器内目录 —&gt;映射容器内的目录到主机上 ​ 参考https://xulilei.github.io/2020/06/12/elasticSearch%E5%85%A5%E9%97%A8/ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Docker","slug":"Docker","permalink":"https://xulilei.github.io/tags/Docker/"}]},{"title":"DayOne-架构","date":"2020-06-02T11:02:13.000Z","path":"2020/06/02/十次方社交平台项目/","text":"DayOne系统架构SpringBoot+SpringCloud+SpringMVC+SpringData，也称这种架构模式为spring全家桶 系统模块不再采取按dao，service层划分模块，而是基于每个微服务，再将每个模块封装成一个镜像，再通过springCloud连接起来。因此在每个微服务中便不需要再写接口，因为每个微服务就是最小模块 开发API通过swagger封装，Nginx代理，形成的API开发文档 Restful开发风格我们在项目中经常用到增删改查：get/post/put/delete四种方法，安全：操作不会出现脏读、幻读等操作。幂等：查询成功后不会对数据库造成影响 Get查询是安全且幂等的 Post是不安全且不幂等的 Put改是不安全且幂等的 Delete删是不安全且幂等的 主要工作Mysql环境搭建创建虚拟机，安装docker，下载Mysql镜像，在服务器(192.168.152.128)运行并从本地连接完成建表 创建父工程主要是一些子模块都需要的依赖配置在这里 &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.1.RELEASE&lt;/version&gt; &lt;relativePath/&gt;&lt;/parent&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; &lt;!--SpringCloud全家桶父工程推荐默认配置--&gt;&lt;repositories&gt; &lt;repository&gt; &lt;id&gt;spring-snapshots&lt;/id&gt; &lt;name&gt;Spring Snapshots&lt;/name&gt; &lt;url&gt;https://repo.spring.io/snapshot&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;repository&gt; &lt;id&gt;spring-milestones&lt;/id&gt; &lt;name&gt;Spring Milestones&lt;/name&gt; &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;pluginRepositories&gt; &lt;pluginRepository&gt; &lt;id&gt;spring-snapshots&lt;/id&gt; &lt;name&gt;Spring Snapshots&lt;/name&gt; &lt;url&gt;https://repo.spring.io/snapshot&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/pluginRepository&gt; &lt;pluginRepository&gt; &lt;id&gt;spring-milestones&lt;/id&gt; &lt;name&gt;Spring Milestones&lt;/name&gt; &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/pluginRepository&gt; &lt;/pluginRepositories&gt; 模块搭建公共模块搭建，根据swagger约定，封装数据传输到前端。其中utils包下的idWoker根据雪花算法，可以生成不同的ID，吞吐量为20W+。 基础模块搭建，数据的CRUD操作 import com.tensquare.base.pojo.Label;import org.springframework.data.jpa.repository.JpaRepository;import org.springframework.data.jpa.repository.JpaSpecificationExecutor;//SpringDataJpa封装了CRUD操作，以及一些复杂的条件查询public interface LabelDao extends JpaRepository&lt;Label,String&gt;, JpaSpecificationExecutor&lt;Label&gt; {} Day01总结在服务器端，通过Docker创建了Mysql镜像 通过本地IDEA的DataSource连接上去。 通过PostMan检查当天的CRUD操作 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"项目","slug":"项目","permalink":"https://xulilei.github.io/tags/%E9%A1%B9%E7%9B%AE/"}]}]