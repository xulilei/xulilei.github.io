[{"title":"DayFour","date":"2020-06-14T10:34:44.000Z","path":"2020/06/14/十次方DayFour/","text":"搜索微服务搭建使用spring-data-elasticsearch操作导入依赖&lt;dependency&gt; &lt;groupId&gt;org.springframework.data&lt;/groupId&gt; &lt;artifactId&gt;spring-data-elasticsearch&lt;/artifactId&gt;&lt;/dependency&gt; Pojo实体类@Document(indexName = \"articleindex\",type = \"article\")public class Article implements Serializable { @Id private String id; //是否能被搜索到 //是否分词，整体匹配还是分词匹配 //是否在页面上显示，即数据库中在该实体类中的字段，就是要显示的,比如该例中的id title content state //analyzer,分词 //searchAnalyzer，搜索 @Field(index = true,analyzer=\"ik_max_word\",searchAnalyzer=\"ik_max_word\") private String title; @Field(index = true,analyzer=\"ik_max_word\",searchAnalyzer=\"ik_max_word\") private String content; private String state;} Dao层public interface ArticleDao extends ElasticsearchRepository&lt;Article,String&gt; { public Page&lt;Article&gt; findByTitleOrContentLike(String title, String content, Pageable pageable);} Service层@Servicepublic class ArticleService { @Autowired private ArticleDao articleDao; @Autowired private IdWorker idWorker; public void save(Article article){ articleDao.save(article); } //springdata系列分页的写法都是这个 public Page&lt;Article&gt; findByKey(String key, int page, int size) { Pageable pageable= PageRequest.of(page-1,size); return articleDao.findByTitleOrContentLike(key,key,pageable); }} controller层@RestController@RequestMapping(\"/article\")@CrossOriginpublic class ArticleController { @Autowired private ArticleService articleService; @RequestMapping(method = RequestMethod.POST) public Result save(@RequestBody Article article){ articleService.save(article); return new Result(true, StatusCode.OK,\"存储成功\"); } @RequestMapping(value = \"/{key}/{page}/{size}\",method = RequestMethod.GET) public Result findByKey(@PathVariable String key,@PathVariable int page,@PathVariable int size){ Page&lt;Article&gt;pageData=articleService.findByKey(key,page,size); return new Result(true,StatusCode.OK,\"搜索成功\",new PageResult&lt;Article&gt;(pageData.getTotalElements(),pageData.getContent())); }} docker部署elasticsearchhttps://xulilei.github.io/2020/06/12/elasticSearch%E5%85%A5%E9%97%A8/ 连接服务器，并测试存储到服务器的索引库application.yml配置server: port: 9007spring: application: name: tensquare-search data: elasticsearch: cluster-nodes: 192.168.152.128:9300 postMan测试成功 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"项目","slug":"项目","permalink":"https://xulilei.github.io/tags/%E9%A1%B9%E7%9B%AE/"},{"name":"elasticsearch","slug":"elasticsearch","permalink":"https://xulilei.github.io/tags/elasticsearch/"},{"name":"搜索功能","slug":"搜索功能","permalink":"https://xulilei.github.io/tags/%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD/"}]},{"title":"ElasticSearch从认识到发布","date":"2020-06-12T07:54:05.000Z","path":"2020/06/12/elasticSearch入门/","text":"分布式搜索引擎ElasticSearch概念与mysql数据库对比 Elasticsearch 关系型数据库Mysql 索引(index) 数据库(databases) 类型(type) 表(table) 文档(document) 行(row) restful风格操作ElasticSearch新建索引如果需要创建一个叫articleindex的索引 ,就以put方式提交 http://127.0.0.1:9200/articleindex/ 新建文档新建类型，在索引后追加类型： 以post方式提交 http://127.0.0.1:9200/articleindex/article 查询文档查询全部_search，以get方式请求 http://127.0.0.1:9200/articleindex/article/_search 按ID查询以GET方式请求 http://127.0.0.1:9200/articleindex/article/1 匹配查询根据title=aa进行查询，get方式提交下列地址： http://127.0.0.1:9200/articleindex/article/_search?q=title:aa 模糊查询以*用代表任意字符： http://192.168.184.134:9200/articleindex/article/_search?q=title:*s* 修改以put形式提交以下地址,如果ID存在则修改，否则添加 http://127.0.0.1:9200/articleindex/article/1 删除文档根据ID删除文档,删除ID为1的文档 DELETE方式提交 http://192.168.184.134:9200/articleindex/article/1 head插件操作ElasticSearch安装步骤步骤1： 下载head插件：https://github.com/mobz/elasticsearch-head 步骤2： 将grunt安装为全局命令npm install ‐g grunt‐cli 步骤3：解决跨域问题修改elasticsearch配置文件：elasticsearch.yml，增加以下两句命令： http.cors.enabled: true http.cors.allow‐origin: \"*\" 步骤4： 安装依赖并启动cnpm installgrunt server 图形化界面 Logstash概念Logstash是一款轻量级的日志搜集处理框架，可以方便的把分散的、多样化的日志搜集 起来，并进行自定义的处理，然后传输到指定的位置，比如某个服务器或者文件。 基本用法命令行参数: -e ：执行（很少用） -f：路径，后跟参数类型可以是一个字符串的配置或全路径文件名或全路径 如：/etc/logstash.d/，logstash会自动读取/etc/logstash.d/目录下所有*.conf 的文 本文件，然后在自己内存里拼接成一个完整的大配置文件再去执行 使用Logstash将数据库的内容同步到索引库模版，用到时直接填写input { jdbc { # mysql jdbc connection string to our backup databse jdbc_connection_string =&gt; \"jdbc:mysql://192.168.xx.xx:3306/aaaaa?characterEncoding=UTF8\" # the user we wish to excute our statement as jdbc_user =&gt; \"root\" jdbc_password =&gt; \"root\" # the path to our downloaded jdbc driver jdbc_driver_library =&gt; \"C:\\Users\\xu\\Desktop\\tensquare\\logstash-5.6.8\\mysqletc\\mysql-connector-java-5.1.46.jar\" # the name of the driver class for mysql jdbc_driver_class =&gt; \"com.mysql.jdbc.Driver\" jdbc_paging_enabled =&gt; \"true\" jdbc_page_size =&gt; \"50\" #以下对应着要执行的sql的绝对路径。 #statement_filepath =&gt; \"\" #这个是要直接执行的sql语句 statement =&gt; \"\"select id,title,content,state from tb_article\" #定时字段 各字段含义（由左至右）分、时、天、月、年，全部为*默认含义为每分钟都更新（测试结果，不同的话请留言指出） schedule =&gt; \"* * * * *\" }}output { elasticsearch { #ESIP地址与端口 hosts =&gt; \"127.0.0.1:9200\" #ES索引名称（自己定义的） index =&gt; \"articleindex\" #自增ID编号 document_id =&gt; \"%{id}\" document_type =&gt; \"article\" } stdout { #以JSON格式输出 codec =&gt; json_lines }} 再通过一下命令执行该文件logstash ‐f ../mysqletc/mysql.conf 结果返回{\"@version\":\"1\",\"id\":\"1\",\"state\":\"1\",\"@timestamp\":\"2020-06-15T03:35:00.106Z\",\"title\":\"xu测试\",\"content\":\"测试\"}{\"@version\":\"1\",\"id\":\"1\",\"state\":\"1\",\"@timestamp\":\"2020-06-15T03:34:01.671Z\",\"title\":\"xu测试\",\"content\":\"测试\"} 注意事项删除数据库中的文件并不会导致索引库中的数据删除，可以约定一个state，当需要删除的时候更改state的值，在索引库中，查询约定state的值即可实现 docker安装ES安装ES容器第一步，安装容器docker run ‐di ‐‐name=tensquare_elasticsearch ‐p 9200:9200 ‐p 9300:9300 elasticsearch:5.6.8 第二步，允许其他ip地址访问#进入elasticsearch容器的目录docker exec ‐it tensquare_elasticsearch /bin/bash#拷贝容器中的配置文件到宿主机docker cp tensquare_elasticsearch:/usr/share/elasticsearch/config/elasticsearch.yml /usr/share/elasticsearch.yml#停止删除原来的容器docker stop tensquare_elasticsearch docker rm tensquare_elasticsearch#重新安装容器，并挂载配置文件为/usr/share/elasticsearch.ymldocker run ‐di ‐‐name=tensquare_elasticsearch ‐p 9200:9200 ‐p 9300:9300 ‐v /usr/share/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch .yml elasticsearch:5.6.8#修改/usr/share/elasticsearch.yml 将#transport.host:0.0.0.0前的#去掉后保存文件退出。其作用是允许任何ip地址访问elasticsearch，并指定可以跨域transport.host:0.0.0.0http.cors.enabled: true http.cors.allow‐origin: \"*\"#重启容器docker restart tensquare_elasticsearch 第三部，如果遇到容器启动自动关闭，则需要优化配置(每个机器不同优化也不同)可以参考 https://blog.csdn.net/qq_34756221/article/details/105550037 https://www.cnblogs.com/jasonzeng/p/11584754.html 安装ik分词器先通过xftp将ik分词文件传送至服务器，再拷贝至es容器目录的plugins中 docker cp ik tensquare_elasticsearch:/usr/share/elasticsearch/plugins/ 安装headerdocker run ‐di ‐‐name=myhead ‐p 9100:9100 docker pull mobz/elasticsearch‐ head:5 成功页面展示head插件展示 ik分词器展示 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"ElasticSearch","slug":"ElasticSearch","permalink":"https://xulilei.github.io/tags/ElasticSearch/"},{"name":"Logstash","slug":"Logstash","permalink":"https://xulilei.github.io/tags/Logstash/"},{"name":"ik分词器","slug":"ik分词器","permalink":"https://xulilei.github.io/tags/ik%E5%88%86%E8%AF%8D%E5%99%A8/"},{"name":"docker","slug":"docker","permalink":"https://xulilei.github.io/tags/docker/"}]},{"title":"DayThree","date":"2020-06-09T08:25:22.000Z","path":"2020/06/09/十次方项目第三天/","text":"Day03什么是MongoDB​ MongoDB 是一个跨平台的，面向文档的数据库，是当前 NoSQL 数据库产品中最热 门 的一种。它介于关系数据库和非关系数据库之间，是非关系数据库当中功能最丰富，最像关系数据库的产品。它支持的数据结构非常松散，是类似 JSON 的 BSON 格式，因此可以存储比较复杂的数据类型。 MongoDB适用场景​ 适用于场景数据量大，数据价值相对低的情况 MongoDB体系结构（1）MongoDB 的文档（document），相当于关系数据库中的一行记录。 （2）多个文档组成一个集合（collection），相当于关系数据库的表。 （3）多个集合（collection），逻辑上组织在一起，就是数据库（database）。 服务器创建Docker MongoDB容器[root@pinyoyougou-docker ~]# docker run -di --name=tensquare_mongo -p 27017:27017 mongo MongoDB语法创建表use 数据库名称//如果不存在则自动创建 插入数据db.集合名称.insert(数据);//插入文档的语法格式比如db.spit.insert({content:\"听说十次方课程很给力呀\",userid:\"1011\",nickname:\"小雅\",visits:NumberInt(902)}) 查询数据db.集合名称.find()//查询所有db.spit.find().limit(3)//限定返回3条db.spit.find({userid:'1013'})//查询userid=1013的文档 修改与删除数据db.集合名称.update(条件,修改后的数据)//如果我们想修改_id为1的记录，浏览量为1000，输入以下语句：db.spit.update({_id:\"1\"},{visits:NumberInt(1000)})执行后，我们会发现，这条文档除了visits字段其它字段都不见了，为了解决这个问题，我们需要使用修改器$set来实现，命令如下：db.spit.update({_id:\"2\"},{$set:{visits:NumberInt(2000)}})//删除指定文档db.集合名称.remove(条件) 模糊查询MongoDB的模糊查询是通过正则表达式的方式实现的格式为：db.集合名称.find({content:/aaa/})例如，我要查询吐槽内容包含“流量”的所有文档，代码如下：db.spit.find({content:/流量/})如果要查询吐槽内容中以“加班”开头的，代码如下：db.spit.find({content:/^加班/}) 大于 小于 不等于db.集合名称.find({ \"field\" : { $gt: value }}) // 大于: field &gt; valuedb.集合名称.find({ \"field\" : { $lt: value }}) // 小于: field &lt; valuedb.集合名称.find({ \"field\" : { $gte: value }}) // 大于等于: field &gt;= valuedb.集合名称.find({ \"field\" : { $lte: value }}) // 小于等于: field &lt;= valuedb.集合名称.find({ \"field\" : { $ne: value }}) // 不等于: field != value 包含与不包含包含使用$in操作符。示例：查询吐槽集合中userid字段包含1013和1014的文档db.spit.find({userid:{$in:[\"1013\",\"1014\"]}})不包含使用$nin操作符。示例：查询吐槽集合中userid字段不包含1013和1014的文档db.spit.find({userid:{$nin:[\"1013\",\"1014\"]}}) 条件连接我们如果需要查询同时满足两个以上条件，需要使用$and操作符将条件进行关联。（相当于SQL的and）格式为：$and:[{ },{ },{ }]示例：查询吐槽集合中visits大于等于1000 并且小于2000的文档db.spit.find({$and:[ {visits:{$gte:1000}} ,{visits:{$lt:2000}}]})如果两个以上条件之间是或者的关系，我们使用 操作符进行关联，与前面and的使用方式相同格式为：$or:[{ },{ },{ }]示例：查询吐槽集合中userid为1013，或者浏览量小于2000的文档记录db.spit.find({$or:[ {userid:\"1013\"} ,{visits:{$lt:2000} }]}) 列值增长如果我们想实现对某列值在原有值的基础上进行增加或减少，可以使用$inc运算符来实现db.spit.update({_id:\"2\"},{$inc:{visits:NumberInt(1)}}) JAVA操作MongoDBpublic class MongoDemo { public static void main(String[] args) { MongoClient client=new MongoClient(\"192.168.184.134\");//创建连接 MongoDatabase spitdb = client.getDatabase(\"spitdb\");//打开数据库 MongoCollection&lt;Document&gt; spit = spitdb.getCollection(\"spit\");//获取集合 //条件查询 //BasicDBObject bson=new BasicDBObject(\"userid\",\"1013\");// 构建查询条件 //BasicDBObject bson=new BasicDBObject(\"visits\",newBasicDBObject(\"$gt\",1000) ); //FindIterable&lt;Document&gt; documents = spit.find(bson);//查询记录获取结果集合 FindIterable&lt;Document&gt; documents = spit.find();//查询记录获取文档集合 for(Document document:documents){ // System.out.println(\"内容：\"+ document.getString(\"content\")); System.out.println(\"用户ID:\"+document.getString(\"userid\")); System.out.println(\"浏览量：\"+document.getInteger(\"visits\")); } //插入数据 Map&lt;String,Object&gt; map=new HashMap(); map.put(\"content\",\"我要吐槽\"); map.put(\"userid\",\"9999\"); map.put(\"visits\",123); map.put(\"publishtime\",new Date()); Document document=new Document(map); spit.insertOne(document); client.close();//关闭连接 }} SpringDataMongoDB增删改查与SpringDataJPA几乎一样，详细用法参考https://xulilei.github.io/2020/06/08/%E5%8D%81%E6%AC%A1%E6%96%B9%E9%A1%B9%E7%9B%AEDay2/ 通过MongoTemplate原生方式实现数据自增public void thumbUp(String id){ //方式一,与数据库多次交互性能较低 Spit spit=spitDao.findById(id).get(); spit.setThumbup((spit.getThumbup()==null?0:spit.getThumbup())+1); spitDao.save(spit); //相当于使用原生mongo命令实现自增：db.spit.update({\"_id\":\"1\"},{$inc:{thumbup:NumberInt(1)}}) Query query=new Query(); query.addCriteria(Criteria.where(\"_id\").is(\"id\")); Update update=new Update(); update.inc(\"thumbup\",1); mongoTemplate.updateFirst(query,update,\"spit\"); } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"MongoDB","slug":"MongoDB","permalink":"https://xulilei.github.io/tags/MongoDB/"},{"name":"项目","slug":"项目","permalink":"https://xulilei.github.io/tags/%E9%A1%B9%E7%9B%AE/"}]},{"title":"DayTwo","date":"2020-06-08T07:23:13.000Z","path":"2020/06/08/十次方项目Day2/","text":"SpringDataJpa通过new Specification实现条件查询//service层public List&lt;Label&gt; findSearch(Label label) { return labelDao.findAll(new Specification&lt;Label&gt;() { /** * 采用内部类，方式实现 * @param root 根对象，也就是说要把条件封装到哪个对象中去 * @param query 查询关键字，比如groupBy，orderBy等 * @param cb 用来封装条件对象的 * @return 如果返回null，则代表不需要任何条件 */ @Override public Predicate toPredicate(Root&lt;Label&gt; root, CriteriaQuery&lt;?&gt; query, CriteriaBuilder cb) { List&lt;Predicate&gt; list=new ArrayList&lt;&gt;(); //相当于 where labelname like \"%小明%\" if(label.getLabelname()!=null&amp;&amp;!\"\".equals(label.getLabelname())){ Predicate predicate = cb.like(root.get(\"labelname\").as(String.class), \"%\" + label.getLabelname() + \"%\"); list.add(predicate); } if(label.getState()!=null&amp;&amp;!\"\".equals(label.getState())){ Predicate predicate = cb.equal(root.get(\"state\").as(String.class), label.getState()); list.add(predicate); } Predicate[] parr=new Predicate[list.size()]; list.toArray(parr); //相当于查询where condition A and condition B return cb.and(parr); } }); }//controller层 @RequestMapping(value = \"/search\",method = RequestMethod.POST) public Result findSearch(@RequestBody Label label){ List&lt;Label&gt;list=labelService.findSearch(label); return new Result(true,StatusCode.OK,\"查询成功\",list); } 分页与条件查询//service层public Page&lt;Label&gt; findSearchAndPageQuery(Label label, int page, int size) { //封装一个分页对象 Pageable pageable=PageRequest.of(page-1,size); return labelDao.findAll(new Specification&lt;Label&gt;() { /** * * @param root 根对象，也就是说要把条件封装到哪个对象中去 * @param query 查询关键字，比如groupBy，orderBy等 * @param cb 用来封装条件对象的 * @return 如果返回null，则代表不需要任何条件 */ @Override public Predicate toPredicate(Root&lt;Label&gt; root, CriteriaQuery&lt;?&gt; query, CriteriaBuilder cb) { List&lt;Predicate&gt; list=new ArrayList&lt;&gt;(); //相当于 where labelname like \"%小明%\" if(label.getLabelname()!=null&amp;&amp;!\"\".equals(label.getLabelname())){ Predicate predicate = cb.like(root.get(\"labelname\").as(String.class), \"%\" + label.getLabelname() + \"%\"); list.add(predicate); } if(label.getState()!=null&amp;&amp;!\"\".equals(label.getState())){ Predicate predicate = cb.equal(root.get(\"state\").as(String.class), label.getState()); list.add(predicate); } Predicate[] parr=new Predicate[list.size()]; list.toArray(parr); return cb.and(parr); } },pageable); }//controller层 @RequestMapping(value = \"/search/{page}/{size}\",method = RequestMethod.POST) public Result findSearchAndPageQuery(@RequestBody Label label,@PathVariable int page,@PathVariable int size){ Page&lt;Label&gt; pageData=labelService.findSearchAndPageQuery(label,page,size); return new Result(true,StatusCode.OK,\"查询成功\",new PageResult&lt;Label&gt;(pageData.getTotalElements(),pageData.getContent())); }//用来封装pageResult的类public class PageResult&lt;T&gt; { private long total; private List&lt;T&gt; rows; public long getTotal() { return total; } public void setTotal(long total) { this.total = total; } public List&lt;T&gt; getRows() { return rows; } public void setRows(List&lt;T&gt; rows) { this.rows = rows; } public PageResult() { } public PageResult(long total, List&lt;T&gt; rows) { this.total = total; this.rows = rows; }} 在Dao层通过方法命名方式生成sql语句public interface EnterpriseDao extends JpaRepository&lt;Enterprise,String&gt;,JpaSpecificationExecutor&lt;Enterprise&gt;{ //相当于where ishot=? public List&lt;Enterprise&gt; findByIshot(String ishot); }public interface RecruitDao extends JpaRepository&lt;Recruit,String&gt;,JpaSpecificationExecutor&lt;Recruit&gt;{ //相当于where state=？ order by Createtime，并且取前6个 public List&lt;Recruit&gt; findTop6ByStateOrderByCreatetimeDesc(String state); //相当于where state！=？order by createtime。并且取前6个 public List&lt;Recruit&gt; findTop6ByStateNotOrderByCreatetimeDesc(String state);} 具体命名规则参考https://www.cnblogs.com/oxygenG/p/10057525.html。 处理多对多关系在数据库端处理多对多的关系，必须需要借助中间表。而在java端，只需要在一个对象中放入另一个对象的list集合即可。如果不创建实体类，则需要通过原生的sql语句执行 //通过这个查询语句，才能够实现pageable的分页功能@Query(value=\"SELECT * FROM tb_problem,tb_pl WHERE id=problemid AND labelid=:labelid ORDER BY ?#{#pageable}\", countQuery = \"select count(*) from tb_problem ,tb_pl where id=problemid AND labelid=:labelid\",nativeQuery = true)public Page&lt;Problem&gt; newList(@Param(\"labelid\") String labelid, Pageable pageable); 参考：https://blog.csdn.net/tt____tt/article/details/81027269?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase 事务支持1、Dao层，在可能产生线程问题的语句上添加@Modifying @Modifying@Query(value = \"update tb_article set state='1' where id=?1\",nativeQuery = true)public void updateState(String id); 2、Service层开启注解支持@Transactional @Service@Transactionalpublic class ArticleService {} 缓存的应用Redis–有过期时间限制1、添加SpringDataRedis依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt; 2、服务端Docker开启Redis镜像，生成redis容器 [root@pinyoyougou-docker ~]# docker run -di --name=tensquare_redis -p 6379:6379 redis 3、application.ymal配置host redis: host: 192.168.*.* 4、业务逻辑调用 public class ArticleService { @Autowired private ArticleDao articleDao; @Autowired private RedisTemplate redisTemplate; public Article findById(String id) { //先从缓存中查询当前对象 Article article= (Article) redisTemplate.opsForValue().get(\"article_\"+id); //如果没有渠道 if(article==null){ article = articleDao.findById(id).get(); //存入缓存 redisTemplate.opsForValue().set(\"article_\"+id,article); } return article; } public void deleteById(String id) { //删除缓存 redisTemplate.delete(\"article_\"+id); articleDao.deleteById(id); }} redisTemplate用法 stringRedisTemplate.opsForValue().set(\"test\", \"100\",60*10,TimeUnit.SECONDS);//向redis里存入数据和设置缓存时间stringRedisTemplate.opsForValue().get(\"test\")//根据key获取缓存中的valstringRedisTemplate.delete(\"test\");//根据key删除缓存stringRedisTemplate.hasKey(\"546545\");//检查key是否存在，返回boolean值 SpringCache–无过期时间限制1、SpringApplication开启SpringCache @SpringBootApplication@EnableCachingpublic class GatApplication {} 2、业务层调用，@Cacheable为存，@CacheEvict为删 @Cacheable(value = \"gathering\",key = \"#id\")public Gathering findById(String id) { return gatheringDao.findById(id).get();}@CacheEvict(value = \"gathering\",key = \"#gathering.id\")public void update(Gathering gathering) { gatheringDao.save(gathering);} 第二天总结掌握了条件与分页查询，Dao层方法命名规则，事务支持，缓存 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"SpringDataJPA","slug":"SpringDataJPA","permalink":"https://xulilei.github.io/tags/SpringDataJPA/"},{"name":"项目","slug":"项目","permalink":"https://xulilei.github.io/tags/%E9%A1%B9%E7%9B%AE/"}]},{"title":"Docker入门篇","date":"2020-06-05T07:57:43.000Z","path":"2020/06/05/Docker入门/","text":"Docker入门Dokcer为什么会出现？一款产品从开发到上线，一般都需要两套环境。而环境的配置十分麻烦，Docker给出了解决方案 步骤：java–jar（环境）–打包项目带上环境（即Docker镜像）–Docker仓库–下载我们发布的镜像–直接运行即可。 虚拟机技术特点1、资源占用十分多 2、冗余步骤多 3、启动很慢 如下图所示，多个APP共享一个lib环境，可能会造成端口冲突等环境冲突的问题 容器化技术如下图所示，每个模块拥有独属于自己运行的环境，各个模块之间相互隔离 Docker的相关概念Docker架构图 相关术语镜像：images​ 通过这个模版来创建容器服务，比如Mysql镜像–通过Docker运行后，便成为了一个提供服务的容器,一个镜像可以创建多个容器 容器：container​ 提供服务，可以启动、停止、删除等，可类比为一个简单的linux系统 仓库：repository​ 存放镜像的地方，分为共有仓库和私有仓库 Docker安装Nginx1、search：可在命令行和dockerHub上搜索对应版本 2、pull：拉去下载该镜像 3、docker images：查看本机上的镜像 3、运行该镜像 docker run -d --name nginx01 -p 3344:80 nginx #新建一个名字为nginx01的nginx镜像，公网访问地址为3344，内部地址为80，并运行该镜像#-d 后台运行、--name 命名、-p 端口号 4、内部测试 ​ curl localhost:3344 容器数据卷结构示意图如下 防止容器删除后数据丢失，通过实现容器间数据共享，并将产生的数据备份到linux的文件系统上 总结一句话就是：容器的持久化和容器间的同步操作。 使用数据卷​ -v 主机目录:容器内目录 —&gt;映射容器内的目录到主机上 ​ 参考https://xulilei.github.io/2020/06/12/elasticSearch%E5%85%A5%E9%97%A8/ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Docker","slug":"Docker","permalink":"https://xulilei.github.io/tags/Docker/"}]},{"title":"DayOne","date":"2020-06-02T11:02:13.000Z","path":"2020/06/02/十次方社交平台项目/","text":"DayOne系统架构SpringBoot+SpringCloud+SpringMVC+SpringData，也称这种架构模式为spring全家桶 系统模块不再采取按dao，service层划分模块，而是基于每个微服务，再将每个模块封装成一个镜像，再通过springCloud连接起来。因此在每个微服务中便不需要再写接口，因为每个微服务就是最小模块 开发API通过swagger封装，Nginx代理，形成的API开发文档 Restful开发风格我们在项目中经常用到增删改查：get/post/put/delete四种方法，安全：操作不会出现脏读、幻读等操作。幂等：查询成功后不会对数据库造成影响 Get查询是安全且幂等的 Post是不安全且不幂等的 Put改是不安全且幂等的 Delete删是不安全且幂等的 主要工作Mysql环境搭建创建虚拟机，安装docker，下载Mysql镜像，在服务器(192.168.152.128)运行并从本地连接完成建表 创建父工程主要是一些子模块都需要的依赖配置在这里 &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.1.RELEASE&lt;/version&gt; &lt;relativePath/&gt;&lt;/parent&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; &lt;!--SpringCloud全家桶父工程推荐默认配置--&gt;&lt;repositories&gt; &lt;repository&gt; &lt;id&gt;spring-snapshots&lt;/id&gt; &lt;name&gt;Spring Snapshots&lt;/name&gt; &lt;url&gt;https://repo.spring.io/snapshot&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;repository&gt; &lt;id&gt;spring-milestones&lt;/id&gt; &lt;name&gt;Spring Milestones&lt;/name&gt; &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;pluginRepositories&gt; &lt;pluginRepository&gt; &lt;id&gt;spring-snapshots&lt;/id&gt; &lt;name&gt;Spring Snapshots&lt;/name&gt; &lt;url&gt;https://repo.spring.io/snapshot&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/pluginRepository&gt; &lt;pluginRepository&gt; &lt;id&gt;spring-milestones&lt;/id&gt; &lt;name&gt;Spring Milestones&lt;/name&gt; &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/pluginRepository&gt; &lt;/pluginRepositories&gt; 模块搭建公共模块搭建，根据swagger约定，封装数据传输到前端。其中utils包下的idWoker根据雪花算法，可以生成不同的ID，吞吐量为20W+。 基础模块搭建，数据的CRUD操作 import com.tensquare.base.pojo.Label;import org.springframework.data.jpa.repository.JpaRepository;import org.springframework.data.jpa.repository.JpaSpecificationExecutor;//SpringDataJpa封装了CRUD操作，以及一些复杂的条件查询public interface LabelDao extends JpaRepository&lt;Label,String&gt;, JpaSpecificationExecutor&lt;Label&gt; {} Day01总结在服务器端，通过Docker创建了Mysql镜像 通过本地IDEA的DataSource连接上去。 通过PostMan检查当天的CRUD操作 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"项目","slug":"项目","permalink":"https://xulilei.github.io/tags/%E9%A1%B9%E7%9B%AE/"}]}]