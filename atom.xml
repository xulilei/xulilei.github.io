<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Humble</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://xulilei.github.io/"/>
  <updated>2020-07-15T05:12:52.756Z</updated>
  <id>https://xulilei.github.io/</id>
  
  <author>
    <name>Mr.Xu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>秋招基础复习之IO</title>
    <link href="https://xulilei.github.io/2020/07/14/%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%E4%B9%8BIO/"/>
    <id>https://xulilei.github.io/2020/07/14/%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%E4%B9%8BIO/</id>
    <published>2020-07-14T06:07:52.000Z</published>
    <updated>2020-07-15T05:12:52.756Z</updated>
    
    <content type="html"><![CDATA[<h2 id="秋招基础复习之IO"><a href="#秋招基础复习之IO" class="headerlink" title="秋招基础复习之IO"></a>秋招基础复习之IO</h2><p>基本四个：InputStream，outputStream，reader，writer</p><h3 id="字节流和字符流的区别"><a href="#字节流和字符流的区别" class="headerlink" title="字节流和字符流的区别"></a>字节流和字符流的区别</h3><p>1、字节流是最小单元，但是在字符与字节流的转化过程中，可能会造成乱码，因此提供了直接操作字符的工具</p><p>2、字节流在操作时本身不会用到缓冲区（内存），是文件本身直接操作的；而字符流在操作时使用了缓冲区，通过缓冲区再操作文件。</p><h4 id="什么是缓冲区？有什么作用？"><a href="#什么是缓冲区？有什么作用？" class="headerlink" title="什么是缓冲区？有什么作用？"></a>什么是缓冲区？有什么作用？</h4><p>缓冲区就是一段特殊的内存区域，很多情况下当程序需要频繁地操作一个资源（如文件或数据库）则性能会很低，所以为了提升性能就可以将一部分数据暂时读写到缓存区，以后直接从此区域中读写数据即可，这样就显著提升了性能。</p><h4 id="缓冲和缓存的区别"><a href="#缓冲和缓存的区别" class="headerlink" title="缓冲和缓存的区别"></a>缓冲和缓存的区别</h4><p>缓存（cache）是在读取硬盘中的数据时，把最常用的数据保存在内存的缓存区中，再次读取该数据时，就不去硬盘中读取了，而在缓存中读取。<br>缓冲（buffer）是在向硬盘写入数据时，先把数据放入缓冲区,然后再一起向硬盘写入，把分散的写操作集中进行，减少磁盘碎片和硬盘的反复寻道，从而提高系统性能。</p><h3 id="BIO-NIO-AIO"><a href="#BIO-NIO-AIO" class="headerlink" title="BIO/NIO/AIO"></a>BIO/NIO/AIO</h3><h4 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h4><p>两个阻塞点：Socket socket=serverSocket.accept()处理请求的时候，另一个是InputStream is=socket.getInputStream()处理io流的时候</p><p>优点是：一个线程为一个客户端服务，质量好。</p><p>缺点是：并发量大的时候性能差</p><h4 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h4><h5 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h5><p>Selector(通道的管理器，选择器)：下面两种事件会注册到Selector上</p><p>ServerSocketChannel（相对于BIO的ServerSocket，关心accept事件）</p><p>SocketChannel（相当于BIO的Socket，关心IO操作）</p><p>SelectionKey事件集合</p><h5 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h5><p>1、创建ServerSocketChannel，配置其为非阻塞模式</p><p>2、创建Selector，将之前创建的ServerSocket注册到Selector上，监听accept事件</p><p>3、Selector对象进行死循环监听每一个Channel通道的事件，轮询就绪的Channel</p><p>4、从Selector中获取所有的SelectorKey（这个就可以看成是不同的事件），如果SelectorKey是处于 OP_ACCEPT 状态，说明是新的客户端接入</p><p>5、然后对这个把这个接受的新客户端的Channel通道注册到ServerSocketChannel上，并且把之前的OP_ACCEPT 状态改为SelectionKey.OP_READ读取事件状态，开始读取机制，并且设置为非阻塞的，然后把当前的这个SelectorKey给移除掉，说明这个事件完成了</p><h4 id="I-O多路复用机制（epoll）"><a href="#I-O多路复用机制（epoll）" class="headerlink" title="I/O多路复用机制（epoll）"></a>I/O多路复用机制（epoll）</h4><p>多路I/O复用模型是利用 select、poll、epoll 可以同时监察多个流的 I/O 事件的能力，在空闲的时候，会把当前线程阻塞掉。当有一个或多个流有 I/O事件时，就从阻塞态中唤醒，于是程序就会轮询一遍所有的流（epoll 是只轮询那些真正发出了事件的流），并且只依次顺序的处理就绪的流，这种做法就避免了大量的无用操作</p><h4 id="多路复用读流程"><a href="#多路复用读流程" class="headerlink" title="多路复用读流程"></a>多路复用读流程</h4><p>（1）进行select/epoll系统调用，查询可以读的连接。kernel会查询所有select的可查询socket列表，当任何一个socket中的数据准备好了，select就会返回。</p><p>当用户进程调用了select，那么整个线程会被block（阻塞掉）。</p><p>（2）用户线程获得了目标连接后，发起read系统调用，用户线程阻塞。内核开始复制数据。它就会将数据从kernel内核缓冲区，拷贝到用户缓冲区（用户内存），然后kernel返回结果。</p><p>（3）用户线程才解除block的状态，用户线程终于真正读取到数据，继续执行</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>用select/epoll的优势在于，它可以同时处理成千上万个连接（connection）。与一条线程维护一个连接相比，I/O多路复用技术的最大优势是：系统不必创建线程，也不必维护这些线程，从而大大减小了系统的开销。</p><p>本质上，select/epoll系统调用，属于同步IO，也是阻塞IO。都需要在读写事件就绪后，自己负责进行读写，也就是说这个读写过程是阻塞的。</p><h4 id="epoll-select-poll区别"><a href="#epoll-select-poll区别" class="headerlink" title="epoll/select/poll区别"></a>epoll/select/poll区别</h4><h5 id="1-select-gt-时间复杂度O-n"><a href="#1-select-gt-时间复杂度O-n" class="headerlink" title="(1)select==>时间复杂度O(n)"></a>(1)select==&gt;时间复杂度O(n)</h5><p>它仅仅知道了，有I/O事件发生了，却并不知道是哪那几个流（可能有一个，多个，甚至全部），我们只能无差别轮询所有流，找出能读出数据，或者写入数据的流，对他们进行操作。所以select具有O(n)的无差别轮询复杂度，同时处理的流越多，无差别轮询时间就越长。</p><h5 id="2-poll-gt-时间复杂度O-n"><a href="#2-poll-gt-时间复杂度O-n" class="headerlink" title="(2)poll==>时间复杂度O(n)"></a>(2)poll==&gt;时间复杂度O(n)</h5><p>poll本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态，基于链表来存储.</p><h5 id="3-epoll-gt-时间复杂度O-1"><a href="#3-epoll-gt-时间复杂度O-1" class="headerlink" title="(3)epoll==>时间复杂度O(1)"></a>(3)epoll==&gt;时间复杂度O(1)</h5><p>epoll可以理解为event poll，不同于忙轮询和无差别轮询，epoll会把哪个流发生了怎样的I/O事件通知我们，基于红黑树来存储。</p><p>总结：select，poll实现需要自己不断轮询所有fd集合，直到设备就绪。而epoll是设备就绪时，调用回调函数，把就绪fd放入就绪链表中，并唤醒在epoll_wait中进入睡眠的进程。虽然都要睡眠和交替，但是select和poll在“醒着”的时候要遍历整个fd集合，而epoll在“醒着”的时候只要判断一下就绪链表是否为空就行了，这节省了大量的CPU时间。这就是回调机制带来的性能提升。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;秋招基础复习之IO&quot;&gt;&lt;a href=&quot;#秋招基础复习之IO&quot; class=&quot;headerlink&quot; title=&quot;秋招基础复习之IO&quot;&gt;&lt;/a&gt;秋招基础复习之IO&lt;/h2&gt;&lt;p&gt;基本四个：InputStream，outputStream，reader，write
      
    
    </summary>
    
    
      <category term="秋招基础复习" scheme="https://xulilei.github.io/categories/%E7%A7%8B%E6%8B%9B%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0/"/>
    
    
      <category term="IO" scheme="https://xulilei.github.io/tags/IO/"/>
    
  </entry>
  
  <entry>
    <title>秋招复习之java基础</title>
    <link href="https://xulilei.github.io/2020/07/12/%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%E4%B9%8Bjava%E5%9F%BA%E7%A1%80/"/>
    <id>https://xulilei.github.io/2020/07/12/%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%E4%B9%8Bjava%E5%9F%BA%E7%A1%80/</id>
    <published>2020-07-12T08:15:47.000Z</published>
    <updated>2020-07-14T12:37:43.740Z</updated>
    
    <content type="html"><![CDATA[<h2 id="秋招复习之java基础"><a href="#秋招复习之java基础" class="headerlink" title="秋招复习之java基础"></a>秋招复习之java基础</h2><h4 id="1、面对对象的理解"><a href="#1、面对对象的理解" class="headerlink" title="1、面对对象的理解"></a>1、面对对象的理解</h4><p>面向对象易维护，易复用，易扩展。因为面向对象有封装、继承、多态三大特性，所以基于面对对象思想构建的程序具有低耦合、更灵活、易维护等特点</p><h5 id="封装、继承、多态"><a href="#封装、继承、多态" class="headerlink" title="封装、继承、多态"></a>封装、继承、多态</h5><p>封装：也就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。</p><p>继承：是指可以让某个类型的对象获得另一个类型的对象的属性的方法。</p><p>所态：就是指一个类实例的相同方法在不同情形有不同表现形式</p><h4 id="2、JVM、JRE、JDK"><a href="#2、JVM、JRE、JDK" class="headerlink" title="2、JVM、JRE、JDK"></a>2、JVM、JRE、JDK</h4><p>JVM：被称为java虚拟机，是运行java字节码的虚拟机</p><p>JRE：java运行时环境，包括JVM，Java类库，Java命令和其他一些基础组件</p><p>JDK：拥有JRE所拥有的一切，还有java编译器javac和工具</p><h4 id="3、基本数据类型"><a href="#3、基本数据类型" class="headerlink" title="3、基本数据类型"></a>3、基本数据类型</h4><p><img src="https://gitee.com/xulilei/pic/raw/master/6N89T@$E%60R3PM6%60_0GDV_AC.png" alt=""></p><h4 id="4、重载、重写与重构的区别"><a href="#4、重载、重写与重构的区别" class="headerlink" title="4、重载、重写与重构的区别"></a>4、重载、重写与重构的区别</h4><p>重载：发生在同一个类中，方法名必须相同，参数类型，个数，顺序，返回值类型，访问修饰符等都可以不同</p><p>重写：是子类对父类允许访问的方法的实现过程进行重新编写，发生在子类中，方法名、参数列表必须相同，返回值范围小于等于父类，访问修饰符范围大于等于父类，如果父类是private修饰的就不能重写该方法。也就是说方法提供的行为改变，而方法的外貌并没有改变</p><p>重构：是重写的一种特殊方式，子类与父类的成员方法的返回值、方法名称、参数类型及个数完全相同，唯一不同的是方法实现内容，这种特殊重写方式被称为重构。</p><h4 id="5、StringBuffer、StringBuilder、String"><a href="#5、StringBuffer、StringBuilder、String" class="headerlink" title="5、StringBuffer、StringBuilder、String"></a>5、StringBuffer、StringBuilder、String</h4><p>String：由final关键字修饰，即String对象是不可变的，线程安全</p><p>StringBuffer：对象可变，线程安全</p><p>StringBuilder：对象可变，线程不安全</p><h4 id="6、自动装箱与拆箱"><a href="#6、自动装箱与拆箱" class="headerlink" title="6、自动装箱与拆箱"></a>6、自动装箱与拆箱</h4><p>装箱：将基本数据类型用他们对应的引用类型包装起来</p><p>拆箱：将包装类型转换为基本数据类型</p><p>一种机制，使得这些基本类型在一般的编程中被当作非对象的简单类型处理，在另一些场合，又允许它们被视作是一个对象</p><h4 id="7、静态方法和非静态方法的区别"><a href="#7、静态方法和非静态方法的区别" class="headerlink" title="7、静态方法和非静态方法的区别"></a>7、静态方法和非静态方法的区别</h4><h5 id="一、静态方法"><a href="#一、静态方法" class="headerlink" title="一、静态方法"></a>一、静态方法</h5><p>是使用static关键字修饰的方法，又叫类方法。属于类的，不属于对象，在实例化对象之前就可以通过类名.方法名调用静态方法。<br>A.在静态方法中，可以调用静态方法。<br>B.在静态方法中，不能调用非静态方法。<br>C.在静态方法中，可以引用类变量（即，static修饰的变量）。<br>D.在静态方法中，不能引用成员变量（即，没有static修饰的变量）。<br>E.在静态方法中，不能使用super和this关键字</p><h5 id="二、非静态方法"><a href="#二、非静态方法" class="headerlink" title="二、非静态方法"></a>二、非静态方法</h5><p>是不含有static关键字修饰的普通方法，又称为实例方法，成员方法。属于对象的，不属于类的。成员方法是属于对象的，必须通过new关键字创建对象后，再通过对象调用<br>A.在普通方法中，可以调用普通方法。<br>B.在普通方法中，可以调用静态方法<br>C.在普通方法中，可以引用类变量和成员变量<br>D.在普通方法中，可以使用super和this关键字</p><h5 id="静态方法和非静态方法的区别（生命周期不同）"><a href="#静态方法和非静态方法的区别（生命周期不同）" class="headerlink" title="静态方法和非静态方法的区别（生命周期不同）"></a>静态方法和非静态方法的区别（生命周期不同）</h5><p>静态方法的生命周期跟相应的类一样长，静态方法和静态变量会随着类的定义而被分配和装载入内存中。一直到线程结束，静态属性和方法才会被销毁。（也就是静态方法属于类）<br>非静态方法的生命周期和类的实例化对象一样长，只有当类实例化了一个对象，非静态方法才会被创建，而当这个对象被销毁时，非静态方法也马上被销毁。（也就是非静态方法属于对象）</p><h4 id="8、空构造函数的作用"><a href="#8、空构造函数的作用" class="headerlink" title="8、空构造函数的作用"></a>8、空构造函数的作用</h4><p>构造函数的作用：当new一个对象的时候，调用构造函数完成对象的初始化</p><p>在类中如果没有参构造函数，系统会默认一个无参构造函数，此时写不写空构造没有影响。但如果父类只定义了有参构造，在子类的构造函数中，又没有通过super()来调用父类特定有参构造函数的情况下，将会发生编译错误。</p><h4 id="9、接口和抽象类"><a href="#9、接口和抽象类" class="headerlink" title="9、接口和抽象类"></a>9、接口和抽象类</h4><p>抽象类：抽象类不能实例化，即不能使用new关键字来实例化对象；抽象类可以含有抽象方法，也可以不包含抽象方法，抽象类中可以有具体的方法；抽象类中的抽象方法只有方法体，没有具体实现；</p><p>接口：接口不能被实例化；一个类只能继承一个类，但是可以实现多个接口；接口中方法可以为抽象方法，java8后接口也可以定义静态方法，可以直接通过接口名.方法调用</p><h4 id="10、静态变量、成员变量和局部变量的区别"><a href="#10、静态变量、成员变量和局部变量的区别" class="headerlink" title="10、静态变量、成员变量和局部变量的区别"></a>10、静态变量、成员变量和局部变量的区别</h4><h5 id="一、静态变量和成员变量的区别："><a href="#一、静态变量和成员变量的区别：" class="headerlink" title="一、静态变量和成员变量的区别："></a>一、静态变量和成员变量的区别：</h5><p>(1)所属不同：<br>　　　　静态变量：属于类，也称为类变量。<br>　　　　成员变量：属于对象，也称为对象变量或实例变量。<br>(2)在内存中的位置不同：<br>　　　　静态变量：存储于方法区/元空间。<br>　　　　成员变量：存储于堆内存。<br>(3)生命周期不同：<br>　　　　静态变量：静态变量是随着类的加载而加载，随着类的消失而消失。<br>　　　　成员变量：成员变量是随着对象的创建而存在，随着对象的消失而消失。<br>(4)调用不同：<br>　　　　静态变量：可以通过对象名调用，也可以通过类名调用。<br>　　　　成员变量：只能通过对象名调用。</p><p>二、成员变量和局部变量的区别：<br>(1)在类中的位置不同：<br>　　　　成员变量：在类中方法外。<br>　　　　局部变量：在方法定义中或者方法声明上(即形参)。<br>(2)在内存中的位置不同：<br>　　　　成员变量：在堆中。<br>　　　　局部变量：在栈中。<br>(3)生命周期不同：<br>　　　　成员变量：随着对象的创建而存在，随着对象的消失而消失。<br>　　　　局部变量：随着方法的调用而存在，随着方法的调用完毕而消失。<br>(4)初始化值不同：<br>　　　　成员变量：有默认值。<br>　　　　局部变量：没有默认值，必须定义，赋值，然后才能使用。</p><h4 id="12、直接引用与符号引用"><a href="#12、直接引用与符号引用" class="headerlink" title="12、直接引用与符号引用"></a>12、直接引用与符号引用</h4><p>符号引用：在编译时，java类并不知道所引用的类的实际地址，因此只能使用符号引用来代替。</p><p>直接引用：直接引用可以是直接指向目标的指针</p><h4 id="11、-与equals方法"><a href="#11、-与equals方法" class="headerlink" title="11、==与equals方法"></a>11、==与equals方法</h4><p>==：判断两个对象的地址是不是相等，即判断两个对象是不是同一个对象，基本数据类型比较的是值，引用数据类型比较的是内存地址</p><p>equals：若没有重写equals方法，则比较对象时，等价于“==”，若重写了equals，则等价于重写的相等的逻辑</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>{</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">            String a = <span class="keyword">new</span> String(<span class="string">"ab"</span>); <span class="comment">// a 为⼀个引⽤</span></span><br><span class="line">            String b = <span class="keyword">new</span> String(<span class="string">"ab"</span>); <span class="comment">// b为另⼀个引⽤,对象的内容⼀样</span></span><br><span class="line">            String aa = <span class="string">"ab"</span>; <span class="comment">// 放在常量池中</span></span><br><span class="line">            String bb = <span class="string">"ab"</span>; <span class="comment">// 从常量池中查找</span></span><br><span class="line">            <span class="comment">//true，同一对象</span></span><br><span class="line">            System.out.println(aa==bb);</span><br><span class="line">            <span class="comment">//false，非同一对象</span></span><br><span class="line">            System.out.println(a == b);</span><br><span class="line">            <span class="comment">//String对equals方法进行了重写，a的值与b的值相等</span></span><br><span class="line">            System.out.println(a.equals(b))；</span><br><span class="line">        }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="12、重写equals方法为什么要重写hashcode"><a href="#12、重写equals方法为什么要重写hashcode" class="headerlink" title="12、重写equals方法为什么要重写hashcode()"></a>12、重写equals方法为什么要重写hashcode()</h4><p>equals方法在没有被重写前，比较的是对象的内存地址，而重写后，可能不是同一对象的equals方法也相等</p><p>hashcode的作用是为了获取hash码，定位哈希表中索引的位置，是一个基于内存地址的int整数，而当重写了equals方法后，即使equals方法相等，hashcode也极大概率不等，这时如果我们用重写了equals方法的object作为hash表的key，那么会造成一个从hash表中取值为null的现象，因此需要重写equals方法，使得两者保持一致性</p><h4 id="13、java复制"><a href="#13、java复制" class="headerlink" title="13、java复制"></a>13、java复制</h4><h5 id="为什么说java只有值传递"><a href="#为什么说java只有值传递" class="headerlink" title="为什么说java只有值传递"></a>为什么说java只有值传递</h5><p>Java程序设计语言总是采用按值调用。也就是说，方法得到的是所有参数值的一个拷贝，方法不能修改传递给它的任何参数变量的内容。</p><p>值调用表示方法接收的是调用者提供的值，这种情况下方法引用的是该值的副本，在方法形成的栈中进行相关操作，而按引用调用表示方法接收的是被调用对象的地址的副本，对该副本的修改由于指向了原对象的地址，因此可以修改原对象的内容，但其本质仍然是操作副本，对副本进行的修改</p><h5 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h5><p>对基本数据类型进行值传递；如果该字段是引用类型的话，则复制引用但不复制引用的对象  ，因此原始对象及其副本引用同一个对象  </p><h5 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h5><p>对基本数据类型进行值传递；如果该字段是引用类型的话，则创建一个新的对象，并复制其内容，返回这个新的对象</p><h4 id="14、final关键字"><a href="#14、final关键字" class="headerlink" title="14、final关键字"></a>14、final关键字</h4><p>修饰变量：如果是基本数据类型，则其数值一旦在初始化后就不能更改；如果是引用类型的变量，则对齐初始化后边不能再指向另一个对象</p><p>修饰类：表明这个类不能被继承</p><p>修饰方法：防止该方法被继承，private方法都隐式都指定为final</p><h4 id="15、java异常体系"><a href="#15、java异常体系" class="headerlink" title="15、java异常体系"></a>15、java异常体系</h4><p><img src="https://gitee.com/xulilei/pic/raw/master/20200713160928.png" alt=""></p><p>如果某个方法不能按照正常的途径完成任务，就可以通过另一种路径退出方法。在这种情况下会抛出一个封装了错误信息的对象。此时，这个方法会立刻退出同时不返回任何值。另外，调用这个方法的其他代码也无法继续执行，异常处理机制会将代码执行交给异常处理器  </p><h5 id="异常分类"><a href="#异常分类" class="headerlink" title="异常分类"></a>异常分类</h5><p>Error：类是指 java 运行时系统的内部错误和资源耗尽错误。应用程序不会抛出该类对象。如果出现了这样的错误，除了告知用户，剩下的就是尽力使程序安全的终止。<br>Exception（RuntimeException、 CheckedException）：RuntimeException 如 ： NullPointerException、ClassCastException； 一个是检查异常CheckedException，如 I/O 错误导致的 IOException、 SQLException。</p><h5 id="处理方式"><a href="#处理方式" class="headerlink" title="处理方式"></a>处理方式</h5><p>抛出异常有三种形式，一是 throw,一个 throws，还有一种系统自动抛异常 ：</p><p>throws 用在函数上，后面跟的是异常类，可以跟多个； 而 throw 用在函数内，后面跟的是异常对象 </p><h5 id="try-catch"><a href="#try-catch" class="headerlink" title="try-catch"></a>try-catch</h5><p>try块：用于捕获异常，其后可跟0或多个catch块，如果没有catch块，则必须跟一个finally块</p><p>catch块：用于处理try捕获到的异常</p><p>finally块：无论是否捕获到或者处理了异常，finally块里的语句都会被执行,弱try或者catch语句有return语句时，finally中的语句会被执行，若有返回值会覆盖原始的返回值，如下例子，最终返回0</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> value)</span> </span>{</span><br><span class="line">   <span class="keyword">try</span> {</span><br><span class="line">      <span class="keyword">return</span> value * value;</span><br><span class="line">   } <span class="keyword">finally</span> {</span><br><span class="line">      <span class="keyword">if</span> (value == <span class="number">2</span>) {</span><br><span class="line">         <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      }</span><br><span class="line">     }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="16、java语言的反射机制"><a href="#16、java语言的反射机制" class="headerlink" title="16、java语言的反射机制"></a>16、java语言的反射机制</h4><p>指在运行状态中，对于任意一个类都能够知道这个类所有的属性和方法；并且对于任意一个对象，都能够调用它的任意一个方法；这种动态获取信息以及动态调用对象方法的功能称为 Java 语言的反射机制  </p><h5 id="获取calss对象的三种方法"><a href="#获取calss对象的三种方法" class="headerlink" title="获取calss对象的三种方法"></a>获取calss对象的三种方法</h5><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//1、调用某个对象的getClass()方法：</span></span><br><span class="line">    Person p=<span class="keyword">new</span> Person(); </span><br><span class="line">    Class clazz=p.getClass();</span><br><span class="line"><span class="comment">//2、调用某个类的 class 属性来获取该类对应的 Class 对象：如</span></span><br><span class="line">    Class clazz=Person<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line"><span class="comment">//3、使用 Class 类中的 forName()静态方法(最安全/性能最好/最常用) ：如</span></span><br><span class="line">    Class clazz=Class.forName(<span class="string">"类的全路径"</span>);</span><br></pre></td></tr></tbody></table></figure><h5 id="获取类方法属性信息"><a href="#获取类方法属性信息" class="headerlink" title="获取类方法属性信息"></a>获取类方法属性信息</h5><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//Field 类：Java.lang.reflec 包中的类，表示类的成员变量，可以用来获取和设置类之中的属性值</span></span><br><span class="line">Field[] field=clazz.getDeclaredFields(); </span><br><span class="line"><span class="keyword">for</span>(Field f:field){ </span><br><span class="line">    System.out.println(f.toString());</span><br><span class="line">}</span><br><span class="line"><span class="comment">//Method 类：Java.lang.reflec 包中的类，表示类的方法，它可以用来获取类中的方法信息或者执行方法</span></span><br><span class="line">Method[] method=clazz.getDeclaredMethods();</span><br><span class="line"><span class="keyword">for</span>(Method m:method){ </span><br><span class="line">    System.out.println(m.toString()); </span><br><span class="line">}</span><br><span class="line"><span class="comment">//Constructor 类：Java.lang.reflec 包中的类，表示类的构造方法</span></span><br><span class="line">Constructor[] constructor=clazz.getDeclaredConstructors(); </span><br><span class="line"><span class="keyword">for</span>(Constructor c:constructor){ </span><br><span class="line">    System.out.println(c.toString()); </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="通过反射创建对象的方法"><a href="#通过反射创建对象的方法" class="headerlink" title="通过反射创建对象的方法"></a>通过反射创建对象的方法</h5><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//1、使用 Class 对象的 newInstance()方法来创建该 Class 对象对应类的实例，但是这种方法要求 该 Class 对象对应的类有默认的空构造器</span></span><br><span class="line">Person p=(Person) clazz.newInstance();</span><br><span class="line"><span class="comment">//2、先使用 Class 对象获取指定的 Constructor 对象，再调用 Constructor 对象的 newInstance() 方法来创建 Class 对象对应类的实例</span></span><br><span class="line">Constructor c=clazz.getDeclaredConstructor(String<span class="class">.<span class="keyword">class</span>,<span class="title">String</span>.<span class="title">class</span>,<span class="title">int</span>.<span class="title">class</span>)</span>;</span><br><span class="line">Person p1=(Person) c.newInstance(<span class="string">"李四"</span>,<span class="string">"男"</span>,<span class="number">20</span>);</span><br></pre></td></tr></tbody></table></figure><h4 id="17、对象的序列化和反序列化"><a href="#17、对象的序列化和反序列化" class="headerlink" title="17、对象的序列化和反序列化"></a>17、对象的序列化和反序列化</h4><p>序列化：把对象转换为字节序列的过程称为对象的序列化。保存(持久化)指定的对象，并在将来重新读取被保存的对象。  </p><p>反序列化：把字节序列恢复为对象的过程称为对象的反序列化</p><p>对于不想序列化的变量，使用transient关键词修饰</p><h4 id="18、java泛型"><a href="#18、java泛型" class="headerlink" title="18、java泛型"></a>18、java泛型</h4><p>泛型，即“参数化类型”。就是将类型由原来的具体的类型参数化</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;秋招复习之java基础&quot;&gt;&lt;a href=&quot;#秋招复习之java基础&quot; class=&quot;headerlink&quot; title=&quot;秋招复习之java基础&quot;&gt;&lt;/a&gt;秋招复习之java基础&lt;/h2&gt;&lt;h4 id=&quot;1、面对对象的理解&quot;&gt;&lt;a href=&quot;#1、面对对象的理
      
    
    </summary>
    
    
      <category term="秋招基础复习" scheme="https://xulilei.github.io/categories/%E7%A7%8B%E6%8B%9B%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0/"/>
    
    
      <category term="java基础" scheme="https://xulilei.github.io/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>秋招基础复习之多线程（二）</title>
    <link href="https://xulilei.github.io/2020/07/11/%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B2/"/>
    <id>https://xulilei.github.io/2020/07/11/%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B2/</id>
    <published>2020-07-11T07:32:32.000Z</published>
    <updated>2020-07-11T12:19:23.013Z</updated>
    
    <content type="html"><![CDATA[<h2 id="秋招基础复习之多线程（二）"><a href="#秋招基础复习之多线程（二）" class="headerlink" title="秋招基础复习之多线程（二）"></a>秋招基础复习之多线程（二）</h2><h3 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h3><p>AQS（AbstractQueuedSynchronizer 类）是一个用来构建锁和同步器的框架，各种 Lock 包中的锁（常用的有 ReentrantLock、 ReadWriteLock，countdownlatch、cyclicbarrier）都是基于 AQS 来构建</p><p><img src="https://gitee.com/xulilei/pic/raw/master/20200711154900.png" alt=""></p><h4 id="AQS-工作原理"><a href="#AQS-工作原理" class="headerlink" title="AQS 工作原理"></a>AQS 工作原理</h4><p>AQS的核心思想是，如果被请求的资源空闲，则将当前请求的线程设置为工作线程，并将该资源设置为锁定状态。如果被请求的资源已经被占用，那么就需要一套线程阻塞等待以及唤醒时锁分配的机制，而这个机制是通过CLH队列锁实现的，即将分配不到锁的线程加入到队列中</p><h6 id="CLH锁"><a href="#CLH锁" class="headerlink" title="CLH锁"></a>CLH锁</h6><p>CLH队列是一个虚拟的双向队列，即不存在队列的实例，仅存在节点之间的关联关系，AQS将请求线程封装成CLH队列的一个Node节点，是一个FIFO的过程</p><h4 id="AQS工作步骤"><a href="#AQS工作步骤" class="headerlink" title="AQS工作步骤"></a>AQS工作步骤</h4><p>AQS 在内部定义了一个 volatile int state 变量，表示同步状态：当线程调用 lock 方法时，会通过tryAcquire()独占该锁 ，如果 state=0，说明没有任何线程占有共享资源的锁，可以获得锁并将 state=1；如果 state不为0，先判断是否属于重入的情况，不是的话，则说明有线程目前正在使用共享变量，则该线程必须加入同步队列（CLH）的队尾进行等待，直到占有资源的线程通过tryRelease()对state进行减一操作释放锁到state=0，其他线程才能够去获取该锁。</p><h4 id="AQS公平锁非公平锁"><a href="#AQS公平锁非公平锁" class="headerlink" title="AQS公平锁非公平锁"></a>AQS公平锁非公平锁</h4><ul><li>公平锁：在获取锁时，增加了一个当前线程是否为head结点的判断，当且仅当等待队列为空或者当前线程是等待队列的head结点时才会获取该锁</li><li>非公平锁：那些尝试获取锁且尚未进入等待队列的线程会和等待队列的head节点的线程发生竞争</li></ul><h3 id="AQS组件"><a href="#AQS组件" class="headerlink" title="AQS组件"></a>AQS组件</h3><h4 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h4><h5 id="与Synchronized-相比，可重入锁ReentrantLock其实现原理有什么不同？"><a href="#与Synchronized-相比，可重入锁ReentrantLock其实现原理有什么不同？" class="headerlink" title="与Synchronized 相比，可重入锁ReentrantLock其实现原理有什么不同？"></a>与Synchronized 相比，可重入锁ReentrantLock其实现原理有什么不同？</h5><h6 id="实现方式角度：synchronized操作Mark-Word，lock调用AQS的state和FIFO队列来控制加锁"><a href="#实现方式角度：synchronized操作Mark-Word，lock调用AQS的state和FIFO队列来控制加锁" class="headerlink" title="实现方式角度：synchronized操作Mark Word，lock调用AQS的state和FIFO队列来控制加锁"></a>实现方式角度：synchronized操作Mark Word，lock调用AQS的state和FIFO队列来控制加锁</h6><ul><li>Synchronized 通过在对象头中设置标记实现了这一目的，是一种 JVM 原生的锁实现方式</li><li>而 ReentrantLock 以及所有的基于 Lock 接口的实现类，都是通过用一个 volitile 修饰的 int 型变量，并保证每个线程都能拥有对该 int 的可见性和原子修改， 其本质是基于 AQS 框架。</li></ul><h6 id="从锁释放角度"><a href="#从锁释放角度" class="headerlink" title="从锁释放角度"></a>从锁释放角度</h6><ul><li>Synchronized 在 JVM 层面上实现的，不但可以通过一些监控工具监控 Synchronized 的锁定，而且在代码执行出现异常时，JVM 会自动释放锁定；</li><li>Lock 是通过代码实现的，需要通过 unLock() 来释放锁</li></ul><h6 id="从功能角度，ReentrantLock-比-Synchronized-的同步操作更精细"><a href="#从功能角度，ReentrantLock-比-Synchronized-的同步操作更精细" class="headerlink" title="从功能角度，ReentrantLock 比 Synchronized 的同步操作更精细"></a>从功能角度，ReentrantLock 比 Synchronized 的同步操作更精细</h6><ul><li>如等待可中断：当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，对处理执行时间非常长的同步块很有用。</li><li>带超时的获取锁尝试：在指定的时间范围内获取锁，如果时间到了仍然无法获取则返回。</li><li>可以判断是否有线程在排队等待获取锁，以及是否获取成功。</li><li>可以实现公平锁。</li></ul><h4 id="ReadWriteLock"><a href="#ReadWriteLock" class="headerlink" title="ReadWriteLock"></a>ReadWriteLock</h4><p>虽然 ReentrantLock 和 Synchronized 简单实用，但是行为上有一定局限性，要么不占，要么独占。实际应用场景中， 有时候不需要大量竞争的写操作，而是以并发读取为主，为了进一步优化并发操作的粒度，Java 提供了读写锁。  读写锁基于的原理是多个读操作不需要互斥，如果读锁试图锁定时，写锁是被某个线程持有，读锁将无法获得，而只好等待对方操作结束， 这样就可以自动保证不会读取到有争议的数据</p><h4 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h4><p><img src="https://gitee.com/xulilei/pic/raw/master/20200711172403.png" alt=""></p><h4 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h4><p>CyclicBarrier 叫循环栅栏，它实现让一组线程等待至某个状态之后再全部同时执行，而且当所有等待线程被释放后，CyclicBarrier 可以被重复使用。</p><p><img src="https://gitee.com/xulilei/pic/raw/master/20200711172517.png" alt=""></p><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>1：降低线程切换所带来的资源消耗</p><p>2：解耦作用：线程的创建于执行分开，方便维护</p><p>3：便于其他线程的复用</p><h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><ul><li>在 Java 中，所谓的线程池中的“线程”，其实是被抽象为了一个静态内部类 Worker，它基于 AQS 实现，存放在线程池 的HashSet<worker> workers 成员变量中；</worker></li><li>需要执行的任务则存放在BlockingQueue<runnable> workQueue中。 这样，整个线程池实现的基本思想就是：从workQueue 中不断取出需要执行的任务，放在 Workers 中进行处理。</runnable></li></ul><h4 id="创建线程池"><a href="#创建线程池" class="headerlink" title="创建线程池"></a>创建线程池</h4><h5 id="阿里的开发手册不允许使用Executors去创建线程池，而是通过ThreadPoolExecutor-？"><a href="#阿里的开发手册不允许使用Executors去创建线程池，而是通过ThreadPoolExecutor-？" class="headerlink" title="阿里的开发手册不允许使用Executors去创建线程池，而是通过ThreadPoolExecutor ？"></a>阿里的开发手册不允许使用Executors去创建线程池，而是通过ThreadPoolExecutor ？</h5><p>通过Executors创建的线程池，通过内部构造方法生成的线程池的初始参数会导致OOM</p><p>FixedThreadPool 和SingleThreadExecutor：初始化请求队列的长度为Integer.MAX_VALUE，可能会堆积大量请求，导致OOM</p><p>CachedThreadPool和ScheduledThreadPool：允许创建线程池的数量为Integer.MAX_VALUE，可能会创建大量线程导致OOM</p><h4 id="ThreadPoolExecutor类分析"><a href="#ThreadPoolExecutor类分析" class="headerlink" title="ThreadPoolExecutor类分析"></a>ThreadPoolExecutor类分析</h4><h5 id="常见参数"><a href="#常见参数" class="headerlink" title="常见参数"></a>常见参数</h5><h5 id="corePoolSize：线程池的核心线程数。"><a href="#corePoolSize：线程池的核心线程数。" class="headerlink" title="corePoolSize：线程池的核心线程数。"></a>corePoolSize：线程池的核心线程数。</h5><ul><li>在刚创建线程池时线程不会立即启动，到有任务提交时才开始创建线程并逐步线程数目达到corePoolSize</li></ul><h5 id="maximumPoolSize：线程池允许的最大线程数。"><a href="#maximumPoolSize：线程池允许的最大线程数。" class="headerlink" title="maximumPoolSize：线程池允许的最大线程数。"></a>maximumPoolSize：线程池允许的最大线程数。</h5><ul><li>当核心线程满，且阻塞队列也满时，才会判断当前线程数是否小于最大线程数，才决定是否创建新线程</li></ul><h5 id="keepAliveTime：超过核心线程数时闲置线程的存活时间。"><a href="#keepAliveTime：超过核心线程数时闲置线程的存活时间。" class="headerlink" title="keepAliveTime：超过核心线程数时闲置线程的存活时间。"></a>keepAliveTime：超过核心线程数时闲置线程的存活时间。</h5><h5 id="workQueue：任务执行前保存任务的队列，保存由-execute-方法提交的-Runnable-任务。"><a href="#workQueue：任务执行前保存任务的队列，保存由-execute-方法提交的-Runnable-任务。" class="headerlink" title="workQueue：任务执行前保存任务的队列，保存由 execute 方法提交的 Runnable 任务。"></a>workQueue：任务执行前保存任务的队列，保存由 execute 方法提交的 Runnable 任务。</h5><h5 id="handler：线程池允许的最大线程数。"><a href="#handler：线程池允许的最大线程数。" class="headerlink" title="handler：线程池允许的最大线程数。"></a>handler：线程池允许的最大线程数。</h5><ul><li>线程池中的线程已经用完了，无法继续为新任务服务，等待队列也已经排满了，再也塞不下新任务了，这时候我们就需要拒绝策略机制合理的处理这个问题。  </li></ul><h4 id="线程池种类"><a href="#线程池种类" class="headerlink" title="线程池种类"></a>线程池种类</h4><h5 id="SingleThreadExecutor-线程池"><a href="#SingleThreadExecutor-线程池" class="headerlink" title="SingleThreadExecutor 线程池"></a>SingleThreadExecutor 线程池</h5><ul><li>这个线程池只有一个核心线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束， 那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。</li></ul><h5 id="FixedThreadPool-线程池"><a href="#FixedThreadPool-线程池" class="headerlink" title="FixedThreadPool 线程池"></a>FixedThreadPool 线程池</h5><ul><li>固定大小的线程池，只有核心线程。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。 线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。</li></ul><h5 id="CachedThreadPool-线程池"><a href="#CachedThreadPool-线程池" class="headerlink" title="CachedThreadPool 线程池"></a>CachedThreadPool 线程池</h5><ul><li>无界线程池，如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲（60 秒不执行任务）线程， 当任务数增加时，此线程池又可以智能的添加新线程来处理任务。</li></ul><h5 id="ScheduledThreadPool-线程池"><a href="#ScheduledThreadPool-线程池" class="headerlink" title="ScheduledThreadPool 线程池"></a>ScheduledThreadPool 线程池</h5><ul><li>核心线程池固定，大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。</li></ul><h4 id="ThreadPoolExecutor-handler拒绝策略"><a href="#ThreadPoolExecutor-handler拒绝策略" class="headerlink" title="ThreadPoolExecutor  handler拒绝策略"></a>ThreadPoolExecutor  handler拒绝策略</h4><p>AbortPolicy ： 直接抛出异常，阻止系统正常运行</p><p>CallerRunsPolicy ： 只要线程池未关闭，该策略直接在调用者线程中，运行当前被丢弃的任务。显然这样做不会真的丢弃任务，但是，任务提交线程的性能极有可能会急剧下降。</p><p>DiscardOldestPolicy ： 丢弃最老的一个请求，也就是即将被执行的一个任务，并尝试再次提交当前任务。</p><p>DiscardPolicy ： 该策略默默地丢弃无法处理的任务，不予任何处理。如果允许任务丢失，这是最好的一种方案。  </p><h4 id="执行execute-⽅法和submit-方法的区别是什么呢？"><a href="#执行execute-⽅法和submit-方法的区别是什么呢？" class="headerlink" title="执行execute()⽅法和submit()方法的区别是什么呢？"></a>执行execute()⽅法和submit()方法的区别是什么呢？</h4><p>execute()：用于提交不需要返回值的任务，所以通常传入Runnable对象</p><p>submit()： 用于提交需要返回值的任务，线程池会返回一个Futrue类型的对象，通过get获取返回值，因此通常传入Callable对象</p><h4 id="创建线程池过程"><a href="#创建线程池过程" class="headerlink" title="创建线程池过程"></a>创建线程池过程</h4><p><img src="https://gitee.com/xulilei/pic/raw/master/20200711192440.png" alt=""></p><ul><li>如果正在运行的线程数量小于 corePoolSize，那么马上创建线程运行这个任务；</li><li>如果正在运行的线程数量大于或等于 corePoolSize，那么将这个任务放入队列；</li><li>如果这时候队列满了，而且正在运行的线程数量小于 maximumPoolSize，那么还是要创建非核心线程立刻运行这个任务；</li><li>如果等待队列满了的同时，正在运行的线程数量大于或等于 maximumPoolSize，那么线程池会执行拒绝策略。</li><li>当一个线程完成任务时，它会从队列中取下一个任务来执行。 当一个线程无事可做，超过一定的时间（keepAliveTime）时，线程池会判断。 如果当前运行的线程数大于 corePoolSize，那么这个线程就被停掉。所以线程池的所有任务完成后，它最终会收缩到 corePoolSize 的大小。</li></ul><h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><p>ThreadLocal，线程本地存储， ThreadLocal 的作用是提供线程内的局部变量， 这种变量只在本线程的生命周期内起作用</p><h4 id="实现原理-1"><a href="#实现原理-1" class="headerlink" title="实现原理"></a>实现原理</h4><p>ThreadLocal类中有一个静态内部类ThreadLocalMap，相当于一个哈希表，用private Entry[ ] table来存储数据，其中Entry是一个实现了弱引用（下次GC会被回收）的内部类，它的key为弱引用，目的是为了在GC时防止内存泄漏。而value是强引用，GC是会产生key为null，值为value无法回收的内存，造成内存泄露，ThreadLocalMap会在key回收时，自动清理掉key为null的记录</p><h3 id="原子类"><a href="#原子类" class="headerlink" title="原子类"></a>原子类</h3><p>以AtomicInteger为例</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> <span class="comment">//获取当前的值</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndSet</span><span class="params">(<span class="keyword">int</span> newValue)</span><span class="comment">//获取当前的值，并设置新的值</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span><span class="comment">//获取当前的值，并⾃增</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndDecrement</span><span class="params">()</span> <span class="comment">//获取当前的值，并⾃减</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAdd</span><span class="params">(<span class="keyword">int</span> delta)</span> <span class="comment">//获取当前的值，并加上预期的值</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> <span class="comment">//如果输⼊的数值等于预期值，则以原⼦⽅式将该值设置为输⼊值（update）</span></span></span><br></pre></td></tr></tbody></table></figure><h4 id="AtomicInteger原理"><a href="#AtomicInteger原理" class="headerlink" title="AtomicInteger原理"></a>AtomicInteger原理</h4><p>AtomicInteger主要利用CAS+Volatile+Native方法来保证原子操作，通过本地方法objectFieldO!set()拿到原来值的内存地址，再拿到Volatile修饰的value，最后再通过CAS来进行最终更新值的操作，足以保证在任何时刻任何线程拿到的都是该变量的最新值</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;秋招基础复习之多线程（二）&quot;&gt;&lt;a href=&quot;#秋招基础复习之多线程（二）&quot; class=&quot;headerlink&quot; title=&quot;秋招基础复习之多线程（二）&quot;&gt;&lt;/a&gt;秋招基础复习之多线程（二）&lt;/h2&gt;&lt;h3 id=&quot;AQS&quot;&gt;&lt;a href=&quot;#AQS&quot; c
      
    
    </summary>
    
    
      <category term="秋招基础复习" scheme="https://xulilei.github.io/categories/%E7%A7%8B%E6%8B%9B%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0/"/>
    
    
      <category term="多线程" scheme="https://xulilei.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>秋招基础复习之多线程（一）</title>
    <link href="https://xulilei.github.io/2020/07/10/%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>https://xulilei.github.io/2020/07/10/%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B/</id>
    <published>2020-07-10T07:16:32.000Z</published>
    <updated>2020-07-11T12:15:57.476Z</updated>
    
    <content type="html"><![CDATA[<h2 id="秋招基础复习之多线程（一）"><a href="#秋招基础复习之多线程（一）" class="headerlink" title="秋招基础复习之多线程（一）"></a>秋招基础复习之多线程（一）</h2><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><h4 id="线程和进程的区别？"><a href="#线程和进程的区别？" class="headerlink" title="线程和进程的区别？"></a>线程和进程的区别？</h4><p>进程是系统资源分配的最小单位，线程是CPU调度的基本单位</p><p>线程不能看成独立应用，而进程可以</p><p>进程有独立的地址空间，相互不影响，而线程没有独立的地址空间，只是进程的不同执行路径</p><p>进程的切换开销比线程大</p><h4 id="Java进程和线程的关系"><a href="#Java进程和线程的关系" class="headerlink" title="Java进程和线程的关系"></a>Java进程和线程的关系</h4><p>运行一个程序会产生一个进程，一个进程至少一个线程</p><p>每个进程对应一个JVM实例，多个线程共享JVM的堆</p><h4 id="线程的状态-6种"><a href="#线程的状态-6种" class="headerlink" title="线程的状态(6种)"></a>线程的状态(6种)</h4><p>初始(NEW)：新创建了一个线程对象，但还没有调用start()方法。</p><p>运行(RUNNABLE)：Java线程中将就绪（ready）和运行中（running）两种状态笼统的称为“运行”。</p><p>阻塞(BLOCKED)：表示线程阻塞于锁。</p><p>等待(WAITING)：进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断)不会被分配CPU执行时间，由Object.wait()和Thread.join()导致</p><p>超时等待(TIMED_WAITING)：该状态不同于WAITING，它可以在指定的时间后自行返回。</p><p>终止(TERMINATED)：表示该线程已经执行完毕</p><h4 id="start和run方法的区别"><a href="#start和run方法的区别" class="headerlink" title="start和run方法的区别"></a>start和run方法的区别</h4><p>run()方法只是Thread的一个普通方法的调用，会继续使用当前线程执行该方法</p><p>start()方法会创建一个新的子线程并启动,start()方法会调用JVM的StartThread方法创建一个子线程，并且通过thread_entry方法取调用子线程中的run方法</p><h4 id="Thread类和Runnable接口是什么关系"><a href="#Thread类和Runnable接口是什么关系" class="headerlink" title="Thread类和Runnable接口是什么关系?"></a>Thread类和Runnable接口是什么关系?</h4><p>Thread是实现了Runnable接口的类，使得run支持多线程</p><p>因为类的单一继承性，推荐多使用Runnable接口</p><p>Runnable需要通过构造:Thread t = new Thread(new Runnable())启动</p><h4 id="如何实现处理线程的返回值"><a href="#如何实现处理线程的返回值" class="headerlink" title="如何实现处理线程的返回值"></a>如何实现处理线程的返回值</h4><p>1：主线程等待法(缺点是需要自己实现循环的等待方法，变量多的话代码臃肿)</p><p>2：使用Thread类的join()阻塞当前线程以等待子线程处理完毕，缺点是不能更精细的处理，只能等待join()线程全部执行完毕</p><p>3：通过Callable接口实现：FutureTask和线程池获取</p><ul><li>利用FutureTask获取: FutureTask&lt;&gt; task = new FutureTask&lt;&gt;(new MyCallable())，这里的MyCallable必须实现Callable接口,然后new Thread(task).start()开启新线程，调用task.get();可以或者返回值</li><li>利用线程池获取: ExecutorService newCachedThreadPool = Executors.newCachedThreadPool(); 然后调用线程池的提交方法Future<string> future = newCachedThreadPool.submit(new MyCallable()); 返回一个Future，调用future.get()获取返回值</string></li></ul><h4 id="sleep-和wait-的区别"><a href="#sleep-和wait-的区别" class="headerlink" title="sleep()和wait()的区别"></a>sleep()和wait()的区别</h4><p>sleep是Thread类的方法，wait是Object类中定义的方法，也是native中的方法</p><p>sleep()方法可以在任何地方使用，而wait()方法只能在synchionized方法或synchronized块中使用</p><p>最本质区别：</p><ul><li>Thread.sleep只会让出CPU，不会导致锁行为的改变</li><li>Object.wait()不仅让出CPU，还会释放已经占有的同步资源锁，并进入等待池中，不会再竞争锁，需要通过notify或者notifyAll()唤醒</li></ul><h4 id="锁池和等待池的区别"><a href="#锁池和等待池的区别" class="headerlink" title="锁池和等待池的区别"></a>锁池和等待池的区别</h4><p>锁池：假设某个线程想进入一个对象的synchronized方法，而这个对象锁却被其他线程所占有，该线程就会进入一个地方取等待锁的释放，这个地方就是锁池</p><p>等待池：假设线程A调用了某个对象的wait方法，线程A就会释放该对象的锁，同时进入该对象的等待池中，进入到等待池中的线程不会取竞争该对象的锁，除非被         notify唤醒</p><p>notify()和notifyAll()的区别</p><ul><li>notify只会随机选取一个处于等待池中的线程进入锁池去竞争获取锁的机会</li><li>notifyAll会让所有处于等待池的线程全部进入锁池去竞争获取锁的机会</li></ul><h4 id="interrupt"><a href="#interrupt" class="headerlink" title="interrupt()"></a>interrupt()</h4><p>调用interrupt()，通知线程应该中断了</p><ul><li>1：如果线程处于被阻塞状态，那么线程将立即退出被阻塞状态，并且抛出一个InterruptedException异常。</li><li>2：如果线程处于正常活动状态，那么会将线程的中断标志设置为true，设置中断标志的线程将继续正常运行，不受影响,在运行任务时，我们已经经常检查本线程的中断标志位，如果被设置了中断标志，就自行停止线程</li></ul><p>调用stop()，是让线程强制执行，已经不再推荐使用</p><h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><h5 id="线程死锁和进程死锁"><a href="#线程死锁和进程死锁" class="headerlink" title="线程死锁和进程死锁"></a>线程死锁和进程死锁</h5><p>线程死锁：线程A想要持有线程B持有的资源1，线程B想要持有线程A持有的资源2，互相等待，造成死锁</p><p>进程死锁的四大条件</p><ul><li>互斥条件：即任意时刻，一个资源只能有一个线程持有</li><li>请求与保持：在一个线程请求资源而阻塞的时候，不会释放自己已经持有的资源</li><li>不可剥夺：线程已经获得的资源不能被其他线程强行剥夺，只能等待自己释放</li><li>循环等待：若干进程之间形成一种头尾相接的循环等待的关系</li></ul><h5 id="如何避免死锁"><a href="#如何避免死锁" class="headerlink" title="如何避免死锁"></a>如何避免死锁</h5><p>破坏进程死锁的四大条件</p><ul><li>互斥条件：这个做不到</li><li>请求与保持：一次性申请所有用到的资源，申请不到线程不工作</li><li>不可剥夺：申请其他资源时，如果一段时间申请不到则主动释放已持有的资源</li><li>循环等待：破坏循环等待</li></ul><h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><h4 id="线程安全的主要诱因"><a href="#线程安全的主要诱因" class="headerlink" title="线程安全的主要诱因"></a>线程安全的主要诱因</h4><ul><li>1：存在共享数据（也成临界资源）</li><li>2：存在多条线程共同操作这些共享数据</li></ul><h4 id="解决线程安全问题的根本方法"><a href="#解决线程安全问题的根本方法" class="headerlink" title="解决线程安全问题的根本方法"></a>解决线程安全问题的根本方法</h4><ul><li>同一时刻有且只有一个线程在操作共享数据，其他线程必须等到该线程处理完数据后再对共享数据进行操作</li></ul><h4 id="互斥锁的特性"><a href="#互斥锁的特性" class="headerlink" title="互斥锁的特性"></a>互斥锁的特性</h4><ul><li>互斥性：在同一时间只允许一个线程持有某个对象锁</li><li>可见性：必须确保在锁被释放之前，对共享变量所做的修改，对于随后获得该锁的另一线程是可见的</li></ul><h4 id="什么是可重入性-，为什么说-Synchronized是可重入锁？"><a href="#什么是可重入性-，为什么说-Synchronized是可重入锁？" class="headerlink" title="什么是可重入性 ，为什么说 Synchronized是可重入锁？"></a>什么是可重入性 ，为什么说 Synchronized是可重入锁？</h4><ul><li>从互斥性的设计上来说，当一个线程试图操作一个由其他线程持有的对象锁时，将会处于阻塞状态，但当一个线程再次请求自己持有对象的锁时，这种情况属于重入。可重入性是锁的一个基本要求，如果不能够重入，会发生自己锁死自己的情况。</li></ul><h4 id="获取对象锁的两种用法"><a href="#获取对象锁的两种用法" class="headerlink" title="获取对象锁的两种用法"></a>获取对象锁的两种用法</h4><ul><li>同步代码块，synchronized(this)，锁的是括号中的实例对象，代码块的外面，方法的里面还是异步的。</li><li>同步非静态方法（synchronized method），锁的是当前对象的实例对象，方法整个都是同步的，需要获得当前对象的锁</li></ul><h4 id="获取类锁的两种用法"><a href="#获取类锁的两种用法" class="headerlink" title="获取类锁的两种用法"></a>获取类锁的两种用法</h4><ul><li>同步代码块 synchronized(类.class) 锁的是小括号()中的类对象(Class对象)</li><li>同步静态方法 synchronized static method 锁的是当前对象的类对象(Class对象)</li></ul><h4 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h4><ul><li><p>Java对象在内存中由三部分组成，对象头，实例数据，对齐填充，其中对象头的是synchronized的核心，其中的Mark Word部分存储着锁信息，包括锁的类型，状态标志，通过在对象头设置标记，从而达到了获取锁和释放锁的目的</p><p><img src="https://gitee.com/xulilei/pic/raw/master/20200710155159.png" alt=""></p></li><li><p>monitor:每个java对象天生自带了一把看不见的锁,就是monitor锁，在java虚拟机中，monitor是由ObjectMonitor(在JVM中由C++)实现的，查看JVM中ObjectMonitor源码，里面有一个count_计数器</p></li><li><p>sychronized方法：生成的字节码文件中会多一个ACC_SYNCHRONIZED标志位，当一个线程访问方法时，会先取检查是否存在ACC_SYNCHRONIZED标志，如果存在，执行线程将先获取monitor，获取成功后才能执行方法体，方法执行完后再释放monitor。方法执行期间，其他任何线程都无法再获得同一个monitor对象</p></li><li><p>synchronized代码块：加了synchronized关键字的代码段，生成的字节码文件中会多出monitorenter和monitorexit两条指令，每个monitor维护着一个记录着次数的计数器_count，未被拥有的monitor的该计数器为0，当一个线程执行monitorenter指令，当前线程试图获取对象锁，如果此时的monitor的count计数器为0，线程成功获得monitor，计算器加1，当同一个线程执行了monitorexit指令，计算器减1，当计算器为0时，monitor便被释放.</p></li></ul><h4 id="JDK6以后对于synchronized的优化"><a href="#JDK6以后对于synchronized的优化" class="headerlink" title="JDK6以后对于synchronized的优化"></a>JDK6以后对于synchronized的优化</h4><h5 id="自旋锁和自适应自旋锁"><a href="#自旋锁和自适应自旋锁" class="headerlink" title="自旋锁和自适应自旋锁"></a>自旋锁和自适应自旋锁</h5><ul><li>许多情况下，共享数据的锁定状态持续时间较短，切换线程不值得，通过让线程执行忙循环等待锁的释放，不让出CPU、</li><li>缺点：若锁被其他线程长时间占用，会带来许多性能上的开销</li><li>自适应自旋锁：自旋的次数不再固定，由前一次在同一个锁上的自旋时间以及锁的拥有者的状态来决定</li></ul><h5 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h5><ul><li>如果某个锁不可能被其他线程引用，比如局部变量，由于栈私有，JVM会自动消除内部对象的锁</li></ul><h5 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h5><ul><li>如果检测到一连串的操作都是对同一个对象加锁，JVM会将锁的范围粗化到这一连串操作的外部</li></ul><h4 id="synchronized锁的四种状态以及升级过程"><a href="#synchronized锁的四种状态以及升级过程" class="headerlink" title="synchronized锁的四种状态以及升级过程"></a>synchronized锁的四种状态以及升级过程</h4><h5 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h5><ul><li>无锁–偏向锁–轻量级锁–重量级锁</li></ul><h5 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁:"></a>偏向锁:</h5><ul><li>如果一个线程获得了锁，那么锁就进入偏向模式，Mark Word结构也变为了偏向锁结构，当该线程再次请求锁时，只需要检查Mark Word的锁标记位为偏向锁以及当前线程的ID等于Mark Work 的ThreadID即可。</li><li>不适用于锁竞争比较激烈的多线程场合</li></ul><h5 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h5><ul><li>轻量级锁由偏向锁升级来的，当第二个线程加入锁的争用时，偏向锁会升级为轻量级锁</li><li>每个线程都有自己的栈针，会在栈针中生成一个LockRecord指针，通过CAS去争夺这个锁，LR修改成功的线程获得该锁，而另一个线程会自动进入循环CAS获取这个锁的过程，该过程被称为自旋，因此轻量级锁也被称为自旋锁</li></ul><h5 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h5><ul><li>轻量级锁自旋锁由于一直处于循环CAS的过程，会占据一定量的系统资源，自JDK6后JVM会自适应控制自选次数，当自选次数超过该阈值，则会自动升级为重量级锁。</li><li>升级成重量级锁后，会形成一个队列，没有竞争到锁的线程会进入该队列，且不消耗系统资源</li></ul><h5 id="三种锁的优缺点以及使用场景"><a href="#三种锁的优缺点以及使用场景" class="headerlink" title="三种锁的优缺点以及使用场景"></a>三种锁的优缺点以及使用场景</h5><ul><li>偏向锁的优缺点以及使用场景<ul><li>优点：加锁和解锁不需要CAS操作，没有额外的性能消耗，和非同步方法相比性能差距较小</li><li>缺点：如果线程间存在锁竞争，会带来额外的锁撤销的消耗</li><li>使用场景：只有一个线程访问同步块或者同步方法</li></ul></li><li>轻量级锁的优缺点以及使用场景<ul><li>优点：竞争的线程不会阻塞，提高了响应速度</li><li>缺点：若线程长时间抢不到锁，自旋会消耗CPU性能</li><li>使用场景：线程交替执行同步块或者同步方法的场景</li></ul></li><li>重量级锁的优缺点以及使用场景<ul><li>优点：线程竞争不适用自旋，不会消耗CPU</li><li>缺点：线程阻塞，相应时间缓慢，在多线程下，频繁的获取释放锁，会带来巨大的性能消耗</li><li>使用场景：追求吞吐量，同步块或同步方法执行时间较长的场景</li></ul></li></ul><h3 id="Volatile"><a href="#Volatile" class="headerlink" title="Volatile"></a>Volatile</h3><h4 id="指令重排序"><a href="#指令重排序" class="headerlink" title="指令重排序"></a>指令重排序</h4><p>指令重排序是编译器和处理器为了高效对程序进行优化的手段，它只能保证程序执行的结果时正确的，但是无法保证程序的操作顺序与代码顺序一致。这在单线程中不会构成问题，但是在多线程中就会出现问题。</p><h4 id="指令重排序需要满足的条件"><a href="#指令重排序需要满足的条件" class="headerlink" title="指令重排序需要满足的条件"></a>指令重排序需要满足的条件</h4><ul><li>在单线程环境下不能改变程序运行的结果</li><li>不存在数据依赖关系的</li><li>不满足happens-before原则</li></ul><h4 id="Java内存模型JMM"><a href="#Java内存模型JMM" class="headerlink" title="Java内存模型JMM"></a>Java内存模型JMM</h4><p><img src="https://gitee.com/xulilei/pic/raw/master/JMM1.png" alt=""></p><h5 id="JMM中的主内存（main-memory）"><a href="#JMM中的主内存（main-memory）" class="headerlink" title="JMM中的主内存（main memory）"></a>JMM中的主内存（main memory）</h5><ul><li>存储Java实例对象</li><li>包括成员变量，类信息，常量，静态变量</li><li>属于数据共享的区域，多线程并发操作会引发线程安全问题</li></ul><h5 id="JMM中的工作内存（L1-L2-L3）"><a href="#JMM中的工作内存（L1-L2-L3）" class="headerlink" title="JMM中的工作内存（L1,L2,L3）"></a>JMM中的工作内存（L1,L2,L3）</h5><ul><li>存储当前方法的局部变量信息，局部变量对其他线程不可见</li><li>字节码行号指示器，Native方法信息</li><li>属于线程私有的数据区域，不存在线程安全问题</li></ul><h5 id="读写过程"><a href="#读写过程" class="headerlink" title="读写过程"></a>读写过程</h5><ul><li>将主存中的数据加载到工作内存中</li><li>CPU对工作内存中的数据进行修改</li><li>将每个线程工作内存中修改后的值刷新到主内存中</li></ul><h4 id="Volatile原理"><a href="#Volatile原理" class="headerlink" title="Volatile原理"></a>Volatile原理</h4><p>关键字 volatile 是 Java 虚拟机提供的最轻量级的同步机制。当一个变量被定义成 volatile 之后，具备两种特性：</p><ul><li>1.保证此变量对所有线程的可见性。当一条线程修改了这个变量的值，新值对于其他线程是可以立即得知的。</li><li>2.禁止指令重排序。普通变量仅仅能保证在该方法执行过程中，得到正确结果，但是不保证程序代码的执行顺序。</li></ul><h5 id="如何实现上述两种特性？"><a href="#如何实现上述两种特性？" class="headerlink" title="如何实现上述两种特性？"></a>如何实现上述两种特性？</h5><ul><li>线程可见性：主要通过缓存一致性协议和总线锁两种方式实现<ul><li>立即将线程中工作内存的数据写会到主内存中</li><li>其他处理器数据监测判断自己线程工作区内存中的值是不是过期了，如果过期了，就会将对应的数据置为无效。而当处理器对这个数据进行修改时，会重新从内存中把数据读取到缓存中进行处理。</li></ul></li><li>禁止指令重排序：<ul><li>代码级别：对变量加上volatile修饰</li><li>字节码级别：会生成ACC_volatile指令</li><li>JVM级别：通过JVM的内存屏障禁止内存屏障前后的指令执行重排序优化</li></ul></li></ul><h5 id="DCL单例模式需不需要volatile指令？"><a href="#DCL单例模式需不需要volatile指令？" class="headerlink" title="DCL单例模式需不需要volatile指令？"></a>DCL单例模式需不需要volatile指令？</h5><p>需要，因为在new一个对象的过程中对象并不是刚被创建就会将构造函数中的参数赋值给变量，而是会有一个半初始化的状态，此时如果发生指令重排序会使得别的线程拿到这个半初始化的对象，造成BUG，因此需要双重检测（对象创建的过程见<a href="https://xulilei.github.io/2020/07/06/秋招复习之JVM/">https://xulilei.github.io/2020/07/06/%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%E4%B9%8BJVM/</a>）</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//单例模式</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>{</span><br><span class="line">    <span class="keyword">private</span> Volatile <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>{};</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="comment">//第一次检测</span></span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="keyword">null</span>){</span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton<span class="class">.<span class="keyword">class</span>)</span>{</span><br><span class="line">                <span class="comment">//第二次检测</span></span><br><span class="line">                <span class="keyword">if</span>(instance==<span class="keyword">null</span>){</span><br><span class="line">                    instance=<span class="keyword">new</span> Singleton();</span><br><span class="line">                }         </span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="Syncronized和volatile对比"><a href="#Syncronized和volatile对比" class="headerlink" title="Syncronized和volatile对比"></a>Syncronized和volatile对比</h3><ul><li>volatile本质是告诉JVM当前变量在工作内存中的值是不确定的，需要从主存中读取；synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住直到该线程完成变量操作为止。</li><li>volatile仅能使用在变量上；synchronized则可以使用在变量，方法和类级别</li><li>volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞</li><li>volatile仅能实现变量的修改的可见性，不能保持原子性；而synchronized则可以保证变量修改的可见性和原子性</li></ul><h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><p><img src="https://gitee.com/xulilei/pic/raw/master/20200710180358.png" alt=""></p><h4 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h4><ul><li>底层通过Unsafe类实现原子性操作，包括三个操作数——内存地址V，预期原值A和新值B</li><li>将内存地址的值与预期原值进行比较，如果匹配，那么处理器将该位置的值，自动更新为新值，否则会进行自旋，然后再重新以当前的值为原值再次比较，这也是自旋锁实现的基础</li></ul><h4 id="乐观锁悲观锁"><a href="#乐观锁悲观锁" class="headerlink" title="乐观锁悲观锁"></a>乐观锁悲观锁</h4><ul><li>悲观锁Syncronized：是典型的悲观锁，总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。</li><li>乐观锁CAS：每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据</li></ul><h4 id="CAS缺点（乐观锁的缺点）"><a href="#CAS缺点（乐观锁的缺点）" class="headerlink" title="CAS缺点（乐观锁的缺点）"></a>CAS缺点（乐观锁的缺点）</h4><ul><li>如果自旋时间长，则CPU资源开销很大</li><li>只能保证一个共享变量的原子操作</li><li>ABA问题<ul><li>如果内存地址V初次读取的值为A，并且在准备赋值的时候检查到也为A，如果它曾经被改为了B，但是后来又被改成了A，那么CAS就会误认为它从来没被改变过</li><li>解决：给值加上一个版本号每当修改一次将值加1，或者使用AtomicStampedReference（ 版本戳）</li></ul></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;秋招基础复习之多线程（一）&quot;&gt;&lt;a href=&quot;#秋招基础复习之多线程（一）&quot; class=&quot;headerlink&quot; title=&quot;秋招基础复习之多线程（一）&quot;&gt;&lt;/a&gt;秋招基础复习之多线程（一）&lt;/h2&gt;&lt;h3 id=&quot;线程&quot;&gt;&lt;a href=&quot;#线程&quot; cla
      
    
    </summary>
    
    
      <category term="秋招基础复习" scheme="https://xulilei.github.io/categories/%E7%A7%8B%E6%8B%9B%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0/"/>
    
    
      <category term="多线程" scheme="https://xulilei.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>秋招复习之集合</title>
    <link href="https://xulilei.github.io/2020/07/08/%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%E4%B9%8B%E9%9B%86%E5%90%88/"/>
    <id>https://xulilei.github.io/2020/07/08/%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%E4%B9%8B%E9%9B%86%E5%90%88/</id>
    <published>2020-07-08T04:59:33.000Z</published>
    <updated>2020-07-09T10:24:19.697Z</updated>
    
    <content type="html"><![CDATA[<h1 id="秋招基础复习之集合"><a href="#秋招基础复习之集合" class="headerlink" title="秋招基础复习之集合"></a>秋招基础复习之集合</h1><p><img src="https://gitee.com/xulilei/pic/raw/master/20200708144032.png" alt=""></p><p>集合类存放于 Java.util 包中， 主要有 3 种： set(集）、 list(列表包含 Queue）和 map(映射)。Collection： Collection 是集合 List、 Set、 Queue 的最基本的接口。Iterator：迭代器，可以通过迭代器遍历集合中的数据。Map：是映射表的基础接口 。</p><h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h2><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><p><img src="https://gitee.com/xulilei/pic/raw/master/Collection1.png" alt=""></p><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><h4 id="ArrayList（数组，线程不安全）"><a href="#ArrayList（数组，线程不安全）" class="headerlink" title="ArrayList（数组，线程不安全）"></a>ArrayList（数组，线程不安全）</h4><p>ArrayList 是最常用的 List 实现类，内部是通过数组实现的，它允许对元素进行快速随机访问。数组的缺点是每个元素之间不能有间隔， 当数组大小不满足时需要增加存储能力，就要将已经有数组的数据复制到新的存储空间（1.5倍扩容）中。 当从 ArrayList 的中间位置插入或者删除元素时，需要对数组进行复制、移动、代价比较高。因此，它适合随机查找和遍历，不适合插入和删除。 </p><h4 id="Vector（-数组，线程安全）"><a href="#Vector（-数组，线程安全）" class="headerlink" title="Vector（ 数组，线程安全）"></a>Vector（ 数组，线程安全）</h4><p>Vector 与 ArrayList 一样，也是通过数组实现的，不同的是它支持线程的同步，即某一时刻只有一个线程能够写 Vector，避免多线程同时写而引起的不一致性，但实现同步需要很高的花费，因此，访问它比访问 ArrayList 慢。 </p><h4 id="LinkList（链表，线程不安全）"><a href="#LinkList（链表，线程不安全）" class="headerlink" title="LinkList（链表，线程不安全）"></a>LinkList（链表，线程不安全）</h4><p>LinkedList 是用链表结构存储数据的，很适合数据的动态插入和删除，随机访问和遍历速度比较慢。  </p><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><h4 id="HashSet（Hash表）"><a href="#HashSet（Hash表）" class="headerlink" title="HashSet（Hash表）"></a>HashSet（Hash表）</h4><p>哈希表边存放的是哈希值。 HashSet 存储元素的顺序并不是按照存入时的顺序（和 List 显然不同） 而是按照哈希值来存的所以取数据也是按照哈希值取得。元素的哈希值是通过元素的hashcode 方法来获取的, HashSet 首先判断两个元素的哈希值，如果哈希值一样，接着会比较equals 方法 如果 equls 结果为 true ， HashSet 就视为同一个元素。如果 equals 为 false 就不是同一个元素。HashSet 通过 hashCode 值来确定元素在内存中的位置。 一个 hashCode 位置上可以存放多个元素。  </p><h4 id="TreeSet（二叉树）"><a href="#TreeSet（二叉树）" class="headerlink" title="TreeSet（二叉树）"></a>TreeSet（二叉树）</h4><p>TreeSet()是使用二叉树的原理对新添加的对象按照指定的顺序排序（升序、降序），每增加一个对象都会进行排序，将对象插入的二叉树指定的位置。<br>Integer 和 String 对象都可以进行默认的 TreeSet 排序，而自定义类的对象是不可以的， 自己定义的类必须实现 Comparable 接口，才可以正常使用。</p><h4 id="LinkHashSet（-HashSet-LinkedHashMap）"><a href="#LinkHashSet（-HashSet-LinkedHashMap）" class="headerlink" title="LinkHashSet（ HashSet+LinkedHashMap）"></a>LinkHashSet（ HashSet+LinkedHashMap）</h4><p>对于 LinkedHashSet 而言，它继承与 HashSet、又基于 LinkedHashMap 来实现的。由于底层使用 LinkedHashMap 来保存所有元素 ，因此可以通过双向链表来记录插入的顺序</p><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p><img src="https://gitee.com/xulilei/pic/raw/master/Map.png" alt=""></p><h3 id="HashMap底层实现"><a href="#HashMap底层实现" class="headerlink" title="HashMap底层实现"></a>HashMap底层实现</h3><h4 id="JDK1-7实现"><a href="#JDK1-7实现" class="headerlink" title="JDK1.7实现"></a>JDK1.7实现</h4><p>数组+链表</p><p><img src="https://gitee.com/xulilei/pic/raw/master/20200708161943.png" alt=""></p><p>HashMap 的主干是一个数组，然后数组中每个元素是一个单向链表。上图中，每个绿色的实体是嵌套类 Entry 的实例， Entry 包含四个属性： key, value, hash 值和用于单向链表的 next。</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//默认大小</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line"><span class="comment">//最大容量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="comment">//默认负载因子</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"><span class="comment">//存储元素的数组</span></span><br><span class="line"><span class="keyword">transient</span> Entry[] table;</span><br><span class="line"><span class="comment">//键值对数量</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"><span class="comment">//阈值，size大于阈值触发扩容</span></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"><span class="comment">//负载因子默认是0.75</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line"><span class="comment">//修改次数</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> modCount;</span><br></pre></td></tr></tbody></table></figure><h5 id="Put的过程"><a href="#Put的过程" class="headerlink" title="Put的过程"></a>Put的过程</h5><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>{</span><br><span class="line">    <span class="comment">//容器为空时，调用初始化方法，找到大于threshold的最小二次幂数</span></span><br><span class="line">    <span class="keyword">if</span> (table == EMPTY_TABLE) {</span><br><span class="line">        inflateTable(threshold);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//键为空则存放入数组第0个元素，如果之前有key为null的元素，则新元素将旧元素替换返回，否则创建新的元素并返回null，来看一下创建新元素的逻辑：</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">    <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line">    <span class="comment">//弱key存在，则用新value覆盖oldvalue，并返回覆盖后的值</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) {</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) {</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    modCount++;</span><br><span class="line">    addEntry(hash, key, value, i);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>主要实现方法</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//addEntry过程</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>{</span><br><span class="line">       <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="keyword">null</span> != table[bucketIndex])) {</span><br><span class="line">          resize(<span class="number">2</span> * table.length);</span><br><span class="line">          hash = (<span class="keyword">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">          bucketIndex = indexFor(hash, table.length);</span><br><span class="line">       }</span><br><span class="line">     createEntry(hash, key, value, bucketIndex);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="comment">//在数组下标为bucketIndex的位置创建节点，并将之前的头结点作为新结点的next结点，实现了链表头部插入元素，这样做的好处很明显，节省了插入的效率</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>{</span><br><span class="line">      Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">      table[bucketIndex] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">      size++;</span><br><span class="line">    }</span><br><span class="line"> </span><br><span class="line"><span class="comment">//h（hash）与数组长度-1进行按位与操作，这个操作就保证了插入元素一定是在数组内部</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>{</span><br><span class="line">    <span class="comment">// assert Integer.bitCount(length) == 1 : "length must be a non-zero power of 2";</span></span><br><span class="line">     <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><h5 id="resize过程"><a href="#resize过程" class="headerlink" title="resize过程"></a>resize过程</h5><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span></span>{</span><br><span class="line">     Entry[] oldTable = table;</span><br><span class="line">     <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">     ......</span><br><span class="line">     <span class="comment">//创建一个新的Hash Table</span></span><br><span class="line">     Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];</span><br><span class="line">     <span class="comment">//将Old Hash Table上的数据迁移到New Hash Table上</span></span><br><span class="line">     transfer(newTable);</span><br><span class="line">     table = newTable;</span><br><span class="line">     threshold = (<span class="keyword">int</span>)(newCapacity * loadFactor);</span><br><span class="line">}</span><br><span class="line"><span class="comment">//resize()方法中的transfer()，采用头插法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable, <span class="keyword">boolean</span> rehash)</span> </span>{</span><br><span class="line">      <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">      <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) {</span><br><span class="line">          <span class="keyword">while</span>(<span class="keyword">null</span> != e) {</span><br><span class="line">             Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">             <span class="keyword">if</span> (rehash) {</span><br><span class="line">                e.hash = <span class="keyword">null</span> == e.key ? <span class="number">0</span> : hash(e.key);</span><br><span class="line">             }</span><br><span class="line">             <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);</span><br><span class="line">             e.next = newTable[i];</span><br><span class="line">             newTable[i] = e;</span><br><span class="line">             e = next;</span><br><span class="line">         }</span><br><span class="line">     }</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure><h6 id="造成死循环的原因"><a href="#造成死循环的原因" class="headerlink" title="造成死循环的原因"></a>造成死循环的原因</h6><p>在扩容的过程中，将原来hashMap数组中的链表转移到新的hashmap中时，采用的是头插法进行指针操作，会将原hashmap的链表顺序反转，但如果此时再进来一个线程，会导致next指针指向一个环，形成死循环</p><h4 id="JDK1-8实现"><a href="#JDK1-8实现" class="headerlink" title="JDK1.8实现"></a>JDK1.8实现</h4><p>数组+链表+红黑树，当链表中的元素超过了 8 个以后，会将链表转换为红黑树  </p><p><img src="https://gitee.com/xulilei/pic/raw/master/20200709110657.png" alt=""></p><h5 id="put过程"><a href="#put过程" class="headerlink" title="put过程"></a>put过程</h5><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>{</span><br><span class="line">       <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,<span class="keyword">boolean</span> evict)</span> </span>{</span><br><span class="line">       Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">       <span class="comment">//初始化时，map中还没有key-value</span></span><br><span class="line">       <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">           <span class="comment">//利用resize生成对应的tab[]数组</span></span><br><span class="line">           n = (tab = resize()).length;</span><br><span class="line">       <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">           <span class="comment">//当前桶无元素</span></span><br><span class="line">           tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">       <span class="keyword">else</span> {<span class="comment">//桶内有元素</span></span><br><span class="line">           Node&lt;K,V&gt; e; K k;</span><br><span class="line">           <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">               ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">               <span class="comment">//桶内第一个元素的key等于待放入的key，用</span></span><br><span class="line">               e = p;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">               <span class="comment">//如果此时桶内已经树化</span></span><br><span class="line">               e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">           <span class="keyword">else</span> {<span class="comment">//桶内还是一个链表，则插入链尾（尾插）</span></span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) {</span><br><span class="line">                   <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) {</span><br><span class="line">                       p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                       <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                           <span class="comment">//变成红黑树</span></span><br><span class="line">                           treeifyBin(tab, hash);</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   }</span><br><span class="line">                   <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                       ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   p = e;</span><br><span class="line">               }</span><br><span class="line">           }</span><br><span class="line">           <span class="keyword">if</span> (e != <span class="keyword">null</span>) { <span class="comment">// existing mapping for key</span></span><br><span class="line">               V oldValue = e.value;</span><br><span class="line">               <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                   e.value = value;</span><br><span class="line">               afterNodeAccess(e);</span><br><span class="line">               <span class="keyword">return</span> oldValue;</span><br><span class="line">           }</span><br><span class="line">       }</span><br><span class="line">       <span class="comment">//检查是否应该扩容</span></span><br><span class="line">       ++modCount;</span><br><span class="line">       <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">           resize();</span><br><span class="line">       afterNodeInsertion(evict);</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      }</span><br></pre></td></tr></tbody></table></figure><h6 id="示意图"><a href="#示意图" class="headerlink" title="示意图"></a>示意图</h6><p><img src="https://gitee.com/xulilei/pic/raw/master/20180719172426832.png" alt=""></p><h5 id="resize过程-1"><a href="#resize过程-1" class="headerlink" title="resize过程"></a>resize过程</h5><p>采用尾插法，容量扩充为原来的两倍，再对每个节点重新计算hash值</p><h3 id="HashMap面试问题总结"><a href="#HashMap面试问题总结" class="headerlink" title="HashMap面试问题总结"></a>HashMap面试问题总结</h3><h4 id="1、为什么hashmap的长度是2的幂次方？"><a href="#1、为什么hashmap的长度是2的幂次方？" class="headerlink" title="1、为什么hashmap的长度是2的幂次方？"></a>1、为什么hashmap的长度是2的幂次方？</h4><p>首先不可能直接用散列化后的值直接作为数组下标，而是需要对长度进行取模运算，再得到下标。这个数组下标的计算方法为（n-1）&amp;hash。之所以使用与操作是因为与操作的性能优于取余。而当length是2的幂次方时，hash%length==hash&amp;（length-1），因此长度是2的幂次方。</p><h4 id="2、hashmap1-7与1-8的区别"><a href="#2、hashmap1-7与1-8的区别" class="headerlink" title="2、hashmap1.7与1.8的区别"></a>2、hashmap1.7与1.8的区别</h4><p>(1)结构不同，1.7采用数组+链表，1.8采用数组+链表+红黑树</p><p>(2)插入位置不同，JDK1.7用的是头插法，而JDK1.8及之后使用的都是尾插法，因为JDK1.7是用单链表进行的纵向延伸，当采用头插法时可以避免遍历链表造成的性能损失，但是会容易出现逆序及多线程下环形链表死循环问题。但是在JDK1.8之后因为加入了红黑树使用尾插法，插入效率提升，且能够避免出现逆序和链表死循环的情况</p><p>(3)扩容数据存储位置的计算方式不一样，1.7通过扰动之后的hash&amp;（length-1）得到数组下标，1.8在扩容中只用判断原来的 hash 值与数组长度左移动的一位(扩大一倍)按位与操作是 0 或 1 就行，0 的话索引就不变，1 的话索引变成原索引加上扩容前数组</p><p>(4)扩容时数据的插入时机，1.7是先扩容后插入，1.8是先插入后扩容</p><h4 id="3、为什么HashMap是线程不安全的，实际会如何体现"><a href="#3、为什么HashMap是线程不安全的，实际会如何体现" class="headerlink" title="3、为什么HashMap是线程不安全的，实际会如何体现"></a>3、为什么HashMap是线程不安全的，实际会如何体现</h4><p>第一，如果多个线程同时使用put方法添加元素:假设正好存在两个put的key发生了碰撞(hash值一样)，那么根据HashMap的实现，这两个key会添加到数组的同一个位置，这样最终就会发生其中一个线程的put的数据被覆盖</p><p>第二、hashmap1.7在扩容时，由于采取头插法会导致死循环</p><h3 id="ConCurrentHashMap底层实现"><a href="#ConCurrentHashMap底层实现" class="headerlink" title="ConCurrentHashMap底层实现"></a>ConCurrentHashMap底层实现</h3><h4 id="hashTable实现"><a href="#hashTable实现" class="headerlink" title="hashTable实现"></a>hashTable实现</h4><p><img src="https://gitee.com/xulilei/pic/raw/master/20200709171525.png" alt=""></p><h4 id="JDK1-7实现-1"><a href="#JDK1-7实现-1" class="headerlink" title="JDK1.7实现"></a>JDK1.7实现</h4><p>首先将数据分为一段一段的存储，然后给每一段分配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据仍然能够被访问 </p><p><img src="C:%5CUsers%5Cxu%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200709171613149.png" alt="image-20200709171613149"></p><h4 id="JDK1-8实现-1"><a href="#JDK1-8实现-1" class="headerlink" title="JDK1.8实现"></a>JDK1.8实现</h4><p>1.8的ConcurrentHashMap取消了分段锁，采用CAS和syncronized来保证并发安全，syncronized只锁定一个node链表的首节点</p><p><img src="C:%5CUsers%5Cxu%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200709171619163.png" alt="image-20200709171619163"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;秋招基础复习之集合&quot;&gt;&lt;a href=&quot;#秋招基础复习之集合&quot; class=&quot;headerlink&quot; title=&quot;秋招基础复习之集合&quot;&gt;&lt;/a&gt;秋招基础复习之集合&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://gitee.com/xulilei/pic/ra
      
    
    </summary>
    
    
      <category term="秋招基础复习" scheme="https://xulilei.github.io/categories/%E7%A7%8B%E6%8B%9B%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0/"/>
    
    
      <category term="集合" scheme="https://xulilei.github.io/tags/%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>秋招基础复习之JVM</title>
    <link href="https://xulilei.github.io/2020/07/06/%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%E4%B9%8BJVM/"/>
    <id>https://xulilei.github.io/2020/07/06/%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%E4%B9%8BJVM/</id>
    <published>2020-07-06T07:07:16.000Z</published>
    <updated>2020-07-08T07:17:55.245Z</updated>
    
    <content type="html"><![CDATA[<h1 id="秋招基础复习之JVM"><a href="#秋招基础复习之JVM" class="headerlink" title="秋招基础复习之JVM"></a>秋招基础复习之JVM</h1><h2 id="JVM内存模型"><a href="#JVM内存模型" class="headerlink" title="JVM内存模型"></a>JVM内存模型</h2><p><img src="https://gitee.com/xulilei/pic/raw/master/20200707193840.png" alt=""></p><h2 id="JVM-GC垃圾回收"><a href="#JVM-GC垃圾回收" class="headerlink" title="JVM-GC垃圾回收"></a>JVM-GC垃圾回收</h2><h3 id="知识点概览"><a href="#知识点概览" class="headerlink" title="知识点概览"></a>知识点概览</h3><p><img src="https://gitee.com/xulilei/pic/raw/master/20200706165214.png" alt=""></p><h3 id="判断对象可回收"><a href="#判断对象可回收" class="headerlink" title="判断对象可回收"></a>判断对象可回收</h3><h4 id="引用计数法（JVM中不用）"><a href="#引用计数法（JVM中不用）" class="headerlink" title="引用计数法（JVM中不用）"></a>引用计数法（JVM中不用）</h4><p>给对象添加一个计数器，每当有一个地方引用计数器+1，反之失效-1，当计数器为0的时候，则代表该对象不太可能会被继续用到，则判断该对象为可回收对象，但是会出现循环引用的问题</p><h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><p>为了解决引用计数法的循环引用问题， Java 使用了可达性分析的方法。通过一系列的“GC roots”对象作为起点搜索。如果在“GC roots”和一个对象之间没有可达路径，则称该对象是不可达的。 </p><p> GC roots：类加载器，Thread，虚拟机栈的局部变量表，static成员，本地方法栈等</p><h4 id="强软弱虚引用"><a href="#强软弱虚引用" class="headerlink" title="强软弱虚引用"></a>强软弱虚引用</h4><h5 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h5><p>在 Java 中最常见的就是强引用， 把一个对象赋给一个引用变量，这个引用变量就是一个强引用。当一个对象被强引用变量引用时，它处于可达状态，它是不可能被垃圾回收机制回收的，即使该对象以后永远都不会被用到 JVM 也不会回收。因此强引用是造成 Java 内存泄漏的主要原因之一。</p><h5 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h5><p>软引用需要用 SoftReference 类来实现，对于只有软引用的对象来说，当系统内存足够时它不会被回收，当系统内存空间不足时它会被回收。软引用通常用在对内存敏感的程序中。</p><h5 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h5><p>弱引用需要用 WeakReference 类来实现，它比软引用的生存期更短，对于只有弱引用的对象来说，只要垃圾回收机制一运行，不管 JVM 的内存空间是否足够，总会回收该对象占用的内存。</p><h5 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h5><p>不能单独使用，必须和引用队列联合使用。 虚引用的主要作用是跟踪对象被垃圾回收的状态。  </p><h3 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h3><h4 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h4><h5 id="新生代的复制算法"><a href="#新生代的复制算法" class="headerlink" title="新生代的复制算法"></a>新生代的复制算法</h5><p>eden、survivorFrom  SurvicorTo按照8比1比1划分新生代</p><h6 id="1：eden、-survivorFrom-复制到-SurvivorTo，年龄-1"><a href="#1：eden、-survivorFrom-复制到-SurvivorTo，年龄-1" class="headerlink" title="1：eden、 survivorFrom 复制到 SurvivorTo，年龄+1"></a>1：eden、 survivorFrom 复制到 SurvivorTo，年龄+1</h6><p>首先，把 Eden 和 survivorFrom 区域中存活的对象复制到  SurvivorTo 区域（如果有对象的年龄以及达到了老年的标准15，则赋值到老年代区），同时把这些对象的年龄+1（如果  SurvivorTo 不够位置了就放到老年区）； </p><h6 id="2：清空-eden、-survivorFrom"><a href="#2：清空-eden、-survivorFrom" class="headerlink" title="2：清空 eden、  survivorFrom"></a>2：清空 eden、  survivorFrom</h6><p>然后，清空 Eden 和  survivorFrom 中的对象  </p><h6 id="3：-SurvivorTo和-ServicorFrom-互换"><a href="#3：-SurvivorTo和-ServicorFrom-互换" class="headerlink" title="3： SurvivorTo和 ServicorFrom 互换"></a>3： SurvivorTo和 ServicorFrom 互换</h6><p>最后， SurvivorTo 和 survivorFrom互换，原 SurvivorTo 成为下一次 GC 时的 survivorFrom<br>区。  </p><h5 id="老年代的标记-整理算法"><a href="#老年代的标记-整理算法" class="headerlink" title="老年代的标记-整理算法"></a>老年代的标记-整理算法</h5><p>首先扫描一次所有老年代，标记出存活的对象，让所有存活对象都向一端移动，然后直接清理掉端边界以外的内存</p><h4 id="分区收集算法"><a href="#分区收集算法" class="headerlink" title="分区收集算法"></a>分区收集算法</h4><p>分区算法则将整个堆空间划分为连续的不同小区间, 每个小区间独立使用, 独立回收. 这样做的好处是可以控制一次回收多少个小区间 , 根据目标停顿时间, 每次合理地回收若干个小区间(而不是整个堆), 从而减少一次 GC 所产生的停顿。  </p><h3 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h3><p><img src="https://gitee.com/xulilei/pic/raw/master/garbage.png" alt=""></p><h4 id="新生代"><a href="#新生代" class="headerlink" title="新生代"></a>新生代</h4><h5 id="Serial：单线程收集器，采用复制算法"><a href="#Serial：单线程收集器，采用复制算法" class="headerlink" title="Serial：单线程收集器，采用复制算法"></a>Serial：单线程收集器，采用复制算法</h5><p>它不但只会使用一个 CPU 或一条线程去完成垃圾收集工作，并且在进行垃圾收集的同时，必须暂停其他所有的工作线程，直到垃圾收集结束。它简单高效，对于限定单个 CPU 环境来说，没有线程交互的开销，可以获得最高的单线程垃圾收集效率，因此 Serial垃圾收集器依然是 java 虚拟机运行在 <strong><em>Client</em></strong> 模式下默认的新生代垃圾收集器。  </p><h5 id="Parnew：serial收集器的多线程版本，采用复制算法"><a href="#Parnew：serial收集器的多线程版本，采用复制算法" class="headerlink" title="Parnew：serial收集器的多线程版本，采用复制算法"></a>Parnew：serial收集器的多线程版本，采用复制算法</h5><p>除了使用多线程进行垃圾收集之外，其余的行为和 Serial 收集器完全一样， ParNew 垃圾收集器在垃圾收集过程中同样也要暂停所有其他的工作线程，ParNew垃圾收集器是很多 java虚拟机运行在 <strong><em>Server</em></strong> 模式下新生代的默认垃圾收集    </p><h5 id="Parallel-Scavenge：复制算法，可控制吞吐量的收集器"><a href="#Parallel-Scavenge：复制算法，可控制吞吐量的收集器" class="headerlink" title="Parallel Scavenge：复制算法，可控制吞吐量的收集器"></a>Parallel Scavenge：复制算法，可控制吞吐量的收集器</h5><p>该收集器关注的重点在吞吐量，对用户等待的时间不那么关注，因而适用于在后台运算而不需要太多交互的任务  </p><h4 id="老年代"><a href="#老年代" class="headerlink" title="老年代"></a>老年代</h4><h5 id="Serial-Old：serial收集器的老年代版本，使用标记-整理算法"><a href="#Serial-Old：serial收集器的老年代版本，使用标记-整理算法" class="headerlink" title="Serial Old：serial收集器的老年代版本，使用标记-整理算法"></a>Serial Old：serial收集器的老年代版本，使用标记-整理算法</h5><p>工作时会暂停用户线程</p><h5 id="Parallel-Old：Parallel-Scavenge收集器的老年代版本，多线程，标记-整理算法"><a href="#Parallel-Old：Parallel-Scavenge收集器的老年代版本，多线程，标记-整理算法" class="headerlink" title="Parallel Old：Parallel Scavenge收集器的老年代版本，多线程，标记-整理算法"></a>Parallel Old：Parallel Scavenge收集器的老年代版本，多线程，标记-整理算法</h5><p>工作时会暂停用户线程</p><h5 id="CMS：采用标记-清除算法"><a href="#CMS：采用标记-清除算法" class="headerlink" title="CMS：采用标记-清除算法"></a>CMS：采用标记-清除算法</h5><p>由于耗时最长的并发标记和并发清除过程中，垃圾收集线程可以和用户现在一起并发工作， 所以总体上来看CMS 收集器的内存回收和用户线程是一起并发地执行。 </p><p><img src="https://gitee.com/xulilei/pic/raw/master/20200706195251.png" alt=""></p><h6 id="第一步-初始标记"><a href="#第一步-初始标记" class="headerlink" title="第一步-初始标记"></a>第一步-初始标记</h6><p>只是标记一下 GC Roots 能直接关联的对象，速度很快，仍然需要暂停所有的工作线程。  </p><h6 id="第二步-并发标记"><a href="#第二步-并发标记" class="headerlink" title="第二步-并发标记"></a>第二步-并发标记</h6><p>进行 GC Roots 跟踪的过程，和用户线程一起工作，不需要暂停工作线程  </p><h6 id="第三步-重新标记"><a href="#第三步-重新标记" class="headerlink" title="第三步-重新标记"></a>第三步-重新标记</h6><p>为了修正在并发标记期间，因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，仍然需要暂停所有的工作线程。 </p><h6 id="第四步-并发清除"><a href="#第四步-并发清除" class="headerlink" title="第四步-并发清除"></a>第四步-并发清除</h6><p>清除 GC Roots 不可达对象，和用户线程一起工作，不需要暂停工作线程。 </p><h5 id="Garbage-first：-分区收集以及采用标记-整理算法"><a href="#Garbage-first：-分区收集以及采用标记-整理算法" class="headerlink" title="Garbage first： 分区收集以及采用标记-整理算法"></a>Garbage first： 分区收集以及采用标记-整理算法</h5><p>基于标记-整理算法，不产生内存碎片。可以非常精确控制停顿时间，在不牺牲吞吐量前提下，实现低停顿垃圾回收。</p><p>G1 收集器避免全区域垃圾收集，它把堆内存划分为大小固定的几个独立区域，并且跟踪这些区域的垃圾收集进度，同时在后台维护一个优先级列表，每次根据所允许的收集时间， 优先回收垃圾最多的区域。区域划分和优先级区域回收机制，确保 G1 收集器可以在有限时间获得最高的垃圾收集效率。  </p><h2 id="JVM类加载机制"><a href="#JVM类加载机制" class="headerlink" title="JVM类加载机制"></a>JVM类加载机制</h2><h3 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h3><p><img src="https://gitee.com/xulilei/pic/raw/master/20200707183837.png" alt=""></p><h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><p>加载是类加载过程中的一个阶段， 这个阶段会在内存中生成一个代表这个类的 java.lang.Class 对象  </p><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>这一阶段的主要目的是为了确保 Class 文件的字节流中包含的信息语法符合当前虚拟机的要求  </p><h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p>准备阶段是正式为类变量分配内存并设置类变量的初始值阶段，即在方法区中分配这些变量所使用的内存空间。</p><h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>解析阶段是指虚拟机将常量池中的符号引用替换为直接引用的过程。</p><h6 id="符号引用"><a href="#符号引用" class="headerlink" title="符号引用"></a>符号引用</h6><p>符号引用就是 class 文件中的：  CONSTANT_Class_info、 CONSTANT_Field_info、 CONSTANT_Method_info 等类型的常量，在编译时，java类并不知道所引用的类的实际地址，因此只能使用符号引用来代替。</p><h6 id="直接引用"><a href="#直接引用" class="headerlink" title="直接引用"></a>直接引用</h6><p>直接引用可以是指向目标的指针。如果有了直接引用，那引用的目标必定已经在内存中存在  </p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>初始化阶段是类加载最后一个阶段，前面的类加载阶段由 JVM 主导。到了初始化阶段，才开始真正执行类中定义的 Java 程序代码 </p><h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><h4 id="类加载器的种类"><a href="#类加载器的种类" class="headerlink" title="类加载器的种类"></a>类加载器的种类</h4><p><img src="https://gitee.com/xulilei/pic/raw/master/20200707190324.png" alt=""></p><p>启动类加载器(Bootstrap ClassLoader)：负责加载核心库java.*，由C++编写。</p><p>扩展类加载器(Extension ClassLoader)：负责加载扩展库，由java编写。</p><p>应用程序类加载器(Application ClassLoader)：负责加载程序所在目录，java编写。</p><p>以及自定义加载器。</p><h4 id="双亲委派机制与全盘委派机制"><a href="#双亲委派机制与全盘委派机制" class="headerlink" title="双亲委派机制与全盘委派机制"></a>双亲委派机制与全盘委派机制</h4><p>1、双亲委派机制：先自下而上的委托父类加载目标类，只有当父类加载器反馈自己无法完成这个请求的时候，子类加载器会自上而下的会尝试自己去加载  </p><p>2、全盘委派机制：该类所依赖的类都由该类的类加载器加载</p><h4 id="类加载方式"><a href="#类加载方式" class="headerlink" title="类加载方式"></a>类加载方式</h4><p>new 隐式加载，支持传参，loadclass与forname显式加载，不支持传参。springioc可以懒加载</p><h3 id="对象创建的步骤区别于类加载的过程"><a href="#对象创建的步骤区别于类加载的过程" class="headerlink" title="对象创建的步骤区别于类加载的过程"></a>对象创建的步骤区别于类加载的过程</h3><p>1、虚拟机遇到new命令时，首先检查这个对应的类能否在常量池定位到一个符号引用</p><p>2、判断这个类是否已经被加载解析（解析让符号引用变成直接引用）和初始化，如果没有则进行相应的类加载过程</p><p>3、为新生对象在java堆中分配内存空间，这一步是半初始化（单例的双重检测机制就是为了防止半初始化）</p><p>4、设置对象头相关数据（GC分代年龄、对象的哈希吗、锁等元数据信息）–java对象模型</p><p>5、执行init方法，赋值</p><h3 id="对象分配流程"><a href="#对象分配流程" class="headerlink" title="对象分配流程"></a>对象分配流程</h3><p>1、首先尝试栈上分配，即如果该对象的作用域不会逃逸出该方法之外，则可以将其分配在栈上，随着方法的结束而销毁，不用通过GC收集</p><p>2、若失败则采用tlab分配，会先构造一种线程私有的堆空间，哪怕这块堆空间特别小，但是只要有，就可以每个线程在分配对象到堆空间时，先分配到自己所属的那一块堆空间中，避免同步带来的效率问题，从而提高分配效率</p><p>3、若还是失败，则正常的分配至eden区，若太大则直接进入老年代</p><h2 id="JVM核心参数"><a href="#JVM核心参数" class="headerlink" title="JVM核心参数"></a>JVM核心参数</h2><p>-Xms：最小堆</p><p>-Xmx：最大堆</p><p>-Xmn：新生代内存</p><p>-Xss：栈大小</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;秋招基础复习之JVM&quot;&gt;&lt;a href=&quot;#秋招基础复习之JVM&quot; class=&quot;headerlink&quot; title=&quot;秋招基础复习之JVM&quot;&gt;&lt;/a&gt;秋招基础复习之JVM&lt;/h1&gt;&lt;h2 id=&quot;JVM内存模型&quot;&gt;&lt;a href=&quot;#JVM内存模型&quot; class
      
    
    </summary>
    
    
      <category term="秋招基础复习" scheme="https://xulilei.github.io/categories/%E7%A7%8B%E6%8B%9B%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0/"/>
    
    
      <category term="JVM" scheme="https://xulilei.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>秋招基础复习之计网</title>
    <link href="https://xulilei.github.io/2020/07/05/%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%E4%B9%8B%E8%AE%A1%E7%BD%91/"/>
    <id>https://xulilei.github.io/2020/07/05/%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%E4%B9%8B%E8%AE%A1%E7%BD%91/</id>
    <published>2020-07-05T07:39:30.000Z</published>
    <updated>2020-07-05T10:44:27.684Z</updated>
    
    <content type="html"><![CDATA[<h1 id="秋招基础复习之计网"><a href="#秋招基础复习之计网" class="headerlink" title="秋招基础复习之计网"></a>秋招基础复习之计网</h1><h3 id="7-层模型主要包括："><a href="#7-层模型主要包括：" class="headerlink" title="7 层模型主要包括："></a>7 层模型主要包括：</h3><ol><li><p>物理层：设备之间的比特流传输。 </p></li><li><p>数据链路层：主要将从物理层接收的数据进行 MAC 地址（网卡的地址）的封装与解封装。在这一层工作的设备是交换机，数据通过<strong><em>交换机</em></strong>来传输。 主要协议为ARP协议，提供IP 地址到对应的硬件地址提供动态映射</p></li><li><p>网络层：主要将从下层接收到的数据进行 IP 地址（例 192.168.0.1)的封装与解封装。在这一层工作的设备是<strong><em>路由器</em></strong>，常把这一层的数据叫做数据包。</p></li><li><p>传输层：定义了一些传输数据的协议和端口号（WWW 端口 80 等），如：<strong><em>TCP</em></strong>，<strong><em>UDP</em></strong>协议。 主要是将从下层接收的数据进行分段进行传输，到达目的地址后在进行重组。 常常把这一层数据叫做段。 </p></li><li><p>会话层：通过传输层（端口号：传输端口与接收端口）建立数据传输的通路。主要在你的系统之间发起会话或或者接受会话请求（设备之间需要互相认识可以是IP也可以是 MAC 或者是主机名） </p></li><li><p>表示层：主要是进行对接收的数据进行解释、加密与解密、压缩与解压缩等（也就是把计算机能够 识别的东西转换成人能够能识别的东西（如图片、声音等））</p></li><li><p>应用层：主要是一些终端的应用，比如说FTP（各种文件下载），WEB（IE浏览），QQ之类的（你 就把它理解成我们在电脑屏幕上可以看到的东西．就 是终端应用）。</p></li></ol><h3 id="TCP-IP协议"><a href="#TCP-IP协议" class="headerlink" title="TCP/IP协议"></a>TCP/IP协议</h3><h4 id="TCP三次握手四次挥手"><a href="#TCP三次握手四次挥手" class="headerlink" title="TCP三次握手四次挥手"></a>TCP三次握手四次挥手</h4><h5 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h5><p><img src="https://gitee.com/xulilei/pic/raw/master/20200705160254.png" alt=""></p><h6 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h6><p>第一次握手：主机 A 发送位码为 syn＝1,随机产生seq序列号的数据包到服务器，第二次握手：主机B收到请求后要确认联机信息，同样向A发送syn=1，以及确认请求ACK=1，B的seq序列号，以及A的序列号+1的确认号，第三次握手：主机A收到后检查返回的确认号是否正确以及确认请求ACK是否为1，若正确，主机A会再发送确认请求ACK=1以及服务器B的序列号+1的确认号，主机B收到后确认确认序列号值与确认请求 Ack=1 则连接建立成功。</p><h6 id="为什么要三次握手？"><a href="#为什么要三次握手？" class="headerlink" title="为什么要三次握手？"></a>为什么要三次握手？</h6><p>即为什么A还要发送一次确认请求给服务器B，这是为了防止已经失效的连接请求突然又传送到了B。存在这样的一种情况，当A发送连接请求给B，此时由于网络拥堵造成服务器B没有及时收到连接请求，因此A又重新发送了一个请求给B，正常建立连接后，拥堵的第一次请求又传送到了服务器B，如果不采用三次握手，那么B又会发送确认连接的请求给B，又会建立一个新的连接，会浪费许多资源</p><h6 id="syn攻击"><a href="#syn攻击" class="headerlink" title="syn攻击"></a>syn攻击</h6><p>在第一次握手后，服务器向客户端发送确认请求信息后需要等待客户端的再次确认信息，如果此时客户端掉线，服务器会一直尝试发送5次请求信息，会浪费大量资源，可能导致正常的syn请求无法完成。</p><p>那么如何防护呢？</p><p>当syn队列满后，通过tcp_syncookies参数回发syn_cookie给客户端，如果正常连接，客户端会回发这个syn_cookie给服务器，此时即使syn队列满了，依然可以正常建立连接</p><h6 id="建立连接后客户端出现问题怎么办？"><a href="#建立连接后客户端出现问题怎么办？" class="headerlink" title="建立连接后客户端出现问题怎么办？"></a>建立连接后客户端出现问题怎么办？</h6><p>服务器会发送保持会话报文，若一直没有响应一定次数，服务器会中断此次会话</p><h5 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h5><p><img src="https://gitee.com/xulilei/pic/raw/master/20200705164801.png" alt=""></p><h6 id="过程-1"><a href="#过程-1" class="headerlink" title="过程"></a>过程</h6><p>首先由客户端发送一个FIN=1，以及seq=a的请求码给服务器，此时客户端进入等待关闭状态1，服务器收到客户端的关闭请求后，会立即发送一个确认关闭的ACK=1，以及a+1的确认码，和seq=b的序列号给客户端，告诉客户端我收到你关闭的请求了，客户端收到请求后会进入等待关闭状态2，当服务器传送玩最后的数据给客户端后，会发送一个确认关闭FIN=1，确认请求ACK=1确认序列a+1的确认号给客户端，意思是我传送玩所有的数据了，你可以关闭了。客户端在收到服务器第二次关闭请求后回回发最终确认ACK=1，以及第二次的确认序列+1的确认号给服务器，服务器收到后关闭连接，客户端在2MSL时间后关闭连接。</p><h6 id="为什么要四次挥手？"><a href="#为什么要四次挥手？" class="headerlink" title="为什么要四次挥手？"></a>为什么要四次挥手？</h6><p>因为TCP是全双工的，客户端给服务器发送信息的同时，服务器也可以给客户端发送，之所以需要四次挥手，是因为在客户端发送结束请求后，可能服务器的数据还没有传输完毕，因此需要2个等待关闭的状态确保所有数据传输完毕，因此需要四次挥手</p><h6 id="为什么客户端还要等待2msl？"><a href="#为什么客户端还要等待2msl？" class="headerlink" title="为什么客户端还要等待2msl？"></a>为什么客户端还要等待2msl？</h6><p>因为服务器给客户端发送的第二次FIN请求后，客户端回发给服务器的最终确认可能丢失，如果服务器没有收到最终确认，则会再次发送FIN请求给客户端，那么在客户端等待关闭的这2MSL里再次收到请求后，会再次发送最终请求，使得服务器能够正常准确的关闭</p><h4 id="如何理解IP协议的不可靠和无连接？"><a href="#如何理解IP协议的不可靠和无连接？" class="headerlink" title="如何理解IP协议的不可靠和无连接？"></a>如何理解IP协议的不可靠和无连接？</h4><p>不可靠：指的是不能保证数据报能成功地到达目的地。 发生错误时候，丢弃该数据包，发送 ICMP 消息给信源端，可靠性由上层提供。 </p><p>无状态：IP 不维护关于后续数据报的状态信息。 体现在，IP 数据可以不按顺序发送和接收。A 发送连续的数据报，到达B不一定是连续的， 来回路由选择可能不一样，路线也不一样，到达先后顺序也不一样。</p><h4 id="TCP如何保证可靠性？"><a href="#TCP如何保证可靠性？" class="headerlink" title="TCP如何保证可靠性？"></a>TCP如何保证可靠性？</h4><p>1） 确认机制，发送报文后，等待确认。</p><p>2） 重发机制，没有收到确认，将重发数据段。 </p><p>3） 拥塞控制：慢启动（逐渐增大窗口）、快速重传（收到失序报文立刻重传）、快速恢复（收到重复确认可能没有拥堵，因此不执行慢启动而是快速恢复）、拥塞避免（门限设为一般后开始慢启动算法）</p><p>4） 排序，有专门的序列号字段</p><p>5） 流量控制，通过滑动窗口实现</p><h4 id="TCP与UDP区别"><a href="#TCP与UDP区别" class="headerlink" title="TCP与UDP区别"></a>TCP与UDP区别</h4><p><img src="https://gitee.com/xulilei/pic/raw/master/20200705171843.png" alt=""></p><p>tcp对应的协议有：FTP、HTTP</p><p>udp对应的协议有：DNS</p><h3 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h3><h4 id="http请求报文和响应报文"><a href="#http请求报文和响应报文" class="headerlink" title="http请求报文和响应报文"></a>http请求报文和响应报文</h4><h5 id="http请求报文"><a href="#http请求报文" class="headerlink" title="http请求报文"></a>http请求报文</h5><p>由请求行（get/post方法，url的path路径，http版本）、请求头（键值对）、请求体（body）</p><h6 id="get-post区别"><a href="#get-post区别" class="headerlink" title="get/post区别"></a>get/post区别</h6><p>1、get请求是通过URL传参，而post请求被放在请求体中，因此决定了get不能代替post发送大量数据</p><p>2、get请求的安全性不如post，是由于get请求在url中会被看到</p><p>3、get请求是幂等的，post不幂等（幂等就是多次操作结果一样，get查询多次肯定一样，post是改肯定不一样）</p><h5 id="http响应报文"><a href="#http响应报文" class="headerlink" title="http响应报文"></a>http响应报文</h5><p>由状态码（Status Code）、HTTP头部（编码格式，过期时间）、响应体（响应的内容）</p><h6 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h6><p>1XX：请求已接受一部分，正等待剩余部分</p><p>2XX：正常接收</p><p>3XX：重定向，进一步操作</p><p>4XX：客户端请求出错</p><p>5XX：服务端出错</p><h4 id="http请求过程"><a href="#http请求过程" class="headerlink" title="http请求过程"></a>http请求过程</h4><p>1、DNS域名解析器解析出IP地址</p><p>2、TCP连接（三次握手）</p><p>3、浏览器发送HTTP请求</p><p>4、服务器处理请求并返回HTTP响应</p><p>5、浏览器解析渲染页面</p><p>6、释放连接（四次挥手）</p><h4 id="http长连接，短连接，无状态，HTTP-1-0，HTTP-1-1，HTTP-2-0"><a href="#http长连接，短连接，无状态，HTTP-1-0，HTTP-1-1，HTTP-2-0" class="headerlink" title="http长连接，短连接，无状态，HTTP/1.0，HTTP/1.1，HTTP/2.0"></a>http长连接，短连接，无状态，HTTP/1.0，HTTP/1.1，HTTP/2.0</h4><h5 id="无状态"><a href="#无状态" class="headerlink" title="无状态"></a>无状态</h5><p>无状态：HTTP 协议是无状态的，指的是协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。也就是说，打开一个服务器上的网页和上一次打开这个服务器上的网 页之间没有任何联系。HTTP 是一个无状态的面向连接的协议，无状态不代表 HTTP 不能保 持 TCP 连接，更不能代表 HTTP 使用的是 UDP 协议（无连接）。</p><h5 id="长短连接"><a href="#长短连接" class="headerlink" title="长短连接"></a>长短连接</h5><p>HTTP/1.0 短连接：客户端和服务器每进行一次 HTTP 操作，就建立一次连接，任务结束就中断连接。适用于而像 WEB 网站的http服务</p><p>HTTP/1.1 默认使用长连接：在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输 HTTP 数据 的 TCP 连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。适用于于操作频繁，点对点的通讯，而且连接数不能太多情况。</p><h5 id="HTTP-1-1和HTTP-2-0区别"><a href="#HTTP-1-1和HTTP-2-0区别" class="headerlink" title="HTTP/1.1和HTTP/2.0区别"></a>HTTP/1.1和HTTP/2.0区别</h5><h6 id="1-1管道传输与2-0的多路复用"><a href="#1-1管道传输与2-0的多路复用" class="headerlink" title="1.1管道传输与2.0的多路复用"></a>1.1管道传输与2.0的多路复用</h6><p>HTTP/1.1使用管道传输，即客户端与服务器建立连接后不用每次等待服务器响应就可发送新的请求，但是服务器仍然会顺序响应。如果某一请求出现问题，那么后面的请求都无法加载，这就会出现队头阻塞的问题。</p><p>在HTTP/2.0中通过多路复用解决了这个问题，即将一个TCP连接分为若干个流（Stream），每个流中可以传输若干消息（Message），这样即使一个请求被阻塞了，也不会影响其他请求</p><h6 id="头部数据压缩"><a href="#头部数据压缩" class="headerlink" title="头部数据压缩"></a>头部数据压缩</h6><p>在HTTP1.1中，消息主体都会经过gzip压缩，但状态行和头部却没有经过任何压缩，直接以纯文本传输。</p><p>HTTP2.0对header的数据进行压缩，这样数据体积小了，在网络上传输就会更快。</p><h6 id="传输格式"><a href="#传输格式" class="headerlink" title="传输格式"></a>传输格式</h6><p>2.0采用二进制格式而非文本格式</p><h4 id="HTTP和HTTPS的区别"><a href="#HTTP和HTTPS的区别" class="headerlink" title="HTTP和HTTPS的区别"></a>HTTP和HTTPS的区别</h4><p>1、HTTP是超文本传输协议，是明文传输，而HTTPS则是具有安全协议SSL的加密传输</p><p>2、http是无状态的，而https是有可以进行加密传输，身份认证的</p><h4 id="cookie和session的区别"><a href="#cookie和session的区别" class="headerlink" title="cookie和session的区别"></a>cookie和session的区别</h4><p>1、cookie 是一种发送到客户浏览器的文本串句柄，并保存在客户机硬盘上，可以用来在 某个 WEB 站点会话间持久的保持数据 </p><p>2、session 其实指的就是访问者从到达某个特定主页到离开为止的那段时间。 Session 其 实是利用 Cookie 进行信息处理的，当用户首先进行了请求后，服务端就在用户浏览器 上创建了一个 Cookie，当这个 Session 结束时，其实就是意味着这个 Cookie 就过期 了 </p><p>3、cookie 数据保存在客户端只能存储string类型的对象，session 数据保存在服务器端，可以存储任意类型的对象</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;秋招基础复习之计网&quot;&gt;&lt;a href=&quot;#秋招基础复习之计网&quot; class=&quot;headerlink&quot; title=&quot;秋招基础复习之计网&quot;&gt;&lt;/a&gt;秋招基础复习之计网&lt;/h1&gt;&lt;h3 id=&quot;7-层模型主要包括：&quot;&gt;&lt;a href=&quot;#7-层模型主要包括：&quot; cla
      
    
    </summary>
    
    
      <category term="秋招基础复习" scheme="https://xulilei.github.io/categories/%E7%A7%8B%E6%8B%9B%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0/"/>
    
    
      <category term="计算机网络" scheme="https://xulilei.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>十次方微服务复习</title>
    <link href="https://xulilei.github.io/2020/07/01/%E5%8D%81%E6%AC%A1%E6%96%B9%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%A4%8D%E4%B9%A0/"/>
    <id>https://xulilei.github.io/2020/07/01/%E5%8D%81%E6%AC%A1%E6%96%B9%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%A4%8D%E4%B9%A0/</id>
    <published>2020-07-01T08:17:02.000Z</published>
    <updated>2020-07-05T10:33:01.959Z</updated>
    
    <content type="html"><![CDATA[<h1 id="利用SpringDataJPA完成问答、文章、招聘、交友、吐槽、用户、管理员的增删改以及模糊分页查询"><a href="#利用SpringDataJPA完成问答、文章、招聘、交友、吐槽、用户、管理员的增删改以及模糊分页查询" class="headerlink" title="利用SpringDataJPA完成问答、文章、招聘、交友、吐槽、用户、管理员的增删改以及模糊分页查询"></a>利用SpringDataJPA完成问答、文章、招聘、交友、吐槽、用户、管理员的增删改以及模糊分页查询</h1><p>1、IdWorker：采用推特开源的雪花算法工具类，每秒能产生26W的id，而不产生id碰撞</p><p>SpringDataJpa用法：Dao层接口继承JpaRepository,JpaSpecifationExecutor（复杂查询使用）接口</p><h2 id="模糊分页查询"><a href="#模糊分页查询" class="headerlink" title="模糊分页查询"></a>模糊分页查询</h2><p> 实现条件查询：</p><p>​      3种方式 ：一种是通过在dao层通过nativeQuery编写模糊查询语句，第二种是在dao层通过findBy**Like</p><p>另一种通过service层new Specification构造动态查询语句</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Label&gt; <span class="title">findSearch</span><span class="params">(Label label)</span> </span>{</span><br><span class="line">   <span class="keyword">return</span> labelDao.findAll(<span class="keyword">new</span> Specification&lt;Label&gt;() {</span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> Predicate <span class="title">toPredicate</span><span class="params">(Root&lt;Label&gt; root, CriteriaQuery&lt;?&gt; query, CriteriaBuilder cb)</span> </span>{</span><br><span class="line">          List&lt;Predicate&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">          <span class="comment">//相当于 ****** where labelname like "%label.getLabelname()%"</span></span><br><span class="line">          <span class="keyword">if</span>(label.getLabelname()!=<span class="keyword">null</span>&amp;&amp;!<span class="string">""</span>.equals(label.getLabelname())){</span><br><span class="line">             <span class="comment">//通过root拿到字段名</span></span><br><span class="line">             Predicate predicate = cb.like(root.get(<span class="string">"labelname"</span>).as(String<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line">                                         "%" + label.getLabelname() + "%");</span><br><span class="line">              <span class="comment">//一个条件，添加到cb中 </span></span><br><span class="line">              list.add(predicate);</span><br><span class="line">       }</span><br><span class="line">       <span class="comment">//将条件链表转化为数组</span></span><br><span class="line">       Predicate[] parr=<span class="keyword">new</span> Predicate[list.size()];</span><br><span class="line">       list.toArray(parr);</span><br><span class="line">           <span class="comment">//合并所有条件，一起查询</span></span><br><span class="line">       <span class="keyword">return</span> cb.and(parr);</span><br><span class="line">      });</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure><p>实现分页查询</p><p>dao层构建查询方法时传入pageable对象</p><p>service层调用JPA封装的方法时传入page和size，通过PageRequest生成Pgeable对象，service层返回Page对象</p><p>controller调用service方法，并通过之前定义好的分页类，返回给前端</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//dao层</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Page&lt;Label&gt; <span class="title">findAll</span><span class="params">(Pagealbe pageable)</span></span>{</span><br><span class="line">}</span><br><span class="line"><span class="comment">//service层</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Page&lt;Label&gt; <span class="title">findAll</span><span class="params">(<span class="keyword">int</span> page,<span class="keyword">int</span> size)</span></span>{</span><br><span class="line">    Pageable pageable=PageRequest.of(page-<span class="number">1</span>,size);</span><br><span class="line">    <span class="keyword">return</span> labelDao.findAll(pageable);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/{page}/{size}"</span>,method = RequestMethod.GET)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">findAll</span><span class="params">(@PathVariable <span class="keyword">int</span> page,@PathVariable <span class="keyword">int</span> size)</span></span>{</span><br><span class="line">        Page&lt;Label&gt; all = labelService.findAll(page,size);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Result(<span class="keyword">true</span>, StatusCode.OK,<span class="string">"查询成功"</span>,<span class="keyword">new</span> PageResult&lt;&gt;(all.getTotalElements(),all.getContent()));</span><br><span class="line">    }</span><br><span class="line"><span class="comment">//pageResult类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PageResult</span>&lt;<span class="title">T</span>&gt; </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> total;</span><br><span class="line">    <span class="keyword">private</span> List&lt;T&gt; rows;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getTotal</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> total;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTotal</span><span class="params">(<span class="keyword">long</span> total)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.total = total;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;T&gt; <span class="title">getRows</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> rows;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRows</span><span class="params">(List&lt;T&gt; rows)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.rows = rows;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PageResult</span><span class="params">()</span> </span>{</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PageResult</span><span class="params">(<span class="keyword">long</span> total, List&lt;T&gt; rows)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.total = total;</span><br><span class="line">        <span class="keyword">this</span>.rows = rows;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="问答模块主要业务"><a href="#问答模块主要业务" class="headerlink" title="问答模块主要业务"></a>问答模块主要业务</h2><p>主要包含两个个表问题表，回答表</p><p>问题表包含：问题id，问题标题，内容，发布日期，最新回复时间、最新回复人，发布人id，点赞数，是否解决</p><p>回答表包含：回答id，问题id，回答内容，回答日期，回答人id等</p><p>完成的主要业务有</p><p>1、最新回答列表：最新回复的问题显示在上方， 按回复时间降序排序</p><p>2、热门回答列表：按回复数降序排序</p><p>3、等待回答列表： 回复数为0按时间升序排序</p><p>在问题展示，会将每个问题的回复通过分页查询的形式返回给前端</p><h2 id="招聘模块主要业务"><a href="#招聘模块主要业务" class="headerlink" title="招聘模块主要业务"></a>招聘模块主要业务</h2><p>招聘微服务主要有两块：企业信息和招聘信息</p><p>企业表包含：id，name，summary，address，ishot等字段</p><p>招聘信息表包含：jobid，jobname，salary，企业id，发布日期，截止日期，状态（0表关闭，1表开启，2表推荐），关注人数等字段</p><p>完成的主要业务有</p><p>1、展示热门企业列表（通过findByIshot查询）</p><p>2、推荐职业列表（通过findTop4ByStateOrderByCreatetimeDesc：查询状态为2并以创建日期降序排序，查询前4条记录）</p><p>3、最新职位列表（findTop12ByStateNotOrderByCreatetimeDesc：查询状态不为0并以创建日期降序排序，查询前12条记录）</p><h2 id="文章模块主要业务"><a href="#文章模块主要业务" class="headerlink" title="文章模块主要业务"></a>文章模块主要业务</h2><p>文章表包含：文章id，类别，用户id，文章标题，内容，发布日期，审核状态（0，1），点赞数，是否热门等</p><p>完成的主要业务有</p><p>1、管理员审核文章：状态改为1</p><p>2、用户对文章进行评论</p><p>3、通过springdataredis对热门文章缓存,可设置缓存时间</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Article <span class="title">findById</span><span class="params">(String id)</span> </span>{</span><br><span class="line">   <span class="comment">//先从缓存中查询当前对象</span></span><br><span class="line">   Article article= (Article) redisTemplate.opsForValue().get(<span class="string">"article_"</span>+id);</span><br><span class="line">   <span class="comment">//如果没有渠道</span></span><br><span class="line">   <span class="keyword">if</span>(article==<span class="keyword">null</span>){</span><br><span class="line">      article = articleDao.findById(id).get();</span><br><span class="line">      <span class="comment">//如果热门存入缓存</span></span><br><span class="line">       <span class="keyword">if</span>(article.getIshot()==<span class="number">1</span>){</span><br><span class="line">           redisTemplate.opsForValue().set(<span class="string">"article_"</span>+id,article);</span><br><span class="line">       }   </span><br><span class="line">   }</span><br><span class="line">   <span class="keyword">return</span> article;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>4、利用Elasticsearch和ik分词器完成文章的搜索功能，利用logstash同步mysql至elasticsearch</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//创建新的实体类，这里只需要一些必须的字段</span></span><br><span class="line"><span class="meta">@Document</span>(indexName = <span class="string">"articleindex"</span>,type = <span class="string">"article"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Article</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>{</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="comment">//@Field注解作用</span></span><br><span class="line">    <span class="comment">//是否能被搜索到</span></span><br><span class="line">    <span class="comment">//是否分词，整体匹配还是分词匹配</span></span><br><span class="line">    <span class="comment">//是否在页面上显示，即数据库中在该实体类中的字段，就是要显示的</span></span><br><span class="line">    <span class="comment">//analyzer,分词</span></span><br><span class="line">    <span class="comment">//searchAnalyzer，搜索</span></span><br><span class="line">    <span class="meta">@Field</span>(index = <span class="keyword">true</span>,analyzer=<span class="string">"ik_max_word"</span>,searchAnalyzer=<span class="string">"ik_max_word"</span>)</span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line">    <span class="meta">@Field</span>(index = <span class="keyword">true</span>,analyzer=<span class="string">"ik_max_word"</span>,searchAnalyzer=<span class="string">"ik_max_word"</span>)</span><br><span class="line">    <span class="keyword">private</span> String content;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getTitle</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> title;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTitle</span><span class="params">(String title)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.title = title;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> content;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContent</span><span class="params">(String content)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.content = content;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">//dao层</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ArticleDao</span> <span class="keyword">extends</span> <span class="title">ElasticsearchRepository</span>&lt;<span class="title">Article</span>,<span class="title">String</span>&gt; </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Page&lt;Article&gt; <span class="title">findByTitleOrContentLike</span><span class="params">(String title, String content, Pageable pageable)</span></span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//service层</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> Page&lt;Article&gt; <span class="title">findByKey</span><span class="params">(String key, <span class="keyword">int</span> page, <span class="keyword">int</span> size)</span> </span>{</span><br><span class="line">        Pageable pageable= PageRequest.of(page-<span class="number">1</span>,size);</span><br><span class="line">        <span class="keyword">return</span>  articleDao.findByTitleOrContentLike(key,key,pageable);</span><br><span class="line">    }</span><br><span class="line"><span class="comment">//controller层</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/{key}/{page}/{size}"</span>,method = RequestMethod.GET)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">findByKey</span><span class="params">(@PathVariable String key,@PathVariable <span class="keyword">int</span> page,@PathVariable <span class="keyword">int</span> size)</span></span>{</span><br><span class="line">        Page&lt;Article&gt;pageData=articleService.findByKey(key,page,size);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Result(<span class="keyword">true</span>,StatusCode.OK,<span class="string">"搜索成功"</span>,<span class="keyword">new</span> PageResult&lt;Article&gt;(pageData.getTotalElements(),pageData.getContent()));</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><h2 id="吐槽模块"><a href="#吐槽模块" class="headerlink" title="吐槽模块"></a>吐槽模块</h2><p>吐槽表：_id，内容content，发布时间，用户id，点赞数，上级吐槽id</p><p>使用springdataMongoDB完成的主要业务有</p><p>1、发布吐槽，如果是在别人下面吐槽需要将上级吐槽回复数加1</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(spit.getParentid()!=<span class="keyword">null</span>&amp;&amp;!<span class="string">""</span>.equals(spit.getParentid())){<span class="comment">//表示是在别人下面回复</span></span><br><span class="line">    Query query=<span class="keyword">new</span> Query();</span><br><span class="line">    query.addCriteria(Criteria.where(<span class="string">"_id"</span>).is(spit.getParentid()));</span><br><span class="line">    Update update=<span class="keyword">new</span> Update();</span><br><span class="line">    update.inc(<span class="string">"thumbup"</span>,<span class="number">1</span>);</span><br><span class="line">    mongoTemplate.updateFirst(query,update,<span class="string">"spit"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>2、根据上级id查询吐槽列表</p><p>3、吐槽点赞，并通过redis使其不能重复点赞</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//使用mongoDB原生方式实现自增</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">thumbUp</span><span class="params">(String id)</span></span>{</span><br><span class="line">        <span class="comment">//方式一,与数据库多次交互性能较低</span></span><br><span class="line">        <span class="comment">//Spit spit=spitDao.findById(id).get();</span></span><br><span class="line">        <span class="comment">//spit.setThumbup((spit.getThumbup()==null?0:spit.getThumbup())+1);</span></span><br><span class="line">        <span class="comment">//spitDao.save(spit);</span></span><br><span class="line">        <span class="comment">//相当于使用原生mongo命令实现自增：db.spit.update({"_id":"1"},{$inc:{thumbup:NumberInt(1)}})</span></span><br><span class="line">        Query query=<span class="keyword">new</span> Query();</span><br><span class="line">        query.addCriteria(Criteria.where(<span class="string">"_id"</span>).is(<span class="string">"id"</span>));</span><br><span class="line">        Update update=<span class="keyword">new</span> Update();</span><br><span class="line">        update.inc(<span class="string">"thumbup"</span>,<span class="number">1</span>);</span><br><span class="line">       mongoTemplate.updateFirst(query,update,<span class="string">"spit"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/thumbup/{spitId}"</span>,method = RequestMethod.PUT)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">thumbUp</span><span class="params">(@PathVariable String spitId)</span></span>{</span><br><span class="line">    <span class="comment">//由于没有做登陆认证，因此暂时写死ID，实现一个用户只能点赞一次</span></span><br><span class="line">    String userid=<span class="string">"111"</span>;</span><br><span class="line">    <span class="keyword">if</span>(redisTemplate.opsForValue().get(<span class="string">"thumbup_"</span>+userid)!=<span class="keyword">null</span>){</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Result(<span class="keyword">false</span>,StatusCode.REPERROR,<span class="string">"不能重复点赞"</span>);</span><br><span class="line">    };</span><br><span class="line">    spitService.thumbUp(spitId);</span><br><span class="line">    redisTemplate.opsForValue().set(<span class="string">"thumbup_"</span>+userid,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Result(<span class="keyword">true</span>,StatusCode.OK,<span class="string">"点赞成功"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="管理员模块"><a href="#管理员模块" class="headerlink" title="管理员模块"></a>管理员模块</h2><p>管理员登陆，JWT鉴权，在完成鉴权后通过feign可以操作其他模块的业务</p><p>1、在招聘模块对关注人数超过一定值的招聘信息可以设置为推荐，删除超过截止日期的招聘信息</p><p>2、手动设置热门企业</p><p>3、对用户进行管理</p><p>4、审核为通过审核文章，删除违规的文章</p><h2 id="用户中心模块"><a href="#用户中心模块" class="headerlink" title="用户中心模块"></a>用户中心模块</h2><p>用户登陆，JWT鉴权，在完成鉴权后通过feign可以操作其他模块的业务</p><p>完成的主要业务有</p><p>1、用户注册：本地生成6位验证码，redis缓存一份，向rabbitmq发送一份，在处理短信的模块中，监听mq的短信队列拿到想换验证码和手机号，通过阿里云的短信API实现发送短信的功能（处理短信的模块是自动完成的，只需向mq发送相关信息即可）</p><p>2、用户登录：通过spring security的BCryptPasswordEncoder实现密码的加密解密，完成用户登录，登录成功通过JWT向用户发送token，以后请求服务需要在头信息中添加token信息</p><h2 id="交友模块"><a href="#交友模块" class="headerlink" title="交友模块"></a>交友模块</h2><p>分为好友表和非好友表</p><p>好友表包含：用户id，朋友id，islike（0表单向喜欢，1表双向喜欢）</p><p>非好友表包含：用户id，朋友id</p><p>完成的业务：</p><p>1、当A点击喜欢B，好友表增加记录，非好友表删除A不喜欢B，当B喜欢A，修改islike为1</p><p>2、当A点击拉黑B，非好友表增加记录，好友表删除A-B的记录，若B喜欢A，则修改为单向喜欢</p><p>3、于此同时，A喜欢B，A的关注数加1，B的粉丝数加1</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">addFriend</span><span class="params">(String userid, String friendid)</span> </span>{</span><br><span class="line">    <span class="comment">//先判断userid到friendid是否有数据，有就是重复添加好友，返回0</span></span><br><span class="line">    Friend friend=friendDao.findByUseridAndFriendid(userid,friendid);</span><br><span class="line">    <span class="keyword">if</span>(friend!=<span class="keyword">null</span>){</span><br><span class="line">        <span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//再判断以前是否不喜欢</span></span><br><span class="line">    <span class="keyword">if</span>(noFriendDao.findByUseridAndFriendid(userid, friendid)!=<span class="keyword">null</span>){</span><br><span class="line">        noFriendDao.deleteByUseridAndFriendid(userid,friendid);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//直接添加好友，让好友表中的userid到friendid方向的type为0</span></span><br><span class="line">    friend=<span class="keyword">new</span> Friend();</span><br><span class="line">    friend.setUserid(userid);</span><br><span class="line">    friend.setFriendid(friendid);</span><br><span class="line">    friend.setIslike(<span class="string">"0"</span>);</span><br><span class="line">    friendDao.save(friend);</span><br><span class="line">    <span class="comment">//再判断friendid到userid是否有数据，如果有则把双方的状态都改为1</span></span><br><span class="line">    <span class="keyword">if</span>(friendDao.findByUseridAndFriendid(friendid,userid)!=<span class="keyword">null</span>){</span><br><span class="line">        <span class="comment">//把双方islike都改为1</span></span><br><span class="line">        friendDao.updateIslike(<span class="string">"1"</span>,userid,friendid);</span><br><span class="line">        friendDao.updateIslike(<span class="string">"1"</span>,friendid,userid);</span><br><span class="line"></span><br><span class="line">    };</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">addNoFriend</span><span class="params">(String userid,String friendid)</span> </span>{</span><br><span class="line">        <span class="comment">//先判断是否已经是非好友</span></span><br><span class="line">        NoFriend noFriend=noFriendDao.findByUseridAndFriendid(userid, friendid);</span><br><span class="line">        <span class="keyword">if</span>(noFriend!=<span class="keyword">null</span>){</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果之前是好友，现在单方面删除</span></span><br><span class="line">        <span class="keyword">if</span>(friendDao.findByUseridAndFriendid(userid,friendid)!=<span class="keyword">null</span>){</span><br><span class="line">            friendDao.deleteByUseridAndFriendid(userid,friendid);</span><br><span class="line">            <span class="keyword">if</span>(friendDao.findByUseridAndFriendid(friendid,userid)!=<span class="keyword">null</span>)</span><br><span class="line">            friendDao.updateIslike(<span class="string">"0"</span>,friendid,userid);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//删完再添加到noFriend表</span></span><br><span class="line">        noFriend=<span class="keyword">new</span> NoFriend();</span><br><span class="line">        noFriend.setUserid(userid);</span><br><span class="line">        noFriend.setFriendid(friendid);</span><br><span class="line">        noFriendDao.save(noFriend);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><h1 id="完成项目的微服务化"><a href="#完成项目的微服务化" class="headerlink" title="完成项目的微服务化"></a>完成项目的微服务化</h1><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;利用SpringDataJPA完成问答、文章、招聘、交友、吐槽、用户、管理员的增删改以及模糊分页查询&quot;&gt;&lt;a href=&quot;#利用SpringDataJPA完成问答、文章、招聘、交友、吐槽、用户、管理员的增删改以及模糊分页查询&quot; class=&quot;headerlink&quot;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>使用jekins完成项目部署于Docker容器</title>
    <link href="https://xulilei.github.io/2020/06/30/%E4%BD%BF%E7%94%A8jekins%E5%AE%8C%E6%88%90%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/"/>
    <id>https://xulilei.github.io/2020/06/30/%E4%BD%BF%E7%94%A8jekins%E5%AE%8C%E6%88%90%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/</id>
    <published>2020-06-30T07:52:28.000Z</published>
    <updated>2020-06-30T08:41:43.010Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用jekins完成项目部署于Docker容器"><a href="#使用jekins完成项目部署于Docker容器" class="headerlink" title="使用jekins完成项目部署于Docker容器"></a>使用jekins完成项目部署于Docker容器</h2><h3 id="创建Docker私有仓库"><a href="#创建Docker私有仓库" class="headerlink" title="创建Docker私有仓库"></a>创建Docker私有仓库</h3><h4 id="创建私有仓库容器"><a href="#创建私有仓库容器" class="headerlink" title="创建私有仓库容器"></a>创建私有仓库容器</h4><h5 id="拉去镜像，创建容器"><a href="#拉去镜像，创建容器" class="headerlink" title="拉去镜像，创建容器"></a>拉去镜像，创建容器</h5><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">docker pull registry</span><br><span class="line">docker run ‐di ‐‐name=registry ‐p 5000:5000 registry</span><br></pre></td></tr></tbody></table></figure><p>打开浏览器 输入地址<a href="http://192.168.xxx.xxx:5000/v2/_catalog" target="_blank" rel="noopener">http://192.168.xxx.xxx:5000/v2/_catalog</a></p><p>看到 {“repositories”:[]} 表示私有仓库搭建成功并且内容为空</p><h5 id="修改daemon-json"><a href="#修改daemon-json" class="headerlink" title="修改daemon.json"></a>修改daemon.json</h5><p>让docker信任私有仓库</p><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">vi /etc/docker/daemon.json</span><br><span class="line">{"insecure‐registries":["192.168.xxx.xxx:5000"]}</span><br></pre></td></tr></tbody></table></figure><h3 id="maven插件自动部署"><a href="#maven插件自动部署" class="headerlink" title="maven插件自动部署"></a>maven插件自动部署</h3><h4 id="修改宿主机docker配置使其可以远程访问"><a href="#修改宿主机docker配置使其可以远程访问" class="headerlink" title="修改宿主机docker配置使其可以远程访问"></a>修改宿主机docker配置使其可以远程访问</h4><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">vi /lib/systemd/system/docker.service</span><br><span class="line">其中ExecStart=后添加配置 ‐H tcp://0.0.0.0:2375 ‐H unix:///var/run/docker.sock</span><br></pre></td></tr></tbody></table></figure><h4 id="发布的项目pom文件引入插件"><a href="#发布的项目pom文件引入插件" class="headerlink" title="发布的项目pom文件引入插件"></a>发布的项目pom文件引入插件</h4><figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>tensquare_config<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--docker的maven插件，官网：</span></span><br><span class="line"><span class="comment">        https://github.com/spotify/docker‐maven‐plugin --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.spotify<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>docker-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.4.13<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                  <span class="comment">&lt;!--上传私有仓库--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">imageName</span>&gt;</span>192.168.152.xx:5000/${project.artifactId}:${project.version}<span class="tag">&lt;/<span class="name">imageName</span>&gt;</span></span><br><span class="line">                 <span class="comment">&lt;!--基础镜像，意味着docker容器中已经存在jdk8的镜像--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">baseImage</span>&gt;</span>jdk8<span class="tag">&lt;/<span class="name">baseImage</span>&gt;</span></span><br><span class="line">                 <span class="comment">&lt;!--打包命令--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entryPoint</span>&gt;</span>["java", "-jar", "/${project.build.finalName}.jar"]<span class="tag">&lt;/<span class="name">entryPoint</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">targetPath</span>&gt;</span>/<span class="tag">&lt;/<span class="name">targetPath</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">directory</span>&gt;</span>${project.build.directory}</span><br><span class="line">                        <span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">include</span>&gt;</span>${project.build.finalName}.jar<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">dockerHost</span>&gt;</span>http://192.168.152.xx:2375<span class="tag">&lt;/<span class="name">dockerHost</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h4 id="进入该工程所在目录执行命令"><a href="#进入该工程所在目录执行命令" class="headerlink" title="进入该工程所在目录执行命令"></a>进入该工程所在目录执行命令</h4><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">mvn clean package docker:build -DpushImage</span><br></pre></td></tr></tbody></table></figure><h3 id="代码管理服务gogs"><a href="#代码管理服务gogs" class="headerlink" title="代码管理服务gogs"></a>代码管理服务gogs</h3><h4 id="安装gogs"><a href="#安装gogs" class="headerlink" title="安装gogs"></a>安装gogs</h4><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">docker pull gogs/gogs</span><br><span class="line">docker run -d --name=gogs -p 10022:22 -p 3000:3000 -v /var/gogsdata:/data gogs/gogs</span><br></pre></td></tr></tbody></table></figure><h4 id="配置gogs"><a href="#配置gogs" class="headerlink" title="配置gogs"></a>配置gogs</h4><p>在地址栏输入<a href="http://192.168.xxx.xxx:3000" target="_blank" rel="noopener">http://192.168.xxx.xxx:3000</a> 会进入首次运行安装程序页面，我们可以选择一种数据库作为gogs数据的存储，最简单的是选择SQLite3。如果对于规模较大的公司，可以选择MySQL</p><h4 id="页面展示"><a href="#页面展示" class="headerlink" title="页面展示"></a>页面展示</h4><p>idea上传至gogs仓库</p><p><img src="https://gitee.com/xulilei/pic/raw/master/20200630161514.png" alt=""></p><h3 id="jekins持续继承"><a href="#jekins持续继承" class="headerlink" title="jekins持续继承"></a>jekins持续继承</h3><h4 id="配置jekins"><a href="#配置jekins" class="headerlink" title="配置jekins"></a>配置jekins</h4><h5 id="下载安装完后需要配置用户和端口号"><a href="#下载安装完后需要配置用户和端口号" class="headerlink" title="下载安装完后需要配置用户和端口号"></a>下载安装完后需要配置用户和端口号</h5><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">JENKINS_USER="root"</span><br><span class="line">JENKINS_PORT="8888"</span><br></pre></td></tr></tbody></table></figure><h5 id="首次进入，安装插件"><a href="#首次进入，安装插件" class="headerlink" title="首次进入，安装插件"></a>首次进入，安装插件</h5><h6 id="主要的插件有两个一个是maven一个是git"><a href="#主要的插件有两个一个是maven一个是git" class="headerlink" title="主要的插件有两个一个是maven一个是git"></a>主要的插件有两个一个是maven一个是git</h6><p><img src="https://gitee.com/xulilei/pic/raw/master/20200630161906.png" alt=""></p><h5 id="全局工具配置"><a href="#全局工具配置" class="headerlink" title="全局工具配置"></a>全局工具配置</h5><p>服务器安装maven，JDK</p><h6 id="JDK配置"><a href="#JDK配置" class="headerlink" title="JDK配置"></a>JDK配置</h6><h6 id="git配置（一般服务器都已经安装）"><a href="#git配置（一般服务器都已经安装）" class="headerlink" title="git配置（一般服务器都已经安装）"></a>git配置（一般服务器都已经安装）</h6><h6 id="maven配置"><a href="#maven配置" class="headerlink" title="maven配置"></a>maven配置</h6><h4 id="持续继承"><a href="#持续继承" class="headerlink" title="持续继承"></a>持续继承</h4><h5 id="创建一个maven项目"><a href="#创建一个maven项目" class="headerlink" title="创建一个maven项目"></a>创建一个maven项目</h5><p><img src="https://gitee.com/xulilei/pic/raw/master/20200630163344.png" alt=""></p><h5 id="源码管理选git"><a href="#源码管理选git" class="headerlink" title="源码管理选git"></a>源码管理选git</h5><p>URL填写gogs仓库的地址</p><h5 id="Build"><a href="#Build" class="headerlink" title="Build"></a>Build</h5><p>pom要填写生成容器的子项目</p><p><img src="https://gitee.com/xulilei/pic/raw/master/20200630163455.png" alt=""></p><h5 id="执行任务"><a href="#执行任务" class="headerlink" title="执行任务"></a>执行任务</h5><p><img src="https://gitee.com/xulilei/pic/raw/master/20200630163610.png" alt=""></p><h4 id="结果展示"><a href="#结果展示" class="headerlink" title="结果展示"></a>结果展示</h4><p>docker镜像</p><p><img src="https://gitee.com/xulilei/pic/raw/master/20200630163702.png" alt=""></p><p>私有仓库</p><p><img src="https://gitee.com/xulilei/pic/raw/master/20200630163818.png" alt=""></p><p>运行后可以成功展示！</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;使用jekins完成项目部署于Docker容器&quot;&gt;&lt;a href=&quot;#使用jekins完成项目部署于Docker容器&quot; class=&quot;headerlink&quot; title=&quot;使用jekins完成项目部署于Docker容器&quot;&gt;&lt;/a&gt;使用jekins完成项目部署于Do
      
    
    </summary>
    
    
      <category term="微服务" scheme="https://xulilei.github.io/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    
      <category term="jekins" scheme="https://xulilei.github.io/tags/jekins/"/>
    
      <category term="gogs" scheme="https://xulilei.github.io/tags/gogs/"/>
    
  </entry>
  
  <entry>
    <title>集中配置组件SpringCloudConfig</title>
    <link href="https://xulilei.github.io/2020/06/26/%E9%9B%86%E4%B8%AD%E9%85%8D%E7%BD%AE%E7%BB%84%E4%BB%B6SpringCloudConfig/"/>
    <id>https://xulilei.github.io/2020/06/26/%E9%9B%86%E4%B8%AD%E9%85%8D%E7%BD%AE%E7%BB%84%E4%BB%B6SpringCloudConfig/</id>
    <published>2020-06-26T07:58:27.000Z</published>
    <updated>2020-06-30T07:42:03.591Z</updated>
    
    <content type="html"><![CDATA[<h1 id="集中配置组件SpringCloudConfig"><a href="#集中配置组件SpringCloudConfig" class="headerlink" title="集中配置组件SpringCloudConfig"></a>集中配置组件SpringCloudConfig</h1><h2 id="Spring-Cloud-Config简介"><a href="#Spring-Cloud-Config简介" class="headerlink" title="Spring Cloud Config简介"></a>Spring Cloud Config简介</h2><p>在分布式系统中，由于服务数量巨多，为了方便服务配置文件统一管理，实时更新，所 以需要分布式配置中心组件。在Spring Cloud中，有分布式配置中心组件spring cloud config ，它支持配置服务放在配置服务的内存中（即本地），也支持放在远程Git仓库 中。在spring cloud config 组件中，分两个角色，一是config server，二是config client。</p><h3 id="config-server"><a href="#config-server" class="headerlink" title="config server"></a>config server</h3><p>它用于集中管理应用程序各个 环境下的配置，默认使用Git存储配置文件内容</p><h4 id="导入config-server依赖"><a href="#导入config-server依赖" class="headerlink" title="导入config-server依赖"></a>导入config-server依赖</h4><figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-config-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h4 id="启动类添加-EnableConfigServer"><a href="#启动类添加-EnableConfigServer" class="headerlink" title="启动类添加@EnableConfigServer"></a>启动类添加@EnableConfigServer</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableConfigServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigApplication</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        SpringApplication.run(ConfigApplication<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h4><p>这里如果uri使用的是http，则会出现不能clone仓库内容的错误，因此要换成ssh，并添加private-key，该配置文件不需要上传至云端</p><figure class="highlight yaml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">12000</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">tensquare-config</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.152</span><span class="string">.**</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">server:</span></span><br><span class="line">        <span class="attr">git:</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">git@gitee.com:***/tensquare.git</span></span><br><span class="line">          <span class="attr">ignore-local-ssh-settings:</span> <span class="literal">true</span></span><br><span class="line">          <span class="attr">private-key:</span> <span class="string">|</span></span><br><span class="line">            <span class="string">-----BEGIN</span> <span class="string">RSA</span> <span class="string">PRIVATE</span> <span class="string">KEY-----</span></span><br><span class="line">            <span class="string">MIIEowIBAAKCAQEAxawgOKaig29oj/OqSVY9njJMnIYmedq4A7wvKEpg3Q/wYRl0</span></span><br><span class="line">            <span class="string">DO1QOl13ilyj20MyXUEUKON4dKWoBl+2/zhTtyI5cCDhcnISYAp9JSkYSzm8DTDp</span></span><br><span class="line">            <span class="string">E+1Zwmq2yYE68mr5/UaRbhOHBPGr1GwrTNuraqnOtNDjUXm25E4HiCmHoc395RpA</span></span><br><span class="line">            <span class="string">-----END</span> <span class="string">RSA</span> <span class="string">PRIVATE</span> <span class="string">KEY-----</span></span><br></pre></td></tr></tbody></table></figure><h3 id="config-client"><a href="#config-client" class="headerlink" title="config client"></a>config client</h3><p>Config Client是Config Server的客户端，用于操作存储在Config Server中的配置内容。 微服务在启动时会请求Config Server获取配置文件的内容，请求到后再启动容器。</p><h4 id="导入config-client依赖"><a href="#导入config-client依赖" class="headerlink" title="导入config client依赖"></a>导入config client依赖</h4><figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h4 id="上传配置文件application-yml至gitee"><a href="#上传配置文件application-yml至gitee" class="headerlink" title="上传配置文件application.yml至gitee"></a>上传配置文件application.yml至gitee</h4><p>文件命名规则： {application}-{profile}.yml或{application}-{profile}.properties</p><p>其中application为应用名称，profile指的开发环境（用于区分开发环境，测试环境、生产环境等）</p><h4 id="更换配置文件为bootstrap-yml"><a href="#更换配置文件为bootstrap-yml" class="headerlink" title="更换配置文件为bootstrap.yml"></a>更换配置文件为bootstrap.yml</h4><figure class="highlight yaml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">     <span class="comment">#这个对应gitee配置文件的命名规则</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">base</span></span><br><span class="line">      <span class="attr">profile:</span> <span class="string">dev</span></span><br><span class="line">      <span class="attr">label:</span> <span class="string">master</span></span><br><span class="line">      <span class="attr">uri:</span> <span class="string">http://127.0.0.1:12000</span></span><br></pre></td></tr></tbody></table></figure><h2 id="消息总线组件SpringCloudBus"><a href="#消息总线组件SpringCloudBus" class="headerlink" title="消息总线组件SpringCloudBus"></a>消息总线组件SpringCloudBus</h2><h3 id="SpringCloudBus简介"><a href="#SpringCloudBus简介" class="headerlink" title="SpringCloudBus简介"></a>SpringCloudBus简介</h3><p>当云端修改配置文件后，本地不用修改和再次编译，只需向消息中间件发送一条修改提醒即可使得配置文件即时生效</p><h3 id="配置服务端"><a href="#配置服务端" class="headerlink" title="配置服务端"></a>配置服务端</h3><h4 id="config-server导入SpringCloudBus和rabbitmq依赖"><a href="#config-server导入SpringCloudBus和rabbitmq依赖" class="headerlink" title="config-server导入SpringCloudBus和rabbitmq依赖"></a>config-server导入SpringCloudBus和rabbitmq依赖</h4><figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-bus<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-stream-binder-rabbit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h4 id="修改配置文件-1"><a href="#修改配置文件-1" class="headerlink" title="修改配置文件"></a>修改配置文件</h4><figure class="highlight yaml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">     <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.152</span><span class="number">.128</span></span><br><span class="line"><span class="comment">#暴露触发消息总线的地址，</span></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">bus-refresh</span></span><br></pre></td></tr></tbody></table></figure><h3 id="配置客户端"><a href="#配置客户端" class="headerlink" title="配置客户端"></a>配置客户端</h3><h4 id="功能子模块导入依赖"><a href="#功能子模块导入依赖" class="headerlink" title="功能子模块导入依赖"></a>功能子模块导入依赖</h4><figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-bus<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-stream-binder-rabbit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h4 id="云端配置文件添加rabbitmq地址"><a href="#云端配置文件添加rabbitmq地址" class="headerlink" title="云端配置文件添加rabbitmq地址"></a>云端配置文件添加rabbitmq地址</h4><figure class="highlight yaml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.184</span><span class="string">.</span></span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;集中配置组件SpringCloudConfig&quot;&gt;&lt;a href=&quot;#集中配置组件SpringCloudConfig&quot; class=&quot;headerlink&quot; title=&quot;集中配置组件SpringCloudConfig&quot;&gt;&lt;/a&gt;集中配置组件SpringCloud
      
    
    </summary>
    
    
      <category term="微服务" scheme="https://xulilei.github.io/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    
      <category term="SpringCloudConfig" scheme="https://xulilei.github.io/tags/SpringCloudConfig/"/>
    
  </entry>
  
  <entry>
    <title>微服务网关Zuul</title>
    <link href="https://xulilei.github.io/2020/06/26/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3Zuul/"/>
    <id>https://xulilei.github.io/2020/06/26/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3Zuul/</id>
    <published>2020-06-26T07:40:35.000Z</published>
    <updated>2020-06-30T07:37:35.388Z</updated>
    
    <content type="html"><![CDATA[<h2 id="微服务网关Zuul"><a href="#微服务网关Zuul" class="headerlink" title="微服务网关Zuul"></a>微服务网关Zuul</h2><h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><h4 id="为什么使用网关"><a href="#为什么使用网关" class="headerlink" title="为什么使用网关"></a>为什么使用网关</h4><p>不同的微服务一般有不同的网络地址，而外部的客户端可能需要调用多个服务的接口才 能完成一个业务需求。</p><p>如果客户端直接和微服务进行通信，会存在一下问题： </p><p>1、客户端会多次请求不同微服务，增加客户端的复杂性 </p><p>2、存在跨域请求，在一定场景下处理相对复杂 </p><p>3、认证复杂，每一个服务都需要独立认证</p><p>上述问题，都可以借助微服务网关解决。微服务网关是介于客户端和服务器端之间的中间层，所有的外部请求都会先经过微服务网关。</p><h4 id="什么是zuul"><a href="#什么是zuul" class="headerlink" title="什么是zuul"></a>什么是zuul</h4><p>Zuul是Netflix开源的微服务网关，他可以和Eureka,Ribbon,Hystrix等组件配合使用。</p><p>Zuul组件的核心是一系列的过滤器，这些过滤器可以完成以下功能：  </p><p>1、身份认证和安全: 识别每一个资源的验证要求，并拒绝那些不符的请求</p><p>2、动态路由：动态将请求路由到不同后端集群</p><h3 id="Zuul使用"><a href="#Zuul使用" class="headerlink" title="Zuul使用"></a>Zuul使用</h3><h4 id="网关模块导入相关依赖"><a href="#网关模块导入相关依赖" class="headerlink" title="网关模块导入相关依赖"></a>网关模块导入相关依赖</h4><p>zuul是依赖eureka实现的，通过微服务的name在eureka的服务器上寻找到对应的路径</p><figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-zuul<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h4 id="配置application-yml"><a href="#配置application-yml" class="headerlink" title="配置application,yml"></a>配置application,yml</h4><figure class="highlight yaml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">9011</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">tensquare-manager</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://127.0.0.1:6868/eureka/</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="string">prefer‐ip‐address:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">zuul:</span></span><br><span class="line">  <span class="attr">routes:</span></span><br><span class="line">    <span class="attr">tensquare-base:</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">/base/**</span></span><br><span class="line">      <span class="attr">serviceId:</span> <span class="string">tensquare-base</span></span><br><span class="line">    <span class="attr">tensquare-user:</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">/user/**</span></span><br><span class="line">      <span class="attr">serviceId:</span> <span class="string">tensquare-user</span></span><br><span class="line">    <span class="attr">tensquare-qa:</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">/qa/**</span></span><br><span class="line">      <span class="attr">serviceId:</span> <span class="string">tensquare-qa</span></span><br></pre></td></tr></tbody></table></figure><h4 id="修改启动类"><a href="#修改启动类" class="headerlink" title="修改启动类"></a>修改启动类</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="meta">@EnableZuulProxy</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ManagerApplication</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        SpringApplication.run(ManagerApplication<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JwtUtil <span class="title">jwtUtil</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JwtUtil();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="实例：通过ZuulFilter实现身份验证功能"><a href="#实例：通过ZuulFilter实现身份验证功能" class="headerlink" title="实例：通过ZuulFilter实现身份验证功能"></a>实例：通过ZuulFilter实现身份验证功能</h3><p>创建Filter类继承ZuulFilter，并实现其中的方法，具体细节请看注释</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ManagerFilter</span> <span class="keyword">extends</span> <span class="title">ZuulFilter</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JwtUtil jwtUtil;</span><br><span class="line">    <span class="comment">//过滤器类型</span></span><br><span class="line">    <span class="comment">//“pre”执行之前，“post”执行时</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">filterType</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"pre"</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//排序，0表示优先执行</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">filterOrder</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//表示当前过滤器是否开启，true为开启</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldFilter</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//过滤器内执行的操作，return任何object表示继续执行，</span></span><br><span class="line">    <span class="comment">//setSendZullResponse(false)表示不再继续执行</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> ZuulException </span>{</span><br><span class="line">        <span class="comment">//通过com.netflix.zuul得到request上下文</span></span><br><span class="line">        RequestContext currentContext =RequestContext.getCurrentContext();</span><br><span class="line">        <span class="comment">//得到request域</span></span><br><span class="line">        HttpServletRequest request = currentContext.getRequest();</span><br><span class="line">        <span class="comment">// 第一次转发始终放行，因为是根据配置文件中的路径去找其他服务</span></span><br><span class="line">         <span class="keyword">if</span>(request.getMethod().equals(<span class="string">"OPTIONS"</span>)){</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">         }</span><br><span class="line">         <span class="comment">//登陆放行</span></span><br><span class="line">        <span class="keyword">if</span>(request.getRequestURI().indexOf(<span class="string">"login"</span>)&gt;<span class="number">0</span>){</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">//得到头信息</span></span><br><span class="line">        String header = request.getHeader(<span class="string">"Authorization"</span>);</span><br><span class="line">        <span class="keyword">if</span>(header!=<span class="keyword">null</span>&amp;&amp;!<span class="string">""</span>.equals(header)){</span><br><span class="line">            <span class="keyword">if</span>(header.startsWith(<span class="string">"Bearer "</span>)){</span><br><span class="line">                String token=header.substring(<span class="number">7</span>);</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    Claims claims = jwtUtil.parseJWT(token);</span><br><span class="line">                    String role= (String) claims.get(<span class="string">"roles"</span>);</span><br><span class="line">                    <span class="keyword">if</span>(role.equals(<span class="string">"admin"</span>)){</span><br><span class="line">                        <span class="comment">//把头信息继续往下传</span></span><br><span class="line">                        currentContext.addZuulRequestHeader(<span class="string">"Authorization"</span>,header);</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                    }</span><br><span class="line">                }<span class="keyword">catch</span> (Exception e){</span><br><span class="line">                    <span class="comment">//终止运行</span></span><br><span class="line">                    currentContext.setSendZuulResponse(<span class="keyword">false</span>);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//header为空返回错误信息</span></span><br><span class="line">        currentContext.setSendZuulResponse(<span class="keyword">false</span>);</span><br><span class="line">        currentContext.setResponseStatusCode(<span class="number">403</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;微服务网关Zuul&quot;&gt;&lt;a href=&quot;#微服务网关Zuul&quot; class=&quot;headerlink&quot; title=&quot;微服务网关Zuul&quot;&gt;&lt;/a&gt;微服务网关Zuul&lt;/h2&gt;&lt;h3 id=&quot;相关概念&quot;&gt;&lt;a href=&quot;#相关概念&quot; class=&quot;headerli
      
    
    </summary>
    
    
      <category term="微服务" scheme="https://xulilei.github.io/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    
      <category term="zuul" scheme="https://xulilei.github.io/tags/zuul/"/>
    
  </entry>
  
  <entry>
    <title>Hystrix入门</title>
    <link href="https://xulilei.github.io/2020/06/25/Hystrix%E2%80%9C%E5%85%A5%E9%97%A8/"/>
    <id>https://xulilei.github.io/2020/06/25/Hystrix%E2%80%9C%E5%85%A5%E9%97%A8/</id>
    <published>2020-06-25T13:58:25.000Z</published>
    <updated>2020-06-30T07:20:00.603Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Hystrix熔断器"><a href="#Hystrix熔断器" class="headerlink" title="Hystrix熔断器"></a>Hystrix熔断器</h2><h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><h4 id="为什么要使用熔断器"><a href="#为什么要使用熔断器" class="headerlink" title="为什么要使用熔断器"></a>为什么要使用熔断器</h4><p>在微服务架构中通常会有多个服务层调用，基础服务的故障可能会导致级联故障， 进而造成整个系统不可用的情况，这种现象被称为服务雪崩效应。而熔断器的产生，则有效规避了雪崩效应</p><h4 id="熔断器工作机制"><a href="#熔断器工作机制" class="headerlink" title="熔断器工作机制"></a>熔断器工作机制</h4><p>当服务的某个API接口的失败次数在一定时间内小于设定的阈值时，熔断器处于关闭状态，该API接口正常提供服务。当该API接口处理请求的失败次数大于设定的阈值时，Hystrix判定该API接口出现了故障，打开熔断器，这时该API接口会执行快速失败的逻辑，不执行业务逻辑，请求的线程不会处于阻塞状态。处于打开状态的熔断器在一定时间后会处于半打开状态，并将一定数量的请求执行正常逻辑，剩余的请求会执行快速失败。若执行正常逻辑的请求失败了，则熔断器继续打开，若成功了，则熔断器关闭。这样熔断器就具有了自我修复的功能。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h4 id="配置文件开启hystrix支持"><a href="#配置文件开启hystrix支持" class="headerlink" title="配置文件开启hystrix支持"></a>配置文件开启hystrix支持</h4><p>Feign本身支持Hystrix，因此不需要导入额外依赖</p><figure class="highlight yml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line"> <span class="attr">hystrix:</span></span><br><span class="line">  <span class="attr">enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></tbody></table></figure><h4 id="创建实现feign接口的实现类"><a href="#创建实现feign接口的实现类" class="headerlink" title="创建实现feign接口的实现类"></a>创建实现feign接口的实现类</h4><p>在声明式接口中的@FeignClient注解上添加fallback属性来配置快速失败的处理类。该处理类作为Feign熔断器的逻辑处理类，必须实现被@FeignClient修饰的接口</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient</span>(value = <span class="string">"tensquare-base"</span>,fallback = BaseClientImpl<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">interface</span> <span class="title">BaseClient</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/label/{labelId}"</span>,method = RequestMethod.GET)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">findById</span><span class="params">(@PathVariable(<span class="string">"labelId"</span>)</span> String labelId)</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseClientImpl</span> <span class="keyword">implements</span> <span class="title">BaseClient</span> </span>{</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">findById</span><span class="params">(String labelId)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Result(<span class="keyword">false</span>, StatusCode.ERROR,<span class="string">"失败"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Hystrix熔断器&quot;&gt;&lt;a href=&quot;#Hystrix熔断器&quot; class=&quot;headerlink&quot; title=&quot;Hystrix熔断器&quot;&gt;&lt;/a&gt;Hystrix熔断器&lt;/h2&gt;&lt;h3 id=&quot;相关概念&quot;&gt;&lt;a href=&quot;#相关概念&quot; class=&quot;head
      
    
    </summary>
    
    
      <category term="微服务" scheme="https://xulilei.github.io/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    
      <category term="Hystrix" scheme="https://xulilei.github.io/tags/Hystrix/"/>
    
  </entry>
  
  <entry>
    <title>SpringCloud架构模型</title>
    <link href="https://xulilei.github.io/2020/06/25/cloud%E5%B8%B8%E8%A7%81%E6%A8%A1%E5%9D%97/"/>
    <id>https://xulilei.github.io/2020/06/25/cloud%E5%B8%B8%E8%A7%81%E6%A8%A1%E5%9D%97/</id>
    <published>2020-06-25T13:54:19.000Z</published>
    <updated>2020-06-30T07:51:46.207Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Spring-Cloud架构模型"><a href="#Spring-Cloud架构模型" class="headerlink" title="Spring Cloud架构模型"></a>Spring Cloud架构模型</h2><p><img src="https://gitee.com/xulilei/pic/raw/master/20190706180949381.png" alt=""></p><h3 id="服务发现组件Eureka"><a href="#服务发现组件Eureka" class="headerlink" title="服务发现组件Eureka"></a>服务发现组件Eureka</h3><p>Eureka是Netflix开发的服务发现框架，SpringCloud将它集成在自己的子项目spring-cloud-netflix中，实现SpringCloud的服务发现功能。Eureka包含两个组件：Eureka Server和Eureka Client。</p><p>Eureka Server提供服务注册服务，各个节点启动后，会在Eureka Server中进行注册，这样EurekaServer中的服务注册表中将会存储所有可用服务节点的信息，服务节点的信息可以在界面中直观的看到。</p><p>详见：<a href="https://xulilei.github.io/2020/06/21/eureka入门/">https://xulilei.github.io/2020/06/21/eureka%E5%85%A5%E9%97%A8/</a></p><h3 id="服务间调用Feign"><a href="#服务间调用Feign" class="headerlink" title="服务间调用Feign"></a>服务间调用Feign</h3><p>feign是声明式的web service客户端，它让微服务之间的调用变得更简单了，类似controller调用service。Spring Cloud集成了Ribbon和Eureka，可在使用Feign时提供负载均衡的http客户端</p><p>详见：<a href="https://xulilei.github.io/2020/06/21/eureka入门/">https://xulilei.github.io/2020/06/21/eureka%E5%85%A5%E9%97%A8/</a></p><h3 id="熔断器Hystrix"><a href="#熔断器Hystrix" class="headerlink" title="熔断器Hystrix"></a>熔断器Hystrix</h3><p>在微服务架构中通常会有多个服务层调用，基础服务的故障可能会导致级联故障， 进而造成整个系统不可用的情况，这种现象被称为服务雪崩效应。而熔断器的产生，则有效规避了雪崩效应</p><p>当服务的某个API接口的失败次数在一定时间内小于设定的阈值时，熔断器处于关闭状态，该API接口正常提供服务。当该API接口处理请求的失败次数大于设定的阈值时，Hystrix判定该API接口出现了故障，打开熔断器，这时该API接口会执行快速失败的逻辑，不执行业务逻辑，请求的线程不会处于阻塞状态。处于打开状态的熔断器在一定时间后会处于半打开状态，并将一定数量的请求执行正常逻辑，剩余的请求会执行快速失败。若执行正常逻辑的请求失败了，则熔断器继续打开，若成功了，则熔断器关闭。这样熔断器就具有了自我修复的功能。</p><p>详见：<a href="https://xulilei.github.io/2020/06/25/Hystrix" 入门="" "="">https://xulilei.github.io/2020/06/25/Hystrix%E2%80%9C%E5%85%A5%E9%97%A8/</a></p><h3 id="路由网关Zuul"><a href="#路由网关Zuul" class="headerlink" title="路由网关Zuul"></a>路由网关Zuul</h3><p>Zuul是Netflix开源的微服务网关，Zuul组件的核心是一系列的过滤器，这些过滤器可以完成以下功能：  </p><p>1、身份认证和安全: 识别每一个资源的验证要求，并拒绝那些不符的请求</p><p>2、动态路由：动态将请求路由到不同后端集群</p><p>详见：<a href="https://xulilei.github.io/2020/06/26/微服务网关Zuul/">https://xulilei.github.io/2020/06/26/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3Zuul/</a></p><h3 id="分布式配置中心SpringCloud-Config"><a href="#分布式配置中心SpringCloud-Config" class="headerlink" title="分布式配置中心SpringCloud Config"></a>分布式配置中心SpringCloud Config</h3><p>在分布式系统中，由于服务数量巨多，为了方便服务配置文件统一管理，实时更新，所 以需要分布式配置中心组件。在Spring Cloud中，有分布式配置中心组件spring cloud config ，它支持配置服务放在配置服务的内存中（即本地），也支持放在远程Git仓库 中。在spring cloud config 组件中，分两个角色，一是config server，二是config client。</p><p>详见：<a href="https://xulilei.github.io/2020/06/26/集中配置组件SpringCloudConfig/">https://xulilei.github.io/2020/06/26/%E9%9B%86%E4%B8%AD%E9%85%8D%E7%BD%AE%E7%BB%84%E4%BB%B6SpringCloudConfig/</a></p><h3 id="消息总线组件SpringCloud-Bus"><a href="#消息总线组件SpringCloud-Bus" class="headerlink" title="消息总线组件SpringCloud Bus"></a>消息总线组件SpringCloud Bus</h3><p>当云端修改配置文件后，本地不用修改和再次编译，只需向消息中间件发送一条修改提醒即可使得配置文件即时生效</p><p>详见：<a href="https://xulilei.github.io/2020/06/26/集中配置组件SpringCloudConfig/">https://xulilei.github.io/2020/06/26/%E9%9B%86%E4%B8%AD%E9%85%8D%E7%BD%AE%E7%BB%84%E4%BB%B6SpringCloudConfig/</a></p><h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><p>十次方项目首先启动tensquare_config模块，且只有该模块的配置文件存于本地</p><p>当项目启动后，启动注册中心tensquare_eureka模块，通过tensquare_config向远程仓库读取配置文件</p><p>接着启动网关服务tensquare_manager，作为项目管理员的入口，并在其中作鉴权等操作</p><p>接着启动其他业务模块，实现所有功能的启用，各业务模块间通过feign调用服务，通过Hystrix防止雪崩。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Spring-Cloud架构模型&quot;&gt;&lt;a href=&quot;#Spring-Cloud架构模型&quot; class=&quot;headerlink&quot; title=&quot;Spring Cloud架构模型&quot;&gt;&lt;/a&gt;Spring Cloud架构模型&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http
      
    
    </summary>
    
    
      <category term="微服务" scheme="https://xulilei.github.io/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    
      <category term="SpringCloud" scheme="https://xulilei.github.io/tags/SpringCloud/"/>
    
  </entry>
  
  <entry>
    <title>daySeven-eureka</title>
    <link href="https://xulilei.github.io/2020/06/21/%E5%8D%81%E6%AC%A1%E6%96%B9daySeven/"/>
    <id>https://xulilei.github.io/2020/06/21/%E5%8D%81%E6%AC%A1%E6%96%B9daySeven/</id>
    <published>2020-06-21T15:04:08.000Z</published>
    <updated>2020-06-22T03:17:06.633Z</updated>
    
    <content type="html"><![CDATA[<h2 id="交友服务搭建"><a href="#交友服务搭建" class="headerlink" title="交友服务搭建"></a>交友服务搭建</h2><h3 id="主要业务"><a href="#主要业务" class="headerlink" title="主要业务"></a>主要业务</h3><h4 id="添加喜欢"><a href="#添加喜欢" class="headerlink" title="添加喜欢"></a>添加喜欢</h4><h5 id="业务逻辑"><a href="#业务逻辑" class="headerlink" title="业务逻辑"></a>业务逻辑</h5><p>有两张表分别为tb_friend和tb_nofriend，当A添加喜欢B，先在tb_friend表中查询有无数据，如果有则代表已经添加喜欢了，回复不可重复添加，然后在tb_nofriend中查询是否之前A不喜欢B，如果有记录，则删除该记录。并在tb_friend中添加一条从A-B的记录，且状态为0，代表单向喜欢。如果在添加记录时，恰哈发现B-A已经有数据了，那么则将二者的状态都改为1，代表双向喜欢</p><h5 id="业务实现，service层"><a href="#业务实现，service层" class="headerlink" title="业务实现，service层"></a>业务实现，service层</h5><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">addFriend</span><span class="params">(String userid, String friendid)</span> </span>{</span><br><span class="line">    <span class="comment">//先判断userid到friendid是否有数据，有就是重复添加好友，返回0</span></span><br><span class="line">    Friend friend=friendDao.findByUseridAndFriendid(userid,friendid);</span><br><span class="line">    <span class="keyword">if</span>(friend!=<span class="keyword">null</span>){</span><br><span class="line">        <span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//再判断以前是否不喜欢</span></span><br><span class="line">    <span class="keyword">if</span>(noFriendDao.findByUseridAndFriendid(userid, friendid)!=<span class="keyword">null</span>){</span><br><span class="line">        noFriendDao.deleteByUseridAndFriendid(userid,friendid);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//直接添加好友，让好友表中的userid到friendid方向的type为0</span></span><br><span class="line">    friend=<span class="keyword">new</span> Friend();</span><br><span class="line">    friend.setUserid(userid);</span><br><span class="line">    friend.setFriendid(friendid);</span><br><span class="line">    friend.setIslike(<span class="string">"0"</span>);</span><br><span class="line">    friendDao.save(friend);</span><br><span class="line">    <span class="comment">//再判断friendid到userid是否有数据，如果有则把双方的状态都改为1</span></span><br><span class="line">    <span class="keyword">if</span>(friendDao.findByUseridAndFriendid(friendid,userid)!=<span class="keyword">null</span>){</span><br><span class="line">        <span class="comment">//把双方islike都改为1</span></span><br><span class="line">        friendDao.updateIslike(<span class="string">"1"</span>,userid,friendid);</span><br><span class="line">        friendDao.updateIslike(<span class="string">"1"</span>,friendid,userid);</span><br><span class="line">    };</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="添加不喜欢"><a href="#添加不喜欢" class="headerlink" title="添加不喜欢"></a>添加不喜欢</h4><h5 id="业务逻辑-1"><a href="#业务逻辑-1" class="headerlink" title="业务逻辑"></a>业务逻辑</h5><p>当A添加B为不喜欢，首先查询tb_nofriend中是否已经有数据，如果有则提示不可重复拉黑。然后再去tb_friend中查询是否有A-B的喜欢，如果有则删除该记录，同时查询B-A是否也有记录，有则代表之前是双向喜欢，此时应将B-A的状态改为0，最后在tb_nofriend中添加一行A-B数据。</p><h5 id="业务实现，service层-1"><a href="#业务实现，service层-1" class="headerlink" title="业务实现，service层"></a>业务实现，service层</h5><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">addNoFriend</span><span class="params">(String userid,String friendid)</span> </span>{</span><br><span class="line">    <span class="comment">//先判断是否已经是非好友</span></span><br><span class="line">    NoFriend noFriend=noFriendDao.findByUseridAndFriendid(userid, friendid);</span><br><span class="line">    <span class="keyword">if</span>(noFriend!=<span class="keyword">null</span>){</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//如果之前是好友，现在单方面删除</span></span><br><span class="line">    <span class="keyword">if</span>(friendDao.findByUseridAndFriendid(userid,friendid)!=<span class="keyword">null</span>){</span><br><span class="line">        friendDao.deleteByUseridAndFriendid(userid,friendid);</span><br><span class="line">       <span class="comment">//如果之前双向喜欢，则改为单向喜欢</span></span><br><span class="line">        <span class="keyword">if</span>(friendDao.findByUseridAndFriendid(friendid,userid)!=<span class="keyword">null</span>)</span><br><span class="line">        friendDao.updateIslike(<span class="string">"0"</span>,friendid,userid);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//删完再添加到noFriend表</span></span><br><span class="line">    noFriend=<span class="keyword">new</span> NoFriend();</span><br><span class="line">    noFriend.setUserid(userid);</span><br><span class="line">    noFriend.setFriendid(friendid);</span><br><span class="line">    noFriendDao.save(noFriend);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="上述功能用到的Dao层"><a href="#上述功能用到的Dao层" class="headerlink" title="上述功能用到的Dao层"></a>上述功能用到的Dao层</h4><h5 id="FriendDao"><a href="#FriendDao" class="headerlink" title="FriendDao"></a>FriendDao</h5><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FriendDao</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">Friend</span>,<span class="title">String</span>&gt; </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Friend <span class="title">findByUseridAndFriendid</span><span class="params">(String userid,String friendid)</span></span>;</span><br><span class="line">    <span class="meta">@Modifying</span></span><br><span class="line">    <span class="meta">@Query</span>(value =<span class="string">"update tb_friend SET islike=? where userid=? and friendid=?"</span>,nativeQuery = <span class="keyword">true</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateIslike</span><span class="params">(String islike,String userid,String friendid)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteByUseridAndFriendid</span><span class="params">(String userid,String friendid)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="NoFriendDao"><a href="#NoFriendDao" class="headerlink" title="NoFriendDao"></a>NoFriendDao</h5><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">NoFriendDao</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">NoFriend</span>,<span class="title">String</span>&gt; </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> NoFriend <span class="title">findByUseridAndFriendid</span><span class="params">(String userid, String friendid)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteByUseridAndFriendid</span><span class="params">(String userid,String friendid)</span></span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="feign调用user模块业务"><a href="#feign调用user模块业务" class="headerlink" title="feign调用user模块业务"></a>feign调用user模块业务</h4><h5 id="业务逻辑-2"><a href="#业务逻辑-2" class="headerlink" title="业务逻辑"></a>业务逻辑</h5><p>当A添加B为喜欢时，在tb_user表中，userA的关注数+1，B的粉丝数+1。当A添加B为不喜欢时，userA的关注数-1，B的粉丝数-1。</p><h5 id="User模块中粉丝关注业务实现"><a href="#User模块中粉丝关注业务实现" class="headerlink" title="User模块中粉丝关注业务实现"></a>User模块中粉丝关注业务实现</h5><h6 id="Dao层"><a href="#Dao层" class="headerlink" title="Dao层"></a>Dao层</h6><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">User</span>,<span class="title">String</span>&gt;,<span class="title">JpaSpecificationExecutor</span>&lt;<span class="title">User</span>&gt;</span>{</span><br><span class="line">    <span class="meta">@Modifying</span></span><br><span class="line">    <span class="meta">@Query</span>(value =<span class="string">"update tb_user set fanscout=fanscount+? where  id=?"</span> ,nativeQuery = <span class="keyword">true</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateFans</span><span class="params">(<span class="keyword">int</span> x, String friendid)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Modifying</span></span><br><span class="line">    <span class="meta">@Query</span>(value =<span class="string">"update tb_user set followcount=followcount+? where  id=?"</span> ,nativeQuery = <span class="keyword">true</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateFollows</span><span class="params">(<span class="keyword">int</span> x, String userid)</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h6 id="Service层"><a href="#Service层" class="headerlink" title="Service层"></a>Service层</h6><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateFansAndFollowCounts</span><span class="params">(<span class="keyword">int</span> x, String userid, String friendid)</span> </span>{</span><br><span class="line">     <span class="comment">//friendB粉丝数+1，userA的关注数+1</span></span><br><span class="line">     userDao.updateFans(x,friendid);</span><br><span class="line">     userDao.updateFollows(x,userid);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h6 id="Controller层"><a href="#Controller层" class="headerlink" title="Controller层"></a>Controller层</h6><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//不返回result是因为这个业务是服务之间的调用，不涉及前台</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/{userid}/{friendid}/x"</span>,method = RequestMethod.PUT)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateFansAndFollowCounts</span><span class="params">(@PathVariable <span class="keyword">int</span> x,@PathVariable String userid,@PathVariable String friendid)</span></span>{</span><br><span class="line">   userService.updateFansAndFollowCounts(x,userid,friendid);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="交友模块中调用上述业务"><a href="#交友模块中调用上述业务" class="headerlink" title="交友模块中调用上述业务"></a>交友模块中调用上述业务</h5><h6 id="启动类添加相应注解"><a href="#启动类添加相应注解" class="headerlink" title="启动类添加相应注解"></a>启动类添加相应注解</h6><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FriendApplication</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        SpringApplication.run(FriendApplication<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h6 id="创建client"><a href="#创建client" class="headerlink" title="创建client"></a>创建client</h6><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient</span>(<span class="string">"tensquare-user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserClient</span> </span>{</span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/user/{userid}/{friendid}/x"</span>,method = RequestMethod.PUT)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> updateFansAndFollowCounts</span><br><span class="line">        (<span class="meta">@PathVariable</span>(<span class="string">"x"</span>) <span class="keyword">int</span> x, <span class="meta">@PathVariable</span>(<span class="string">"userid"</span>) String userid, <span class="meta">@PathVariable</span>(<span class="string">"friendid"</span>) String friendid);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h6 id="controller层调用"><a href="#controller层调用" class="headerlink" title="controller层调用"></a>controller层调用</h6><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//添加喜欢</span></span><br><span class="line"><span class="keyword">if</span>(flag==<span class="number">1</span>){</span><br><span class="line">    userClient.updateFansAndFollowCounts(<span class="number">1</span>,userid,friendid);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Result(<span class="keyword">true</span>, StatusCode.OK,<span class="string">"添加成功"</span>);</span><br><span class="line">}</span><br><span class="line"><span class="comment">//添加不喜欢</span></span><br><span class="line"><span class="keyword">if</span>(flag==<span class="number">1</span>){</span><br><span class="line">    userClient.updateFansAndFollowCounts(-<span class="number">1</span>,userid,friendid);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Result(<span class="keyword">true</span>, StatusCode.OK,<span class="string">"添加成功"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="交友服务controller层整合"><a href="#交友服务controller层整合" class="headerlink" title="交友服务controller层整合"></a>交友服务controller层整合</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/like/{friendid}/{type}"</span>,method = RequestMethod.PUT )</span><br><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">addFriend</span><span class="params">(@PathVariable String friendid,@PathVariable String type)</span></span>{</span><br><span class="line">    <span class="comment">//验证是否登陆，并拿到ID</span></span><br><span class="line">    Claims claims = (Claims) request.getAttribute(<span class="string">"user_claims"</span>);</span><br><span class="line">    <span class="keyword">if</span>(claims==<span class="keyword">null</span>){</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Result(<span class="keyword">false</span>, StatusCode.LOGINERROR,<span class="string">"权限不足"</span>);</span><br><span class="line">    }</span><br><span class="line">    String userid = claims.getId();</span><br><span class="line">    System.out.println(userid);</span><br><span class="line">    <span class="comment">//判断是添加好友还是非好友，直接传进来一个类型type，当type为1时，表示添加，2时表示拉黑</span></span><br><span class="line">    <span class="keyword">if</span>(type!=<span class="keyword">null</span>){</span><br><span class="line">        <span class="keyword">if</span>(type.equals(<span class="string">"1"</span>)){</span><br><span class="line">            <span class="keyword">int</span> flag=friendService.addFriend(userid,friendid);</span><br><span class="line">            <span class="keyword">if</span>(flag==<span class="number">0</span>){</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Result(<span class="keyword">false</span>, StatusCode.ERROR,<span class="string">"不能重复添加好友"</span>);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(flag==<span class="number">1</span>){</span><br><span class="line">                <span class="comment">//后文介绍的添加粉丝与关注</span></span><br><span class="line">                userClient.updateFansAndFollowCounts(<span class="number">1</span>,userid,friendid);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Result(<span class="keyword">true</span>, StatusCode.OK,<span class="string">"添加成功"</span>);</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">//添加好友</span></span><br><span class="line">        }<span class="keyword">else</span> <span class="keyword">if</span>(type.equals(<span class="string">"2"</span>)) {</span><br><span class="line">            <span class="comment">//添加黑名单</span></span><br><span class="line">            <span class="keyword">int</span> flag= friendService.addNoFriend(userid,friendid);</span><br><span class="line">            <span class="keyword">if</span>(flag==<span class="number">0</span>){</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Result(<span class="keyword">false</span>, StatusCode.ERROR,<span class="string">"不能重复拉黑好友"</span>);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(flag==<span class="number">1</span>){</span><br><span class="line">                <span class="comment">//后文介绍的减少粉丝与关注</span></span><br><span class="line">                userClient.updateFansAndFollowCounts(-<span class="number">1</span>,userid,friendid);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Result(<span class="keyword">true</span>, StatusCode.OK,<span class="string">"添加成功"</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Result(<span class="keyword">false</span>, StatusCode.ERROR,<span class="string">"参数异常"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;交友服务搭建&quot;&gt;&lt;a href=&quot;#交友服务搭建&quot; class=&quot;headerlink&quot; title=&quot;交友服务搭建&quot;&gt;&lt;/a&gt;交友服务搭建&lt;/h2&gt;&lt;h3 id=&quot;主要业务&quot;&gt;&lt;a href=&quot;#主要业务&quot; class=&quot;headerlink&quot; title=&quot;主
      
    
    </summary>
    
    
      <category term="十次方项目" scheme="https://xulilei.github.io/categories/%E5%8D%81%E6%AC%A1%E6%96%B9%E9%A1%B9%E7%9B%AE/"/>
    
    
      <category term="项目" scheme="https://xulilei.github.io/tags/%E9%A1%B9%E7%9B%AE/"/>
    
      <category term="Eureka" scheme="https://xulilei.github.io/tags/Eureka/"/>
    
      <category term="交友业务" scheme="https://xulilei.github.io/tags/%E4%BA%A4%E5%8F%8B%E4%B8%9A%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>eureka入门</title>
    <link href="https://xulilei.github.io/2020/06/21/eureka%E5%85%A5%E9%97%A8/"/>
    <id>https://xulilei.github.io/2020/06/21/eureka%E5%85%A5%E9%97%A8/</id>
    <published>2020-06-21T07:50:02.000Z</published>
    <updated>2020-06-30T06:48:21.907Z</updated>
    
    <content type="html"><![CDATA[<h2 id="服务发现组件Eureka"><a href="#服务发现组件Eureka" class="headerlink" title="服务发现组件Eureka"></a>服务发现组件Eureka</h2><h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><h4 id="Eureka简介"><a href="#Eureka简介" class="headerlink" title="Eureka简介"></a>Eureka简介</h4><p>Eureka是Netflix开发的服务发现框架，SpringCloud将它集成在自己的子项目spring-cloud-netflix中，实现SpringCloud的服务发现功能。Eureka包含两个组件：Eureka Server和Eureka Client。</p><p><img src="https://gitee.com/xulilei/pic/raw/master/20200622110425.png" alt=""></p><h5 id="Eureka-Server"><a href="#Eureka-Server" class="headerlink" title="Eureka Server"></a>Eureka Server</h5><p>Eureka Server提供服务注册服务，各个节点启动后，会在Eureka Server中进行注册，这样EurekaServer中的服务注册表中将会存储所有可用服务节点的信息，服务节点的信息可以在界面中直观的看到。</p><h6 id="服务端开发"><a href="#服务端开发" class="headerlink" title="服务端开发"></a>服务端开发</h6><p>第一步，在父工程中锁定版本，每一个版本的springboot都对应一个版本的springcloud</p><figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>Finchley.M9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>第二步，Eureka子模块添加eureka-server</p><figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>第三步，添加application.yml</p><figure class="highlight yaml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">6868</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">false</span> <span class="comment">#是否将自己注册到Eureka服务中，本身就是所有无需注册</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">false</span> </span><br><span class="line">    <span class="attr">service-url:</span> <span class="comment">#Eureka客户端与Eureka服务端进行交互的地址</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://127.0.0.1:${server.port}/eureka/</span></span><br></pre></td></tr></tbody></table></figure><p>第四步，启动类</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaServer</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        SpringApplication.run(EurekaServer<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="Eureka-Client"><a href="#Eureka-Client" class="headerlink" title="Eureka Client"></a>Eureka Client</h5><p>Eureka Client是一个java客户端，用于简化与Eureka Server的交互，客户端同时也 就别一个内置的、使用轮询(round-robin)负载算法的负载均衡器。</p><h6 id="客户端开发"><a href="#客户端开发" class="headerlink" title="客户端开发"></a>客户端开发</h6><p>第一步，客户端模块添加eureka-client</p><figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>第二步，修改每个微服务的application.yml，添加注册eureka服务的配置</p><figure class="highlight yaml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://127.0.0.1:6868/eureka/</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="string">prefer‐ip‐address:</span> <span class="literal">true</span>  <span class="comment">#跨域</span></span><br></pre></td></tr></tbody></table></figure><p>第三步，启动类</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserApplication</span> </span>{</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">      SpringApplication.run(UserApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">   }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="Feign实现服务间的调用"><a href="#Feign实现服务间的调用" class="headerlink" title="Feign实现服务间的调用"></a>Feign实现服务间的调用</h4><h5 id="谁调用别人就在谁的模块中搭建环境"><a href="#谁调用别人就在谁的模块中搭建环境" class="headerlink" title="谁调用别人就在谁的模块中搭建环境"></a>谁调用别人就在谁的模块中搭建环境</h5><h6 id="第一步，添加openfeign依赖"><a href="#第一步，添加openfeign依赖" class="headerlink" title="第一步，添加openfeign依赖"></a>第一步，添加openfeign依赖</h6><figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h6 id="第二步，启动类"><a href="#第二步，启动类" class="headerlink" title="第二步，启动类"></a>第二步，启动类</h6><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span><span class="comment">//Eureka客户端</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span><span class="comment">//可以发现服务</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span><span class="comment">//通过feign调用其他服务的业务</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QaApplication</span> </span>{</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">      SpringApplication.run(QaApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h6 id="第三步，创建client包，创建要调用目标的接口"><a href="#第三步，创建client包，创建要调用目标的接口" class="headerlink" title="第三步，创建client包，创建要调用目标的接口"></a>第三步，创建client包，创建要调用目标的接口</h6><p>默认采用的是ribbon的轮询负载均衡算法</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//调用目标的名字，注意这里不能使用下划线，这也是其他模块的application.yml中名字不加下划线的原因</span></span><br><span class="line"><span class="meta">@FeignClient</span>(<span class="string">"tensquare-base"</span>)</span><br><span class="line"><span class="comment">//调用目标controller层的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BaseClient</span> </span>{</span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/label/{labelId}"</span>,method = RequestMethod.GET)</span><br><span class="line">    <span class="comment">//这里的 @PathVariable 后面要加上具体的参数名称("labelId")不然会找不到</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">findById</span><span class="params">(@PathVariable(<span class="string">"labelId"</span>)</span> String labelId)</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="相关实践"><a href="#相关实践" class="headerlink" title="相关实践"></a>相关实践</h3><p>详见：<a href="https://xulilei.github.io/2020/06/21/十次方daySeven/">https://xulilei.github.io/2020/06/21/%E5%8D%81%E6%AC%A1%E6%96%B9daySeven/</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;服务发现组件Eureka&quot;&gt;&lt;a href=&quot;#服务发现组件Eureka&quot; class=&quot;headerlink&quot; title=&quot;服务发现组件Eureka&quot;&gt;&lt;/a&gt;服务发现组件Eureka&lt;/h2&gt;&lt;h3 id=&quot;相关概念&quot;&gt;&lt;a href=&quot;#相关概念&quot; cla
      
    
    </summary>
    
    
      <category term="微服务" scheme="https://xulilei.github.io/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    
      <category term="eureka" scheme="https://xulilei.github.io/tags/eureka/"/>
    
  </entry>
  
  <entry>
    <title>daySix-JWT-BCryptPasswordEncoder</title>
    <link href="https://xulilei.github.io/2020/06/18/%E5%8D%81%E6%AC%A1%E6%96%B9daySix/"/>
    <id>https://xulilei.github.io/2020/06/18/%E5%8D%81%E6%AC%A1%E6%96%B9daySix/</id>
    <published>2020-06-18T02:27:02.000Z</published>
    <updated>2020-06-18T07:53:03.717Z</updated>
    
    <content type="html"><![CDATA[<h2 id="管理员登陆验证与删除鉴权"><a href="#管理员登陆验证与删除鉴权" class="headerlink" title="管理员登陆验证与删除鉴权"></a>管理员登陆验证与删除鉴权</h2><blockquote><p>利用Spring Security的BCryptPasswordEncoder与JWT实现</p></blockquote><h3 id="登陆验证签发token"><a href="#登陆验证签发token" class="headerlink" title="登陆验证签发token"></a>登陆验证签发token</h3><h4 id="service层"><a href="#service层" class="headerlink" title="service层"></a>service层</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Admin <span class="title">login</span><span class="params">(Admin admin)</span> </span>{</span><br><span class="line">       <span class="comment">//想根据用户名查询对象</span></span><br><span class="line">       Admin adminLogin=adminDao.findByLoginname(admin.getLoginname());</span><br><span class="line">       <span class="comment">//然后拿数据库中的密码和用户输入的密码匹配是否相同</span></span><br><span class="line">       <span class="keyword">if</span>(adminLogin!=<span class="keyword">null</span>&amp;&amp;encoder.matches(admin.getPassword(),adminLogin.getPassword())){</span><br><span class="line">           <span class="keyword">return</span> adminLogin;</span><br><span class="line">   }</span><br><span class="line">       <span class="comment">//登陆失败</span></span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="controller层"><a href="#controller层" class="headerlink" title="controller层"></a>controller层</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/login"</span>,method = RequestMethod.POST)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">login</span><span class="params">(@RequestBody Admin admin)</span></span>{</span><br><span class="line">   Admin adminLoginResult=adminService.login(admin);</span><br><span class="line">   <span class="keyword">if</span>(adminLoginResult==<span class="keyword">null</span>){</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Result(<span class="keyword">false</span>,StatusCode.LOGINERROR,<span class="string">"登陆失败"</span>);</span><br><span class="line">   }</span><br><span class="line">   <span class="comment">//做一系列前后端通话的工作，用JWT来实现</span></span><br><span class="line">   <span class="comment">//生成token并返回给客户端</span></span><br><span class="line">   String token=jwtUtil.createJWT(adminLoginResult.getId(),adminLoginResult.getLoginname(),<span class="string">"admin"</span>);</span><br><span class="line">   Map&lt;String,Object&gt;map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">   map.put(<span class="string">"token"</span>,token);</span><br><span class="line">   map.put(<span class="string">"role"</span>,<span class="string">"admin"</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> Result(<span class="keyword">true</span>,StatusCode.OK,<span class="string">"登陆成功"</span>,map);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="返回给前端的token"><a href="#返回给前端的token" class="headerlink" title="返回给前端的token"></a>返回给前端的token</h5><p><img src="https://gitee.com/xulilei/pic/raw/master/20200617161241.png" alt=""></p><h3 id="利用拦截器解析token"><a href="#利用拦截器解析token" class="headerlink" title="利用拦截器解析token"></a>利用拦截器解析token</h3><h4 id="拦截器只是为了将请求头中的token解析成user和admin"><a href="#拦截器只是为了将请求头中的token解析成user和admin" class="headerlink" title="拦截器只是为了将请求头中的token解析成user和admin"></a>拦截器只是为了将请求头中的token解析成user和admin</h4><p>解析后将气保存在域对象中，等需要鉴权时，直接通过获取这个域对象的值来分别是user还是admin</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JwtInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>{</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JwtUtil jwtUtil;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        <span class="comment">//无论如何都放行，具体能不能操作要在具体的操作中去判断</span></span><br><span class="line">        <span class="comment">//拦截器只是负责把请求头中包含的token令牌解析成user和admin</span></span><br><span class="line">        String header=request.getHeader(<span class="string">"Authorization"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(header!=<span class="keyword">null</span>&amp;&amp;header.startsWith(<span class="string">"Bearer "</span>)){</span><br><span class="line">            String token=header.substring(<span class="number">7</span>);</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                Claims claims = jwtUtil.parseJWT(token);</span><br><span class="line">                <span class="keyword">if</span>(claims!=<span class="keyword">null</span>){</span><br><span class="line">                    <span class="keyword">if</span>(<span class="string">"admin"</span>.equals(claims.get(<span class="string">"roles"</span>))){</span><br><span class="line">                       request.setAttribute(<span class="string">"admin_claims"</span>,token);</span><br><span class="line">                    }</span><br><span class="line">                    <span class="keyword">if</span>(<span class="string">"user"</span>.equals(claims.get(<span class="string">"roles"</span>))){</span><br><span class="line">                        request.setAttribute(<span class="string">"user_claims"</span>,token);</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }<span class="keyword">catch</span> (Exception e){</span><br><span class="line">                <span class="comment">//过期</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"token错误"</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="注册拦截器"><a href="#注册拦截器" class="headerlink" title="注册拦截器"></a>注册拦截器</h4><p>当然不用拦截登陆请求了</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterceptorConfig</span> <span class="keyword">extends</span> <span class="title">WebMvcConfigurationSupport</span> </span>{</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JwtInterceptor jwtInterceptor;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="comment">//注册拦截器要声明的拦截器对象和要拦截的请求</span></span><br><span class="line">        registry.addInterceptor(jwtInterceptor)</span><br><span class="line">                .addPathPatterns(<span class="string">"/**"</span>)</span><br><span class="line">                .excludePathPatterns(<span class="string">"/**/login"</span>);</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="管理员删除用户"><a href="#管理员删除用户" class="headerlink" title="管理员删除用户"></a>管理员删除用户</h3><h5 id="直接从域对象中获取admin-claims，如果有则说明该登陆用户为管理员，则可以删除用户，否则提示权限不足"><a href="#直接从域对象中获取admin-claims，如果有则说明该登陆用户为管理员，则可以删除用户，否则提示权限不足" class="headerlink" title="直接从域对象中获取admin_claims，如果有则说明该登陆用户为管理员，则可以删除用户，否则提示权限不足"></a>直接从域对象中获取admin_claims，如果有则说明该登陆用户为管理员，则可以删除用户，否则提示权限不足</h5><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> HttpServletRequest request;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteById</span><span class="params">(String id)</span> </span>{</span><br><span class="line">   String token = (String) request.getAttribute(<span class="string">"admin_claims"</span>);</span><br><span class="line">   <span class="keyword">if</span>(token==<span class="keyword">null</span>||<span class="string">""</span>.equals(token)){</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"权限不足"</span>);</span><br><span class="line">   }</span><br><span class="line">   userDao.deleteById(id);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="当header中的token无法解析时"><a href="#当header中的token无法解析时" class="headerlink" title="当header中的token无法解析时"></a>当header中的token无法解析时</h5><p><img src="https://gitee.com/xulilei/pic/raw/master/20200617164250.png" alt=""></p><h5 id="当header中的token正确时"><a href="#当header中的token正确时" class="headerlink" title="当header中的token正确时"></a>当header中的token正确时</h5><p><img src="https://gitee.com/xulilei/pic/raw/master/20200617164223.png" alt=""></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;管理员登陆验证与删除鉴权&quot;&gt;&lt;a href=&quot;#管理员登陆验证与删除鉴权&quot; class=&quot;headerlink&quot; title=&quot;管理员登陆验证与删除鉴权&quot;&gt;&lt;/a&gt;管理员登陆验证与删除鉴权&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;利用Spring Security
      
    
    </summary>
    
    
      <category term="十次方项目" scheme="https://xulilei.github.io/categories/%E5%8D%81%E6%AC%A1%E6%96%B9%E9%A1%B9%E7%9B%AE/"/>
    
    
      <category term="项目" scheme="https://xulilei.github.io/tags/%E9%A1%B9%E7%9B%AE/"/>
    
      <category term="Spring Security" scheme="https://xulilei.github.io/tags/Spring-Security/"/>
    
      <category term="BCryptPasswordEncoder" scheme="https://xulilei.github.io/tags/BCryptPasswordEncoder/"/>
    
      <category term="JWT" scheme="https://xulilei.github.io/tags/JWT/"/>
    
      <category term="鉴权" scheme="https://xulilei.github.io/tags/%E9%89%B4%E6%9D%83/"/>
    
      <category term="密码加密" scheme="https://xulilei.github.io/tags/%E5%AF%86%E7%A0%81%E5%8A%A0%E5%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>Spring Security加密与JWT鉴权</title>
    <link href="https://xulilei.github.io/2020/06/18/SpringSecurity%E5%8A%A0%E5%AF%86%C2%80%E4%B8%8EJWT%E9%89%B4%E6%9D%83/"/>
    <id>https://xulilei.github.io/2020/06/18/SpringSecurity%E5%8A%A0%E5%AF%86%C2%80%E4%B8%8EJWT%E9%89%B4%E6%9D%83/</id>
    <published>2020-06-18T02:26:39.000Z</published>
    <updated>2020-06-22T03:24:47.259Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SpringSecurity加密与JWT鉴权"><a href="#SpringSecurity加密与JWT鉴权" class="headerlink" title="SpringSecurity加密与JWT鉴权"></a>SpringSecurity加密与JWT鉴权</h2><h3 id="Spring-Security的BCryptPasswordEncoder"><a href="#Spring-Security的BCryptPasswordEncoder" class="headerlink" title="Spring Security的BCryptPasswordEncoder"></a>Spring Security的BCryptPasswordEncoder</h3><h4 id="使用过程"><a href="#使用过程" class="headerlink" title="使用过程"></a>使用过程</h4><h5 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h5><figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h5 id="添加配置类"><a href="#添加配置类" class="headerlink" title="添加配置类"></a>添加配置类</h5><p>如果只是使用BCryptPasswordEncoder，这个配置可以直接拿来用</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span></span>{</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        <span class="comment">//authorizeRequests是所有security全注解配置实现的开端</span></span><br><span class="line">        <span class="comment">//需要的权限分两部分，第一部分是拦截的路径，第二部分是访问该路径需要的权限</span></span><br><span class="line">        <span class="comment">//antMatchers，表示拦截的路径，permitAll表示任何权限都可以访问，直接放行所有</span></span><br><span class="line">        <span class="comment">//这里主要是用security的加密功能，拦截功能用的是jwt</span></span><br><span class="line">        <span class="comment">//anyRequest()任何的请求，authenticated()认证后访问</span></span><br><span class="line">        <span class="comment">//and().csrf().disable()表示使csrf攻击失效</span></span><br><span class="line">        http</span><br><span class="line">                .authorizeRequests()</span><br><span class="line">                .antMatchers(<span class="string">"/**"</span>).permitAll()</span><br><span class="line">                .anyRequest().authenticated()</span><br><span class="line">                .and().csrf().disable();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="配置BCryptPasswordEncoder交给容器"><a href="#配置BCryptPasswordEncoder交给容器" class="headerlink" title="配置BCryptPasswordEncoder交给容器"></a>配置BCryptPasswordEncoder交给容器</h5><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BCryptPasswordEncoder <span class="title">bCryptPasswordEncoder</span><span class="params">()</span></span>{</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> BCryptPasswordEncoder();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="密码加密"><a href="#密码加密" class="headerlink" title="密码加密"></a>密码加密</h5><p>service层</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(User user)</span> </span>{</span><br><span class="line">   user.setId( idWorker.nextId()+<span class="string">""</span> );</span><br><span class="line">   <span class="comment">//密码加密</span></span><br><span class="line">   user.setPassword(encoder.encode(user.getPassword()));</span><br><span class="line"></span><br><span class="line">   userDao.save(user);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="密码验证"><a href="#密码验证" class="headerlink" title="密码验证"></a>密码验证</h5><p>service层</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">login</span><span class="params">(String mobile,String password)</span> </span>{</span><br><span class="line">    <span class="comment">//先通过前台传过来的电话查询出user</span></span><br><span class="line">   User user=userDao.findByMobile(mobile);</span><br><span class="line">    <span class="comment">//再比对user的密码，用encoder.match(原密码,加密后的密码)</span></span><br><span class="line">   <span class="keyword">if</span>(user!=<span class="keyword">null</span>&amp;&amp;encoder.matches(password,user.getPassword())){</span><br><span class="line">      <span class="keyword">return</span> user;</span><br><span class="line">   }</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="JWT鉴权"><a href="#JWT鉴权" class="headerlink" title="JWT鉴权"></a>JWT鉴权</h3><h4 id="常见的鉴权方式"><a href="#常见的鉴权方式" class="headerlink" title="常见的鉴权方式"></a>常见的鉴权方式</h4><h5 id="Cookie认证"><a href="#Cookie认证" class="headerlink" title="Cookie认证"></a>Cookie认证</h5><p>Cookie认证机制就是为一次请求认证在服务端创建一个Session对象，同时在客户端 的浏览器端创建了一个Cookie对象；通过客户端带上来Cookie对象来与服务器端的 session对象匹配来实现状态管理的。</p><h5 id="Token认证"><a href="#Token认证" class="headerlink" title="Token认证"></a>Token认证</h5><p>使用基于 Token 的身份验证方法，在服务端不需要存储用户的登录记录。大概的流程是 这样的： </p><ol><li>客户端使用用户名跟密码请求登录 </li><li>服务端收到请求，去验证用户名与密码 </li><li>验证成功后，服务端会签发一个 Token，再把这个 Token 发送给客户端 </li><li>客户端收到 Token 以后可以把它存储起来，比如放在 Cookie 里 </li><li>客户端每次向服务端请求资源的时候需要带着服务端签发的 Token </li><li>服务端收到请求，然后去验证客户端请求里面带着的 Token，如果验证成功，就向 客户端返回请求的数据</li></ol><h5 id="两者对比Token的优势"><a href="#两者对比Token的优势" class="headerlink" title="两者对比Token的优势"></a>两者对比Token的优势</h5><ol><li>支持跨域访问: Cookie是不允许垮域访问的，这一点对Token机制是不存在的，前提 是传输的用户认证信息通过HTTP头传输.</li><li>无状态:Token机制在服务端不需要存储session信息，因为 Token 自身包含了所有登录用户的信息，只需要在客户端的cookie或本地介质存储状态信息.</li><li>去耦: 不需要绑定到一个特定的身份验证方案。Token可以在任何地方生成，只要在 你的API被调用的时候，你可以进行Token生成调用即可.</li><li>一次网络往返时间（通过数据库查询session信息）总比做一次HMACSHA256计算的Token验证和解析要费时得多.</li><li>基于标准化:你的API可以采用标准化的 JSON Web Token (JWT)</li></ol><h4 id="JWT介绍"><a href="#JWT介绍" class="headerlink" title="JWT介绍"></a>JWT介绍</h4><p>一个JWT实际上就是一个字符串，它由三部分组成，头部、载荷与签名，且生成后都会采用base64进行编码。</p><h5 id="头部（Header）"><a href="#头部（Header）" class="headerlink" title="头部（Header）"></a>头部（Header）</h5><p>头部用于描述关于该JWT的最基本的信息，例如其类型以及签名所用的算法等。这也可以 被表示成一个JSON对象，如下指明了采用了JWT的算法为HS256</p><figure class="highlight json"><table><tbody><tr><td class="code"><pre><span class="line">{<span class="attr">"typ"</span>:<span class="string">"JWT"</span>,<span class="attr">"alg"</span>:<span class="string">"HS256"</span>}</span><br></pre></td></tr></tbody></table></figure><p>base64编码后：eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9</p><h5 id="载荷（playload）"><a href="#载荷（playload）" class="headerlink" title="载荷（playload）"></a>载荷（playload）</h5><p>一般包含ID，用户SUB，身份roles，比如</p><figure class="highlight json"><table><tbody><tr><td class="code"><pre><span class="line">{<span class="attr">"id"</span>:<span class="string">"1234567890"</span>,<span class="attr">"sub"</span>:<span class="string">"John Doe"</span>,<span class="attr">"roles"</span>:<span class="string">"admin"</span>}</span><br></pre></td></tr></tbody></table></figure><p>会再次进行base64编码</p><h5 id="签证（signature）"><a href="#签证（signature）" class="headerlink" title="签证（signature）"></a>签证（signature）</h5><p>包含头部，载荷，以及定义的salt，同样进行base编码</p><h5 id="最终JWT"><a href="#最终JWT" class="headerlink" title="最终JWT"></a>最终JWT</h5><p>会将三部分连接成一个字符串，以.连接</p><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6I kpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ</span><br></pre></td></tr></tbody></table></figure><h4 id="JJWT：Java-JWT"><a href="#JJWT：Java-JWT" class="headerlink" title="JJWT：Java JWT"></a>JJWT：Java JWT</h4><h5 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h5><figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.jsonwebtoken<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jjwt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.6.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h5 id="在common包下的util包中创建JWT工具类"><a href="#在common包下的util包中创建JWT工具类" class="headerlink" title="在common包下的util包中创建JWT工具类"></a>在common包下的util包中创建JWT工具类</h5><p>这个工具类，需要提供ID,SUB,ROLE作为claims</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties</span>(<span class="string">"jwt.config"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JwtUtil</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String key ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> ttl ;<span class="comment">//一个小时</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getKey</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setKey</span><span class="params">(String key)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getTtl</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> ttl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTtl</span><span class="params">(<span class="keyword">long</span> ttl)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.ttl = ttl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成JWT</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> subject</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">createJWT</span><span class="params">(String id, String subject, String roles)</span> </span>{</span><br><span class="line">        <span class="keyword">long</span> nowMillis = System.currentTimeMillis();</span><br><span class="line">        Date now = <span class="keyword">new</span> Date(nowMillis);</span><br><span class="line">        JwtBuilder builder = Jwts.builder().setId(id)</span><br><span class="line">                .setSubject(subject)</span><br><span class="line">                .setIssuedAt(now)</span><br><span class="line">                .signWith(SignatureAlgorithm.HS256, key).claim(<span class="string">"roles"</span>, roles);</span><br><span class="line">        <span class="keyword">if</span> (ttl &gt; <span class="number">0</span>) {</span><br><span class="line">            builder.setExpiration( <span class="keyword">new</span> Date( nowMillis + ttl));</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> builder.compact();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解析JWT</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jwtStr</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Claims <span class="title">parseJWT</span><span class="params">(String jwtStr)</span></span>{</span><br><span class="line">        <span class="keyword">return</span>  Jwts.parser()</span><br><span class="line">                .setSigningKey(key)</span><br><span class="line">                .parseClaimsJws(jwtStr)</span><br><span class="line">                .getBody();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>jwt.config哪里用到了这个工具类，哪里的application.yml添加jwt定义，哪里传入jwtUtil</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> JwtUtil <span class="title">jwtUtil</span><span class="params">()</span></span>{ </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> util.JwtUtil(); </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight yaml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">jwt:</span> </span><br><span class="line">  <span class="attr">config:</span> </span><br><span class="line">    <span class="attr">key:</span> <span class="string">itcast</span></span><br><span class="line">    <span class="attr">ttl:</span> <span class="number">360000</span></span><br></pre></td></tr></tbody></table></figure><h4 id="以admin的登陆与删除鉴权为例"><a href="#以admin的登陆与删除鉴权为例" class="headerlink" title="以admin的登陆与删除鉴权为例"></a>以admin的登陆与删除鉴权为例</h4><p>详见：<a href="https://xulilei.github.io/2020/06/18/十次方daySix/">https://xulilei.github.io/2020/06/18/%E5%8D%81%E6%AC%A1%E6%96%B9daySix/</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;SpringSecurity加密与JWT鉴权&quot;&gt;&lt;a href=&quot;#SpringSecurity加密与JWT鉴权&quot; class=&quot;headerlink&quot; title=&quot;SpringSecurity加密与JWT鉴权&quot;&gt;&lt;/a&gt;SpringSecurity加密与JWT
      
    
    </summary>
    
    
      <category term="微服务" scheme="https://xulilei.github.io/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    
      <category term="Spring Security" scheme="https://xulilei.github.io/tags/Spring-Security/"/>
    
      <category term="BCryptPasswordEncoder" scheme="https://xulilei.github.io/tags/BCryptPasswordEncoder/"/>
    
      <category term="JWT" scheme="https://xulilei.github.io/tags/JWT/"/>
    
      <category term="鉴权" scheme="https://xulilei.github.io/tags/%E9%89%B4%E6%9D%83/"/>
    
      <category term="密码加密" scheme="https://xulilei.github.io/tags/%E5%AF%86%E7%A0%81%E5%8A%A0%E5%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>dayFive-rabbitmq</title>
    <link href="https://xulilei.github.io/2020/06/15/%E5%8D%81%E6%AC%A1%E6%96%B9dayFive/"/>
    <id>https://xulilei.github.io/2020/06/15/%E5%8D%81%E6%AC%A1%E6%96%B9dayFive/</id>
    <published>2020-06-15T10:53:31.000Z</published>
    <updated>2020-06-18T07:50:33.673Z</updated>
    
    <content type="html"><![CDATA[<h3 id="用户注册模块搭建"><a href="#用户注册模块搭建" class="headerlink" title="用户注册模块搭建"></a>用户注册模块搭建</h3><h4 id="在user模块添加发送短信业务"><a href="#在user模块添加发送短信业务" class="headerlink" title="在user模块添加发送短信业务"></a>在user模块添加发送短信业务</h4><h5 id="service层"><a href="#service层" class="headerlink" title="service层"></a>service层</h5><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMsg</span><span class="params">(String mobile)</span> </span>{</span><br><span class="line">   <span class="comment">//生成六位随机数</span></span><br><span class="line">   String checkCode = RandomStringUtils.randomNumeric(<span class="number">6</span>);</span><br><span class="line">   <span class="comment">//向缓存中放一份</span></span><br><span class="line">       redisTemplate.opsForValue().set(<span class="string">"checkCode"</span>+mobile,checkCode,<span class="number">6</span>, TimeUnit.HOURS);</span><br><span class="line">   <span class="comment">//给用户发一份，先存放至rabbitmq中</span></span><br><span class="line">   Map&lt;String,String&gt;map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">   map.put(<span class="string">"mobile"</span>,mobile);</span><br><span class="line">   map.put(<span class="string">"checkCode"</span>,checkCode);</span><br><span class="line">   rabbitTemplate.convertAndSend(<span class="string">"sms"</span>,map);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="controller层"><a href="#controller层" class="headerlink" title="controller层"></a>controller层</h5><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value =<span class="string">"/sendsms/{mobile}"</span>,method = RequestMethod.POST)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">sendMsg</span><span class="params">(@PathVariable String mobile)</span></span>{</span><br><span class="line">   userService.sendMsg(mobile);</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> Result(<span class="keyword">true</span>,StatusCode.OK,<span class="string">"发送成功"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="在rabbitmq短信监听模块通过阿里云实施发送短信"><a href="#在rabbitmq短信监听模块通过阿里云实施发送短信" class="headerlink" title="在rabbitmq短信监听模块通过阿里云实施发送短信"></a>在rabbitmq短信监听模块通过阿里云实施发送短信</h4><h5 id="导入阿里云依赖"><a href="#导入阿里云依赖" class="headerlink" title="导入阿里云依赖"></a>导入阿里云依赖</h5><figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.aliyun<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aliyun-java-sdk-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.5.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h5 id="根据阿里云官网API创建工具类"><a href="#根据阿里云官网API创建工具类" class="headerlink" title="根据阿里云官网API创建工具类"></a>根据阿里云官网API创建工具类</h5><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmsUtil</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String accessKeyId=<span class="string">"LTAI4GCjWSbTHQzGTaavF**"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String accessKeySecret=<span class="string">"sDiW0PSXaAKXfNfwCI8vaG4spE4**"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String signName=<span class="string">"******"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String templateCode=<span class="string">"SMS_1932477**"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendSms</span><span class="params">(String mobile,String checkCode)</span> </span>{</span><br><span class="line">        DefaultProfile profile = DefaultProfile.getProfile(<span class="string">"default"</span>, accessKeyId, accessKeySecret);</span><br><span class="line">        IAcsClient client = <span class="keyword">new</span> DefaultAcsClient(profile);</span><br><span class="line"></span><br><span class="line">        CommonRequest request = <span class="keyword">new</span> CommonRequest();</span><br><span class="line">        request.setSysMethod(MethodType.POST);</span><br><span class="line">        request.setSysDomain(<span class="string">"dysmsapi.aliyuncs.com"</span>);</span><br><span class="line">        request.setSysVersion(<span class="string">"2017-05-25"</span>);</span><br><span class="line">        request.setSysAction(<span class="string">"SendSms"</span>);</span><br><span class="line">        request.putQueryParameter(<span class="string">"PhoneNumbers"</span>, mobile);</span><br><span class="line">        request.putQueryParameter(<span class="string">"SignName"</span>, signName);</span><br><span class="line">        request.putQueryParameter(<span class="string">"TemplateCode"</span>, templateCode);</span><br><span class="line">        <span class="comment">//这里使用通配符，code要与在阿里云注册的模版相同</span></span><br><span class="line">        request.putQueryParameter(<span class="string">"TemplateParam"</span>, <span class="string">"{\"code\":"</span>+checkCode+<span class="string">"}"</span>);</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            CommonResponse response = client.getCommonResponse(request);</span><br><span class="line">            System.out.println(response.getData());</span><br><span class="line">        } <span class="keyword">catch</span> (ServerException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        } <span class="keyword">catch</span> (ClientException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="创建rabbitmq监听器类"><a href="#创建rabbitmq监听器类" class="headerlink" title="创建rabbitmq监听器类"></a>创建rabbitmq监听器类</h5><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RabbitListener</span>(queues = <span class="string">"sms"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmsListener</span> </span>{</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SmsUtil smsUtil;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">executeSms</span><span class="params">(Map&lt;String,String&gt; map)</span></span>{</span><br><span class="line">        String mobile = map.get(<span class="string">"mobile"</span>);</span><br><span class="line">        String checkCode = map.get(<span class="string">"checkCode"</span>);</span><br><span class="line">        smsUtil.sendSms(mobile,checkCode);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>自此短信功能部署成功</p><h4 id="用户注册业务"><a href="#用户注册业务" class="headerlink" title="用户注册业务"></a>用户注册业务</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value =<span class="string">"/register/{code}"</span>,method = RequestMethod.POST)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">register</span><span class="params">(@PathVariable String code,@RequestBody User user)</span></span>{</span><br><span class="line">    <span class="comment">//先从缓存中拿到先前发送短信时存放的数据</span></span><br><span class="line">   String checkCodeRedis= (String) redisTemplate.opsForValue().get(<span class="string">"checkCode"</span>+user.getMobile());</span><br><span class="line">    <span class="comment">//比对数据</span></span><br><span class="line">   <span class="keyword">if</span>(checkCodeRedis.isEmpty()){</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Result(<span class="keyword">false</span>,StatusCode.ERROR,<span class="string">"未发送验证码"</span>);</span><br><span class="line">   }</span><br><span class="line">   <span class="keyword">if</span>(!checkCodeRedis.equals(code)){</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Result(<span class="keyword">false</span>,StatusCode.ERROR,<span class="string">"验证码错误"</span>);</span><br><span class="line">   }</span><br><span class="line">    <span class="comment">//比对成功，注册用户</span></span><br><span class="line">   userService.add(user);</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> Result(<span class="keyword">true</span>,StatusCode.OK,<span class="string">"注册成功"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;用户注册模块搭建&quot;&gt;&lt;a href=&quot;#用户注册模块搭建&quot; class=&quot;headerlink&quot; title=&quot;用户注册模块搭建&quot;&gt;&lt;/a&gt;用户注册模块搭建&lt;/h3&gt;&lt;h4 id=&quot;在user模块添加发送短信业务&quot;&gt;&lt;a href=&quot;#在user模块添加发送短信业
      
    
    </summary>
    
    
      <category term="十次方项目" scheme="https://xulilei.github.io/categories/%E5%8D%81%E6%AC%A1%E6%96%B9%E9%A1%B9%E7%9B%AE/"/>
    
    
      <category term="项目" scheme="https://xulilei.github.io/tags/%E9%A1%B9%E7%9B%AE/"/>
    
      <category term="rabbitmq" scheme="https://xulilei.github.io/tags/rabbitmq/"/>
    
      <category term="短信验证" scheme="https://xulilei.github.io/tags/%E7%9F%AD%E4%BF%A1%E9%AA%8C%E8%AF%81/"/>
    
      <category term="用户注册" scheme="https://xulilei.github.io/tags/%E7%94%A8%E6%88%B7%E6%B3%A8%E5%86%8C/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ入门</title>
    <link href="https://xulilei.github.io/2020/06/15/RabbitMQ/"/>
    <id>https://xulilei.github.io/2020/06/15/RabbitMQ/</id>
    <published>2020-06-15T10:53:09.000Z</published>
    <updated>2020-06-17T02:33:31.467Z</updated>
    
    <content type="html"><![CDATA[<h3 id="消息中间件RabbitMQ"><a href="#消息中间件RabbitMQ" class="headerlink" title="消息中间件RabbitMQ"></a>消息中间件RabbitMQ</h3><h4 id="RabbitMQ简介"><a href="#RabbitMQ简介" class="headerlink" title="RabbitMQ简介"></a>RabbitMQ简介</h4><p>消息队列中间件是分布式系统中重要的组件，主要解决应用耦合，异步消息，流量削锋和消息通讯等问题，实现高性能，高可用，可伸缩和最终一致性的架构</p><h5 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h5><p>通过交换机再进入到队列中</p><p><img src="https://gitee.com/xulilei/pic/raw/master/20200616105202.png" alt=""></p><h5 id="主要概念"><a href="#主要概念" class="headerlink" title="主要概念"></a>主要概念</h5><h6 id="RabbitMQ-Server"><a href="#RabbitMQ-Server" class="headerlink" title="RabbitMQ Server"></a>RabbitMQ Server</h6><p>也叫broker server，它是一种传输服务。 他的角色就是维护一条 从Producer到Consumer的路线，保证数据能够按照指定的方式进行传输。</p><h6 id="Producer"><a href="#Producer" class="headerlink" title="Producer"></a>Producer</h6><p>消息生产者，如图A、B、C，数据的发送方。消息生产者连接RabbitMQ服 务器然后将消息投递到Exchange。 </p><h6 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h6><p>消息消费者，如图1、2、3，数据的接收方。消息消费者订阅队列， RabbitMQ将Queue中的消息发送到消息消费者。 </p><h6 id="Exchange"><a href="#Exchange" class="headerlink" title="Exchange"></a>Exchange</h6><p>生产者将消息发送到Exchange（交换器），由Exchange将消息路由到一个 或多个Queue中（或者丢弃）。Exchange并不存储消息。RabbitMQ中的Exchange有 direct、fanout、topic、headers四种类型，每种类型对应不同的路由规则。 </p><h6 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h6><p>队列是RabbitMQ的内部对象，用于存储消息。消息消费者就是通过订阅 队列来获取消息的，RabbitMQ中的消息都只能存储在Queue中，生产者生产消息并最终 投递到Queue中，消费者可以从Queue中获取消息并消费。多个消费者可以订阅同一个 Queue，这时Queue中的消息会被平均分摊给多个消费者进行处理，而不是每个消费者 都收到所有的消息并处理。 </p><h6 id="RoutingKey"><a href="#RoutingKey" class="headerlink" title="RoutingKey"></a>RoutingKey</h6><p>生产者在将消息发送给Exchange的时候，一般会指定一个routing key， 来指定这个消息的路由规则，而这个routing key需要与Exchange Type及binding key联 合使用才能最终生效。在Exchange Type与binding key固定的情况下（在正常使用时一 般这些内容都是固定配置好的），我们的生产者就可以在发送消息给Exchange时，通过 指定routing key来决定消息流向哪里。</p><h5 id="Docker安装"><a href="#Docker安装" class="headerlink" title="Docker安装"></a>Docker安装</h5><p>需要注意的是要配置多个接口</p><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">docker run ‐di ‐‐name=tensquare_rabbitmq ‐p 5671:5617 ‐p 5672:5672 ‐p 4369:4369 ‐p 15671:15671 ‐p 15672:15672 ‐p 25672:25672 rabbitmq:management</span><br></pre></td></tr></tbody></table></figure><h4 id="主要知识点"><a href="#主要知识点" class="headerlink" title="主要知识点"></a>主要知识点</h4><h5 id="Exchange类型"><a href="#Exchange类型" class="headerlink" title="Exchange类型"></a>Exchange类型</h5><h6 id="direct模式"><a href="#direct模式" class="headerlink" title="direct模式"></a>direct模式</h6><p><img src="https://gitee.com/xulilei/pic/raw/master/20200616111243.png" alt=""></p><p>1、将消息发给唯一一个节点时使用这种模式，这是最简单的一种形式</p><p>2、这种模式下不需要将Exchange进行任何绑定(binding)操作 </p><p>3、消息传递时需要一个“RouteKey”，可以简单的理解为要发送到的队列名字</p><p>首先创建一个test队列</p><p><img src="https://gitee.com/xulilei/pic/raw/master/20200616104252.png" alt=""></p><p>以direct模式发送</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">SpringBootTest</span>(<span class="title">classes</span> </span>= RabApplication<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">ProductTest</span> </span>{</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMsg</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="comment">//这里的test就是queue的名字</span></span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">"test"</span>,<span class="string">"测试直接模式"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>创建消费者接受</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RabbitListener</span>(queues = <span class="string">"test"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getMsg</span><span class="params">(String msg)</span></span>{</span><br><span class="line">        System.out.println(<span class="string">"直接模式消费消息"</span>+msg);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>运行结果</p><p><img src="https://gitee.com/xulilei/pic/raw/master/20200616104614.png" alt=""></p><p>该模式下，默认采用了负载均衡，即消费者从队列获取消息是均衡的</p><h6 id="分列模式"><a href="#分列模式" class="headerlink" title="分列模式"></a>分列模式</h6><p><img src="https://gitee.com/xulilei/pic/raw/master/20200616111559.png" alt=""></p><p>任何发送到Fanout Exchange的消息都会被转发到与该Exchange绑定(Binding)的所有 Queue上。 </p><p>1、这种模式不需要RouteKey </p><p>2、这种模式需要提前将Exchange与Queue进行绑定，一个Exchange可以绑定多个 Queue，一个Queue可以同多个Exchange进行绑定。 </p><p>3、如果接受到消息的Exchange没有与任何Queue绑定，则消息会被抛弃。+</p><h6 id="主题模式"><a href="#主题模式" class="headerlink" title="主题模式"></a>主题模式</h6><p><img src="https://gitee.com/xulilei/pic/raw/master/20200616152738.png" alt=""></p><p>任何发送到Topic Exchange的消息都会被转发到所有关心RouteKey中指定话题的 Queue上</p><p>1、这种模式较为复杂，简单来说，就是每个队列都有其关心的主题，所有的消息都带有一 个“标题”(RouteKey)，Exchange会将消息转发到所有关注主题能与RouteKey模糊匹配的 队列。 </p><p>2、这种模式需要RouteKey，也许要提前绑定Exchange与Queue。</p><p>3、在进行绑定时，要提供一个该队列关心的主题，如“#.log.#”表示该队列关心所有涉及 log的消息(一个RouteKey为”MQ.log.error”的消息会被转发到该队列)。</p><p>4、“#”表示0个或若干个关键字，“”表示一个关键字。如“log.”能与“log.warn”匹配，无法 与“log.warn.timeout”匹配；但是“log.#”能与上述两者匹配。 </p><p>5、同样，如果Exchange没有发现能够与RouteKey匹配的Queue，则会抛弃此消息</p><h4 id="配合阿里云实现发送短信功能"><a href="#配合阿里云实现发送短信功能" class="headerlink" title="配合阿里云实现发送短信功能"></a>配合阿里云实现发送短信功能</h4><p>详见</p><p><a href="https://xulilei.github.io/2020/06/15/十次方dayFive/">https://xulilei.github.io/2020/06/15/%E5%8D%81%E6%AC%A1%E6%96%B9dayFive/</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;消息中间件RabbitMQ&quot;&gt;&lt;a href=&quot;#消息中间件RabbitMQ&quot; class=&quot;headerlink&quot; title=&quot;消息中间件RabbitMQ&quot;&gt;&lt;/a&gt;消息中间件RabbitMQ&lt;/h3&gt;&lt;h4 id=&quot;RabbitMQ简介&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
    
      <category term="微服务" scheme="https://xulilei.github.io/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    
      <category term="rabbitmq" scheme="https://xulilei.github.io/tags/rabbitmq/"/>
    
      <category term="短信验证" scheme="https://xulilei.github.io/tags/%E7%9F%AD%E4%BF%A1%E9%AA%8C%E8%AF%81/"/>
    
  </entry>
  
  <entry>
    <title>DayFour-elasticsearch</title>
    <link href="https://xulilei.github.io/2020/06/14/%E5%8D%81%E6%AC%A1%E6%96%B9DayFour/"/>
    <id>https://xulilei.github.io/2020/06/14/%E5%8D%81%E6%AC%A1%E6%96%B9DayFour/</id>
    <published>2020-06-14T10:34:44.000Z</published>
    <updated>2020-06-22T03:48:25.175Z</updated>
    
    <content type="html"><![CDATA[<h3 id="搜索微服务搭建"><a href="#搜索微服务搭建" class="headerlink" title="搜索微服务搭建"></a>搜索微服务搭建</h3><h4 id="使用spring-data-elasticsearch操作"><a href="#使用spring-data-elasticsearch操作" class="headerlink" title="使用spring-data-elasticsearch操作"></a>使用spring-data-elasticsearch操作</h4><h5 id="导入依赖"><a href="#导入依赖" class="headerlink" title="导入依赖"></a>导入依赖</h5><figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.data<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-data-elasticsearch<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h5 id="Pojo实体类"><a href="#Pojo实体类" class="headerlink" title="Pojo实体类"></a>Pojo实体类</h5><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Document</span>(indexName = <span class="string">"articleindex"</span>,type = <span class="string">"article"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Article</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>{</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="comment">//是否能被搜索到</span></span><br><span class="line">    <span class="comment">//是否分词，整体匹配还是分词匹配</span></span><br><span class="line">    <span class="comment">//是否在页面上显示，即数据库中在该实体类中的字段，就是要显示的,比如该例中的id title content state</span></span><br><span class="line">    <span class="comment">//analyzer,分词</span></span><br><span class="line">    <span class="comment">//searchAnalyzer，搜索</span></span><br><span class="line">    <span class="meta">@Field</span>(index = <span class="keyword">true</span>,analyzer=<span class="string">"ik_max_word"</span>,searchAnalyzer=<span class="string">"ik_max_word"</span>)</span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line">    <span class="meta">@Field</span>(index = <span class="keyword">true</span>,analyzer=<span class="string">"ik_max_word"</span>,searchAnalyzer=<span class="string">"ik_max_word"</span>)</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">private</span> String content;</span><br><span class="line">    <span class="keyword">private</span> String state;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="Dao层"><a href="#Dao层" class="headerlink" title="Dao层"></a>Dao层</h5><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ArticleDao</span> <span class="keyword">extends</span> <span class="title">ElasticsearchRepository</span>&lt;<span class="title">Article</span>,<span class="title">String</span>&gt; </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Page&lt;Article&gt; <span class="title">findByTitleOrContentLike</span><span class="params">(String title, String content, Pageable pageable)</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="Service层"><a href="#Service层" class="headerlink" title="Service层"></a>Service层</h5><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArticleService</span> </span>{</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ArticleDao articleDao;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IdWorker idWorker;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(Article article)</span></span>{</span><br><span class="line">        articleDao.save(article);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//springdata系列分页的写法都是这个</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Page&lt;Article&gt; <span class="title">findByKey</span><span class="params">(String key, <span class="keyword">int</span> page, <span class="keyword">int</span> size)</span> </span>{</span><br><span class="line">        Pageable pageable= PageRequest.of(page-<span class="number">1</span>,size);</span><br><span class="line">        <span class="keyword">return</span>  articleDao.findByTitleOrContentLike(key,key,pageable);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="controller层"><a href="#controller层" class="headerlink" title="controller层"></a>controller层</h5><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/article"</span>)</span><br><span class="line"><span class="meta">@CrossOrigin</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArticleController</span> </span>{</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ArticleService articleService;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(method = RequestMethod.POST)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">save</span><span class="params">(@RequestBody Article article)</span></span>{</span><br><span class="line">        articleService.save(article);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Result(<span class="keyword">true</span>, StatusCode.OK,<span class="string">"存储成功"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/{key}/{page}/{size}"</span>,method = RequestMethod.GET)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">findByKey</span><span class="params">(@PathVariable String key,@PathVariable <span class="keyword">int</span> page,@PathVariable <span class="keyword">int</span> size)</span></span>{</span><br><span class="line">        Page&lt;Article&gt;pageData=articleService.findByKey(key,page,size);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Result(<span class="keyword">true</span>,StatusCode.OK,<span class="string">"搜索成功"</span>,<span class="keyword">new</span> PageResult&lt;Article&gt;(pageData.getTotalElements(),pageData.getContent()));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="docker部署elasticsearch"><a href="#docker部署elasticsearch" class="headerlink" title="docker部署elasticsearch"></a>docker部署elasticsearch</h4><p><a href="https://xulilei.github.io/2020/06/12/elasticSearch入门/">https://xulilei.github.io/2020/06/12/elasticSearch%E5%85%A5%E9%97%A8/</a></p><h4 id="连接服务器，并测试存储到服务器的索引库"><a href="#连接服务器，并测试存储到服务器的索引库" class="headerlink" title="连接服务器，并测试存储到服务器的索引库"></a>连接服务器，并测试存储到服务器的索引库</h4><h5 id="application-yml配置"><a href="#application-yml配置" class="headerlink" title="application.yml配置"></a>application.yml配置</h5><figure class="highlight yaml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">9007</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">tensquare-search</span></span><br><span class="line">  <span class="attr">data:</span></span><br><span class="line">    <span class="attr">elasticsearch:</span></span><br><span class="line">      <span class="attr">cluster-nodes:</span> <span class="number">192.168</span><span class="number">.152</span><span class="number">.128</span><span class="string">:9300</span></span><br></pre></td></tr></tbody></table></figure><p>postMan测试成功</p><p><img src="https://gitee.com/xulilei/pic/raw/master/20200615165805.png" alt=""></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;搜索微服务搭建&quot;&gt;&lt;a href=&quot;#搜索微服务搭建&quot; class=&quot;headerlink&quot; title=&quot;搜索微服务搭建&quot;&gt;&lt;/a&gt;搜索微服务搭建&lt;/h3&gt;&lt;h4 id=&quot;使用spring-data-elasticsearch操作&quot;&gt;&lt;a href=&quot;#使用sp
      
    
    </summary>
    
    
      <category term="十次方项目" scheme="https://xulilei.github.io/categories/%E5%8D%81%E6%AC%A1%E6%96%B9%E9%A1%B9%E7%9B%AE/"/>
    
    
      <category term="项目" scheme="https://xulilei.github.io/tags/%E9%A1%B9%E7%9B%AE/"/>
    
      <category term="elasticsearch" scheme="https://xulilei.github.io/tags/elasticsearch/"/>
    
      <category term="搜索功能" scheme="https://xulilei.github.io/tags/%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>ElasticSearch从认识到发布</title>
    <link href="https://xulilei.github.io/2020/06/12/elasticSearch%E5%85%A5%E9%97%A8/"/>
    <id>https://xulilei.github.io/2020/06/12/elasticSearch%E5%85%A5%E9%97%A8/</id>
    <published>2020-06-12T07:54:05.000Z</published>
    <updated>2020-06-15T08:52:37.340Z</updated>
    
    <content type="html"><![CDATA[<h3 id="分布式搜索引擎ElasticSearch"><a href="#分布式搜索引擎ElasticSearch" class="headerlink" title="分布式搜索引擎ElasticSearch"></a>分布式搜索引擎ElasticSearch</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><h5 id="与mysql数据库对比"><a href="#与mysql数据库对比" class="headerlink" title="与mysql数据库对比"></a>与mysql数据库对比</h5><table><thead><tr><th align="center">Elasticsearch</th><th align="center">关系型数据库Mysql</th></tr></thead><tbody><tr><td align="center">索引(index)</td><td align="center">数据库(databases)</td></tr><tr><td align="center">类型(type)</td><td align="center">表(table)</td></tr><tr><td align="center">文档(document)</td><td align="center">行(row)</td></tr></tbody></table><h4 id="restful风格操作ElasticSearch"><a href="#restful风格操作ElasticSearch" class="headerlink" title="restful风格操作ElasticSearch"></a>restful风格操作ElasticSearch</h4><h5 id="新建索引"><a href="#新建索引" class="headerlink" title="新建索引"></a>新建索引</h5><p>如果需要创建一个叫articleindex的索引 ,就以put方式提交 </p><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">http://127.0.0.1:9200/articleindex/</span><br></pre></td></tr></tbody></table></figure><h5 id="新建文档"><a href="#新建文档" class="headerlink" title="新建文档"></a>新建文档</h5><p>新建类型，在索引后追加类型： 以post方式提交 </p><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">http://127.0.0.1:9200/articleindex/article</span><br></pre></td></tr></tbody></table></figure><h5 id="查询文档"><a href="#查询文档" class="headerlink" title="查询文档"></a>查询文档</h5><h6 id="查询全部"><a href="#查询全部" class="headerlink" title="查询全部"></a>查询全部</h6><p>_search，以get方式请求</p><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">http://127.0.0.1:9200/articleindex/article/_search</span><br></pre></td></tr></tbody></table></figure><h6 id="按ID查询"><a href="#按ID查询" class="headerlink" title="按ID查询"></a>按ID查询</h6><p>以GET方式请求 </p><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">http://127.0.0.1:9200/articleindex/article/1</span><br></pre></td></tr></tbody></table></figure><h6 id="匹配查询"><a href="#匹配查询" class="headerlink" title="匹配查询"></a>匹配查询</h6><p>根据title=aa进行查询，get方式提交下列地址：</p><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">http://127.0.0.1:9200/articleindex/article/_search?q=title:aa</span><br></pre></td></tr></tbody></table></figure><h6 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h6><p>以*用代表任意字符： </p><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">http://192.168.184.134:9200/articleindex/article/_search?q=title:*s*</span><br></pre></td></tr></tbody></table></figure><h5 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h5><p>以put形式提交以下地址,如果ID存在则修改，否则添加</p><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">http://127.0.0.1:9200/articleindex/article/1</span><br></pre></td></tr></tbody></table></figure><h5 id="删除文档"><a href="#删除文档" class="headerlink" title="删除文档"></a>删除文档</h5><p>根据ID删除文档,删除ID为1的文档 DELETE方式提交 </p><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">http://192.168.184.134:9200/articleindex/article/1</span><br></pre></td></tr></tbody></table></figure><h4 id="head插件操作ElasticSearch"><a href="#head插件操作ElasticSearch" class="headerlink" title="head插件操作ElasticSearch"></a>head插件操作ElasticSearch</h4><h5 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h5><h6 id="步骤1：-下载head插件："><a href="#步骤1：-下载head插件：" class="headerlink" title="步骤1： 下载head插件："></a>步骤1： 下载head插件：</h6><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">https://github.com/mobz/elasticsearch-head</span><br></pre></td></tr></tbody></table></figure><h6 id="步骤2：-将grunt安装为全局命令"><a href="#步骤2：-将grunt安装为全局命令" class="headerlink" title="步骤2： 将grunt安装为全局命令"></a>步骤2： 将grunt安装为全局命令</h6><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">npm install ‐g grunt‐cli</span><br></pre></td></tr></tbody></table></figure><h6 id="步骤3：解决跨域问题"><a href="#步骤3：解决跨域问题" class="headerlink" title="步骤3：解决跨域问题"></a>步骤3：解决跨域问题</h6><p>修改elasticsearch配置文件：elasticsearch.yml，增加以下两句命令：</p><figure class="highlight yaml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">http.cors.enabled:</span> <span class="literal">true</span> </span><br><span class="line"><span class="string">http.cors.allow‐origin:</span> <span class="string">"*"</span></span><br></pre></td></tr></tbody></table></figure><h6 id="步骤4：-安装依赖并启动"><a href="#步骤4：-安装依赖并启动" class="headerlink" title="步骤4： 安装依赖并启动"></a>步骤4： 安装依赖并启动</h6><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">cnpm install</span><br><span class="line">grunt server</span><br></pre></td></tr></tbody></table></figure><h5 id="图形化界面"><a href="#图形化界面" class="headerlink" title="图形化界面"></a>图形化界面</h5><p><img src="https://gitee.com/xulilei/pic/raw/master/20200614170620.png" alt=""></p><h3 id="Logstash"><a href="#Logstash" class="headerlink" title="Logstash"></a>Logstash</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p>Logstash是一款轻量级的日志搜集处理框架，可以方便的把分散的、多样化的日志搜集 起来，并进行自定义的处理，然后传输到指定的位置，比如某个服务器或者文件。</p><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><p>命令行参数: </p><p>-e ：执行（很少用）</p><p> -f：路径，后跟参数类型可以是一个字符串的配置或全路径文件名或全路径</p><p> 如：/etc/logstash.d/，logstash会自动读取/etc/logstash.d/目录下所有*.conf 的文 本文件，然后在自己内存里拼接成一个完整的大配置文件再去执行</p><h4 id="使用Logstash将数据库的内容同步到索引库"><a href="#使用Logstash将数据库的内容同步到索引库" class="headerlink" title="使用Logstash将数据库的内容同步到索引库"></a>使用Logstash将数据库的内容同步到索引库</h4><h5 id="模版，用到时直接填写"><a href="#模版，用到时直接填写" class="headerlink" title="模版，用到时直接填写"></a>模版，用到时直接填写</h5><figure class="highlight yaml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="string">input</span> <span class="string">{</span></span><br><span class="line">  <span class="string">jdbc</span> <span class="string">{</span></span><br><span class="line">  <span class="comment"># mysql jdbc connection string to our backup databse</span></span><br><span class="line">  <span class="string">jdbc_connection_string</span> <span class="string">=&gt;</span> <span class="string">"jdbc:mysql://192.168.xx.xx:3306/aaaaa?characterEncoding=UTF8"</span></span><br><span class="line">  <span class="comment"># the user we wish to excute our statement as</span></span><br><span class="line">  <span class="string">jdbc_user</span> <span class="string">=&gt;</span> <span class="string">"root"</span></span><br><span class="line">  <span class="string">jdbc_password</span> <span class="string">=&gt;</span> <span class="string">"root"</span></span><br><span class="line">  <span class="comment"># the path to our downloaded jdbc driver  </span></span><br><span class="line">  <span class="string">jdbc_driver_library</span> <span class="string">=&gt;</span> <span class="string">"C:\Users\xu\Desktop\tensquare\logstash-5.6.8\mysqletc\mysql-connector-java-5.1.46.jar"</span></span><br><span class="line">  <span class="comment"># the name of the driver class for mysql</span></span><br><span class="line">  <span class="string">jdbc_driver_class</span> <span class="string">=&gt;</span> <span class="string">"com.mysql.jdbc.Driver"</span></span><br><span class="line">  <span class="string">jdbc_paging_enabled</span> <span class="string">=&gt;</span> <span class="string">"true"</span></span><br><span class="line">  <span class="string">jdbc_page_size</span> <span class="string">=&gt;</span> <span class="string">"50"</span></span><br><span class="line">  <span class="comment">#以下对应着要执行的sql的绝对路径。</span></span><br><span class="line">  <span class="comment">#statement_filepath =&gt; ""</span></span><br><span class="line">  <span class="comment">#这个是要直接执行的sql语句</span></span><br><span class="line">  <span class="string">statement</span> <span class="string">=&gt;</span> <span class="string">""</span><span class="string">select</span> <span class="string">id,title,content,state</span> <span class="string">from</span> <span class="string">tb_article"</span></span><br><span class="line">  <span class="comment">#定时字段 各字段含义（由左至右）分、时、天、月、年，全部为*默认含义为每分钟都更新（测试结果，不同的话请留言指出）</span></span><br><span class="line">      <span class="string">schedule</span> <span class="string">=&gt;</span> <span class="string">"* * * * *"</span></span><br><span class="line">  <span class="string">}</span></span><br><span class="line"><span class="string">}</span></span><br><span class="line"></span><br><span class="line"><span class="string">output</span> <span class="string">{</span></span><br><span class="line">  <span class="string">elasticsearch</span> <span class="string">{</span></span><br><span class="line">  <span class="comment">#ESIP地址与端口</span></span><br><span class="line">  <span class="string">hosts</span> <span class="string">=&gt;</span> <span class="string">"127.0.0.1:9200"</span> </span><br><span class="line">  <span class="comment">#ES索引名称（自己定义的）</span></span><br><span class="line">  <span class="string">index</span> <span class="string">=&gt;</span> <span class="string">"articleindex"</span></span><br><span class="line">  <span class="comment">#自增ID编号</span></span><br><span class="line">  <span class="string">document_id</span> <span class="string">=&gt;</span> <span class="string">"<span class="template-variable">%{id}</span>"</span></span><br><span class="line">  <span class="string">document_type</span> <span class="string">=&gt;</span> <span class="string">"article"</span></span><br><span class="line">  <span class="string">}</span></span><br><span class="line">  <span class="string">stdout</span> <span class="string">{</span></span><br><span class="line">      <span class="comment">#以JSON格式输出</span></span><br><span class="line">      <span class="string">codec</span> <span class="string">=&gt;</span> <span class="string">json_lines</span></span><br><span class="line">  <span class="string">}</span></span><br><span class="line"><span class="string">}</span></span><br></pre></td></tr></tbody></table></figure><h5 id="再通过一下命令执行该文件"><a href="#再通过一下命令执行该文件" class="headerlink" title="再通过一下命令执行该文件"></a>再通过一下命令执行该文件</h5><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">logstash ‐f ../mysqletc/mysql.conf</span><br></pre></td></tr></tbody></table></figure><h5 id="结果返回"><a href="#结果返回" class="headerlink" title="结果返回"></a>结果返回</h5><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">{"@version":"1","id":"1","state":"1","@timestamp":"2020-06-15T03:35:00.106Z","title":"xu测试","content":"测试"}</span><br><span class="line">{"@version":"1","id":"1","state":"1","@timestamp":"2020-06-15T03:34:01.671Z","title":"xu测试","content":"测试"}</span><br></pre></td></tr></tbody></table></figure><h5 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h5><p>删除数据库中的文件并不会导致索引库中的数据删除，可以约定一个state，当需要删除的时候更改state的值，在索引库中，查询约定state的值即可实现</p><h3 id="docker安装ES"><a href="#docker安装ES" class="headerlink" title="docker安装ES"></a>docker安装ES</h3><h4 id="安装ES容器"><a href="#安装ES容器" class="headerlink" title="安装ES容器"></a>安装ES容器</h4><h5 id="第一步，安装容器"><a href="#第一步，安装容器" class="headerlink" title="第一步，安装容器"></a>第一步，安装容器</h5><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">docker run ‐di ‐‐name=tensquare_elasticsearch ‐p 9200:9200 ‐p 9300:9300 elasticsearch:5.6.8</span><br></pre></td></tr></tbody></table></figure><h5 id="第二步，允许其他ip地址访问"><a href="#第二步，允许其他ip地址访问" class="headerlink" title="第二步，允许其他ip地址访问"></a>第二步，允许其他ip地址访问</h5><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">进入elasticsearch容器的目录</span></span><br><span class="line">docker exec ‐it tensquare_elasticsearch /bin/bash</span><br><span class="line"><span class="meta">#</span><span class="bash">拷贝容器中的配置文件到宿主机</span></span><br><span class="line">docker cp tensquare_elasticsearch:/usr/share/elasticsearch/config/elasticsearch.yml /usr/share/elasticsearch.yml</span><br><span class="line"><span class="meta">#</span><span class="bash">停止删除原来的容器</span></span><br><span class="line">docker stop tensquare_elasticsearch  docker rm tensquare_elasticsearch</span><br><span class="line"><span class="meta">#</span><span class="bash">重新安装容器，并挂载配置文件为/usr/share/elasticsearch.yml</span></span><br><span class="line">docker run ‐di ‐‐name=tensquare_elasticsearch ‐p 9200:9200 ‐p 9300:9300 ‐v /usr/share/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch .yml elasticsearch:5.6.8</span><br><span class="line"><span class="meta">#</span><span class="bash">修改/usr/share/elasticsearch.yml 将<span class="comment">#transport.host:0.0.0.0前的#去掉后保存文件退出。其作用是允许任何ip地址访问elasticsearch，并指定可以跨域</span></span></span><br><span class="line">transport.host:0.0.0.0</span><br><span class="line">http.cors.enabled: true </span><br><span class="line">http.cors.allow‐origin: "*"</span><br><span class="line"><span class="meta">#</span><span class="bash">重启容器</span></span><br><span class="line">docker restart tensquare_elasticsearch</span><br></pre></td></tr></tbody></table></figure><h5 id="第三部，如果遇到容器启动自动关闭，则需要优化配置-每个机器不同优化也不同"><a href="#第三部，如果遇到容器启动自动关闭，则需要优化配置-每个机器不同优化也不同" class="headerlink" title="第三部，如果遇到容器启动自动关闭，则需要优化配置(每个机器不同优化也不同)"></a>第三部，如果遇到容器启动自动关闭，则需要优化配置(每个机器不同优化也不同)</h5><p>可以参考</p><p><a href="https://blog.csdn.net/qq_34756221/article/details/105550037" target="_blank" rel="noopener">https://blog.csdn.net/qq_34756221/article/details/105550037</a></p><p><a href="https://www.cnblogs.com/jasonzeng/p/11584754.html" target="_blank" rel="noopener">https://www.cnblogs.com/jasonzeng/p/11584754.html</a></p><h4 id="安装ik分词器"><a href="#安装ik分词器" class="headerlink" title="安装ik分词器"></a>安装ik分词器</h4><p>先通过xftp将ik分词文件传送至服务器，再拷贝至es容器目录的plugins中</p><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">docker cp ik tensquare_elasticsearch:/usr/share/elasticsearch/plugins/</span><br></pre></td></tr></tbody></table></figure><h4 id="安装header"><a href="#安装header" class="headerlink" title="安装header"></a>安装header</h4><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">docker run ‐di ‐‐name=myhead ‐p 9100:9100 docker pull mobz/elasticsearch‐ head:5</span><br></pre></td></tr></tbody></table></figure><h4 id="成功页面展示"><a href="#成功页面展示" class="headerlink" title="成功页面展示"></a>成功页面展示</h4><h5 id="head插件展示"><a href="#head插件展示" class="headerlink" title="head插件展示"></a>head插件展示</h5><p><img src="https://gitee.com/xulilei/pic/raw/master/20200615164944.png" alt=""></p><h5 id="ik分词器展示"><a href="#ik分词器展示" class="headerlink" title="ik分词器展示"></a>ik分词器展示</h5><p><img src="https://gitee.com/xulilei/pic/raw/master/20200615165033.png" alt=""></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;分布式搜索引擎ElasticSearch&quot;&gt;&lt;a href=&quot;#分布式搜索引擎ElasticSearch&quot; class=&quot;headerlink&quot; title=&quot;分布式搜索引擎ElasticSearch&quot;&gt;&lt;/a&gt;分布式搜索引擎ElasticSearch&lt;/h3&gt;&lt;
      
    
    </summary>
    
    
      <category term="微服务" scheme="https://xulilei.github.io/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    
      <category term="ElasticSearch" scheme="https://xulilei.github.io/tags/ElasticSearch/"/>
    
      <category term="Logstash" scheme="https://xulilei.github.io/tags/Logstash/"/>
    
      <category term="ik分词器" scheme="https://xulilei.github.io/tags/ik%E5%88%86%E8%AF%8D%E5%99%A8/"/>
    
      <category term="docker" scheme="https://xulilei.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>DayThree-mongoDB</title>
    <link href="https://xulilei.github.io/2020/06/09/%E5%8D%81%E6%AC%A1%E6%96%B9%E9%A1%B9%E7%9B%AE%E7%AC%AC%E4%B8%89%E5%A4%A9/"/>
    <id>https://xulilei.github.io/2020/06/09/%E5%8D%81%E6%AC%A1%E6%96%B9%E9%A1%B9%E7%9B%AE%E7%AC%AC%E4%B8%89%E5%A4%A9/</id>
    <published>2020-06-09T08:25:22.000Z</published>
    <updated>2020-06-22T02:57:13.038Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Day03"><a href="#Day03" class="headerlink" title="Day03"></a>Day03</h2><h4 id="什么是MongoDB"><a href="#什么是MongoDB" class="headerlink" title="什么是MongoDB"></a>什么是MongoDB</h4><p>​    MongoDB 是一个跨平台的，面向文档的数据库，是当前 NoSQL 数据库产品中最热 门 的一种。它介于关系数据库和非关系数据库之间，是非关系数据库当中功能最丰富，最像关系数据库的产品。它支持的数据结构非常松散，是类似 JSON 的 BSON 格式，因此可以存储比较复杂的数据类型。</p><h4 id="MongoDB适用场景"><a href="#MongoDB适用场景" class="headerlink" title="MongoDB适用场景"></a>MongoDB适用场景</h4><p>​    适用于场景数据量大，数据价值相对低的情况</p><h4 id="MongoDB体系结构"><a href="#MongoDB体系结构" class="headerlink" title="MongoDB体系结构"></a>MongoDB体系结构</h4><p>（1）MongoDB 的文档（document），相当于关系数据库中的一行记录。 </p><p>（2）多个文档组成一个集合（collection），相当于关系数据库的表。 </p><p>（3）多个集合（collection），逻辑上组织在一起，就是数据库（database）。</p><h4 id="服务器创建Docker-MongoDB容器"><a href="#服务器创建Docker-MongoDB容器" class="headerlink" title="服务器创建Docker MongoDB容器"></a>服务器创建Docker MongoDB容器</h4><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">[root@pinyoyougou-docker ~]# docker run -di --name=tensquare_mongo -p 27017:27017 mongo</span><br></pre></td></tr></tbody></table></figure><h4 id="MongoDB语法"><a href="#MongoDB语法" class="headerlink" title="MongoDB语法"></a>MongoDB语法</h4><h5 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h5><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">use 数据库名称//如果不存在则自动创建</span><br></pre></td></tr></tbody></table></figure><h5 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h5><figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line">db.集合名称.insert(数据);//插入文档的语法格式</span><br><span class="line">比如db.spit.insert({<span class="keyword">content</span>:<span class="string">"听说十次方课程很给力呀"</span>,userid:<span class="string">"1011"</span>,nickname:<span class="string">"小雅"</span>,visits:NumberInt(<span class="number">902</span>)})</span><br></pre></td></tr></tbody></table></figure><h5 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h5><figure class="highlight"><table><tbody><tr><td class="code"><pre><span class="line">db.集合名称.find()//查询所有</span><br><span class="line">db.spit.find().limit(3)//限定返回3条</span><br><span class="line">db.spit.find({userid:'1013'})//查询userid=1013的文档</span><br></pre></td></tr></tbody></table></figure><h5 id="修改与删除数据"><a href="#修改与删除数据" class="headerlink" title="修改与删除数据"></a>修改与删除数据</h5><figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line">db.集合名称.update(条件,修改后的数据)</span><br><span class="line">//如果我们想修改_id为<span class="number">1</span>的记录，浏览量为<span class="number">1000</span>，输入以下语句：</span><br><span class="line">db.spit.update({_id:<span class="string">"1"</span>},{visits:NumberInt(<span class="number">1000</span>)})</span><br><span class="line">执行后，我们会发现，这条文档除了visits字段其它字段都不见了，为了解决这个问题，我们需要使用修改器$<span class="keyword">set</span>来实现，命令如下：</span><br><span class="line">db.spit.update({_id:<span class="string">"2"</span>},{$<span class="keyword">set</span>:{visits:NumberInt(<span class="number">2000</span>)}})</span><br><span class="line">//删除指定文档</span><br><span class="line">db.集合名称.remove(条件)</span><br></pre></td></tr></tbody></table></figure><h5 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h5><figure class="highlight"><table><tbody><tr><td class="code"><pre><span class="line">MongoDB的模糊查询是通过正则表达式的方式实现的</span><br><span class="line">格式为：db.集合名称.find({content:/aaa/})</span><br><span class="line">例如，我要查询吐槽内容包含“流量”的所有文档，代码如下：</span><br><span class="line">db.spit.find({content:/流量/})</span><br><span class="line">如果要查询吐槽内容中以“加班”开头的，代码如下：</span><br><span class="line">db.spit.find({content:/^加班/})</span><br></pre></td></tr></tbody></table></figure><h5 id="大于-小于-不等于"><a href="#大于-小于-不等于" class="headerlink" title="大于 小于 不等于"></a>大于 小于 不等于</h5><figure class="highlight"><table><tbody><tr><td class="code"><pre><span class="line">db.集合名称.find({ "field" : { $gt: value }}) // 大于: field &gt; value</span><br><span class="line">db.集合名称.find({ "field" : { $lt: value }}) // 小于: field &lt; value</span><br><span class="line">db.集合名称.find({ "field" : { $gte: value }}) // 大于等于: field &gt;= value</span><br><span class="line">db.集合名称.find({ "field" : { $lte: value }}) // 小于等于: field &lt;= value</span><br><span class="line">db.集合名称.find({ "field" : { $ne: value }}) // 不等于: field != value</span><br></pre></td></tr></tbody></table></figure><h5 id="包含与不包含"><a href="#包含与不包含" class="headerlink" title="包含与不包含"></a>包含与不包含</h5><figure class="highlight"><table><tbody><tr><td class="code"><pre><span class="line">包含使用$in操作符。</span><br><span class="line">示例：查询吐槽集合中userid字段包含1013和1014的文档</span><br><span class="line">db.spit.find({userid:{$in:["1013","1014"]}})</span><br><span class="line">不包含使用$nin操作符。</span><br><span class="line">示例：查询吐槽集合中userid字段不包含1013和1014的文档</span><br><span class="line">db.spit.find({userid:{$nin:["1013","1014"]}})</span><br></pre></td></tr></tbody></table></figure><h5 id="条件连接"><a href="#条件连接" class="headerlink" title="条件连接"></a>条件连接</h5><figure class="highlight"><table><tbody><tr><td class="code"><pre><span class="line">我们如果需要查询同时满足两个以上条件，需要使用$and操作符将条件进行关联。（相当于SQL的and）</span><br><span class="line">格式为：$and:[{ },{ },{ }]</span><br><span class="line">示例：查询吐槽集合中visits大于等于1000 并且小于2000的文档</span><br><span class="line">db.spit.find({$and:[ {visits:{$gte:1000}} ,{visits:{$lt:2000}}]})</span><br><span class="line"></span><br><span class="line">如果两个以上条件之间是或者的关系，我们使用 操作符进行关联，与前面and的使用方式相同</span><br><span class="line">格式为：$or:[{ },{ },{ }]</span><br><span class="line">示例：查询吐槽集合中userid为1013，或者浏览量小于2000的文档记录</span><br><span class="line">db.spit.find({$or:[ {userid:"1013"} ,{visits:{$lt:2000} }]})</span><br></pre></td></tr></tbody></table></figure><h5 id="列值增长"><a href="#列值增长" class="headerlink" title="列值增长"></a>列值增长</h5><figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line">如果我们想实现对某列值在原有值的基础上进行增加或减少，可以使用$inc运算符来实现</span><br><span class="line">db.spit.update({_id:<span class="string">"2"</span>},{$inc:{visits:NumberInt(<span class="number">1</span>)}})</span><br></pre></td></tr></tbody></table></figure><h4 id="JAVA操作MongoDB"><a href="#JAVA操作MongoDB" class="headerlink" title="JAVA操作MongoDB"></a>JAVA操作MongoDB</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MongoDemo</span> </span>{</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">    MongoClient client=<span class="keyword">new</span> MongoClient(<span class="string">"192.168.184.134"</span>);<span class="comment">//创建连接</span></span><br><span class="line">    MongoDatabase spitdb = client.getDatabase(<span class="string">"spitdb"</span>);<span class="comment">//打开数据库</span></span><br><span class="line">    MongoCollection&lt;Document&gt; spit = spitdb.getCollection(<span class="string">"spit"</span>);<span class="comment">//获取集合</span></span><br><span class="line">     <span class="comment">//条件查询</span></span><br><span class="line">     <span class="comment">//BasicDBObject bson=new BasicDBObject("userid","1013");// 构建查询条件</span></span><br><span class="line">     <span class="comment">//BasicDBObject bson=new BasicDBObject("visits",newBasicDBObject("$gt",1000) );</span></span><br><span class="line">     <span class="comment">//FindIterable&lt;Document&gt; documents = spit.find(bson);//查询记录获取结果集合</span></span><br><span class="line">    FindIterable&lt;Document&gt; documents = spit.find();<span class="comment">//查询记录获取文档集合</span></span><br><span class="line">    <span class="keyword">for</span>(Document document:documents){ <span class="comment">//</span></span><br><span class="line">      System.out.println(<span class="string">"内容："</span>+ document.getString(<span class="string">"content"</span>));</span><br><span class="line">      System.out.println(<span class="string">"用户ID:"</span>+document.getString(<span class="string">"userid"</span>));</span><br><span class="line">      System.out.println(<span class="string">"浏览量："</span>+document.getInteger(<span class="string">"visits"</span>));</span><br><span class="line">    }</span><br><span class="line">     <span class="comment">//插入数据</span></span><br><span class="line">     Map&lt;String,Object&gt; map=<span class="keyword">new</span> HashMap();</span><br><span class="line">     map.put(<span class="string">"content"</span>,<span class="string">"我要吐槽"</span>);</span><br><span class="line">     map.put(<span class="string">"userid"</span>,<span class="string">"9999"</span>);</span><br><span class="line">     map.put(<span class="string">"visits"</span>,<span class="number">123</span>);</span><br><span class="line">     map.put(<span class="string">"publishtime"</span>,<span class="keyword">new</span> Date());</span><br><span class="line">     Document document=<span class="keyword">new</span> Document(map);</span><br><span class="line">     spit.insertOne(document);</span><br><span class="line">     client.close();<span class="comment">//关闭连接</span></span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="SpringDataMongoDB"><a href="#SpringDataMongoDB" class="headerlink" title="SpringDataMongoDB"></a>SpringDataMongoDB</h4><p>增删改查与SpringDataJPA几乎一样，详细用法参考<a href="https://xulilei.github.io/2020/06/08/%E5%8D%81%E6%AC%A1%E6%96%B9%E9%A1%B9%E7%9B%AEDay2/">https://xulilei.github.io/2020/06/08/%E5%8D%81%E6%AC%A1%E6%96%B9%E9%A1%B9%E7%9B%AEDay2/</a></p><h5 id="通过MongoTemplate原生方式实现数据自增"><a href="#通过MongoTemplate原生方式实现数据自增" class="headerlink" title="通过MongoTemplate原生方式实现数据自增"></a>通过MongoTemplate原生方式实现数据自增</h5><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">thumbUp</span><span class="params">(String id)</span></span>{</span><br><span class="line">        <span class="comment">//方式一,与数据库多次交互性能较低</span></span><br><span class="line">        Spit spit=spitDao.findById(id).get();</span><br><span class="line">        spit.setThumbup((spit.getThumbup()==<span class="keyword">null</span>?<span class="number">0</span>:spit.getThumbup())+<span class="number">1</span>);</span><br><span class="line">        spitDao.save(spit);</span><br><span class="line">        <span class="comment">//相当于使用原生mongo命令实现自增：db.spit.update({"_id":"1"},{$inc:{thumbup:NumberInt(1)}})</span></span><br><span class="line">        Query query=<span class="keyword">new</span> Query();</span><br><span class="line">        query.addCriteria(Criteria.where(<span class="string">"_id"</span>).is(<span class="string">"id"</span>));</span><br><span class="line">        Update update=<span class="keyword">new</span> Update();</span><br><span class="line">        update.inc(<span class="string">"thumbup"</span>,<span class="number">1</span>);</span><br><span class="line">        mongoTemplate.updateFirst(query,update,<span class="string">"spit"</span>);</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Day03&quot;&gt;&lt;a href=&quot;#Day03&quot; class=&quot;headerlink&quot; title=&quot;Day03&quot;&gt;&lt;/a&gt;Day03&lt;/h2&gt;&lt;h4 id=&quot;什么是MongoDB&quot;&gt;&lt;a href=&quot;#什么是MongoDB&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
    
      <category term="十次方项目" scheme="https://xulilei.github.io/categories/%E5%8D%81%E6%AC%A1%E6%96%B9%E9%A1%B9%E7%9B%AE/"/>
    
    
      <category term="MongoDB" scheme="https://xulilei.github.io/tags/MongoDB/"/>
    
      <category term="项目" scheme="https://xulilei.github.io/tags/%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>DayTwo-SpringDataJpa</title>
    <link href="https://xulilei.github.io/2020/06/08/%E5%8D%81%E6%AC%A1%E6%96%B9%E9%A1%B9%E7%9B%AEDay2/"/>
    <id>https://xulilei.github.io/2020/06/08/%E5%8D%81%E6%AC%A1%E6%96%B9%E9%A1%B9%E7%9B%AEDay2/</id>
    <published>2020-06-08T07:23:13.000Z</published>
    <updated>2020-06-18T07:50:05.929Z</updated>
    
    <content type="html"><![CDATA[<h3 id="SpringDataJpa"><a href="#SpringDataJpa" class="headerlink" title="SpringDataJpa"></a>SpringDataJpa</h3><h4 id="通过new-Specification实现条件查询"><a href="#通过new-Specification实现条件查询" class="headerlink" title="通过new Specification实现条件查询"></a>通过new Specification实现条件查询</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//service层</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Label&gt; <span class="title">findSearch</span><span class="params">(Label label)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> labelDao.findAll(<span class="keyword">new</span> Specification&lt;Label&gt;() {</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 采用内部类，方式实现</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> root 根对象，也就是说要把条件封装到哪个对象中去</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> query 查询关键字，比如groupBy，orderBy等</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> cb 用来封装条件对象的</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@return</span> 如果返回null，则代表不需要任何条件</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Predicate <span class="title">toPredicate</span><span class="params">(Root&lt;Label&gt; root, CriteriaQuery&lt;?&gt; query, CriteriaBuilder cb)</span> </span>{</span><br><span class="line">                List&lt;Predicate&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                <span class="comment">//相当于 where labelname like "%小明%"</span></span><br><span class="line">                <span class="keyword">if</span>(label.getLabelname()!=<span class="keyword">null</span>&amp;&amp;!<span class="string">""</span>.equals(label.getLabelname())){</span><br><span class="line">                    Predicate predicate = cb.like(root.get("labelname").as(String.class), "%" +           label.getLabelname() + "%");</span><br><span class="line">                    list.add(predicate);</span><br><span class="line">                }</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(label.getState()!=<span class="keyword">null</span>&amp;&amp;!<span class="string">""</span>.equals(label.getState())){</span><br><span class="line">                    Predicate predicate = cb.equal(root.get(<span class="string">"state"</span>).as(String<span class="class">.<span class="keyword">class</span>),  <span class="title">label</span>.<span class="title">getState</span>())</span>;</span><br><span class="line">                    list.add(predicate);</span><br><span class="line">                }</span><br><span class="line">                Predicate[] parr=<span class="keyword">new</span> Predicate[list.size()];</span><br><span class="line">                list.toArray(parr);</span><br><span class="line">                <span class="comment">//相当于查询where condition A and condition B</span></span><br><span class="line">                <span class="keyword">return</span> cb.and(parr);</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"><span class="comment">//controller层</span></span><br><span class="line"> <span class="meta">@RequestMapping</span>(value = <span class="string">"/search"</span>,method = RequestMethod.POST)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">findSearch</span><span class="params">(@RequestBody Label label)</span></span>{</span><br><span class="line">        List&lt;Label&gt;list=labelService.findSearch(label);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Result(<span class="keyword">true</span>,StatusCode.OK,<span class="string">"查询成功"</span>,list);</span><br><span class="line"></span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><h4 id="分页与条件查询"><a href="#分页与条件查询" class="headerlink" title="分页与条件查询"></a>分页与条件查询</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//service层</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Page&lt;Label&gt; <span class="title">findSearchAndPageQuery</span><span class="params">(Label label, <span class="keyword">int</span> page, <span class="keyword">int</span> size)</span> </span>{</span><br><span class="line">        <span class="comment">//封装一个分页对象</span></span><br><span class="line">        Pageable pageable=PageRequest.of(page-<span class="number">1</span>,size);</span><br><span class="line">        <span class="keyword">return</span> labelDao.findAll(<span class="keyword">new</span> Specification&lt;Label&gt;() {</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> root 根对象，也就是说要把条件封装到哪个对象中去</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> query 查询关键字，比如groupBy，orderBy等</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> cb 用来封装条件对象的</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@return</span> 如果返回null，则代表不需要任何条件</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Predicate <span class="title">toPredicate</span><span class="params">(Root&lt;Label&gt; root, CriteriaQuery&lt;?&gt; query, CriteriaBuilder cb)</span> </span>{</span><br><span class="line">                List&lt;Predicate&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                <span class="comment">//相当于 where labelname like "%小明%"</span></span><br><span class="line">                <span class="keyword">if</span>(label.getLabelname()!=<span class="keyword">null</span>&amp;&amp;!<span class="string">""</span>.equals(label.getLabelname())){</span><br><span class="line">                    Predicate predicate = cb.like(root.get("labelname").as(String.class), "%" + label.getLabelname() + "%");</span><br><span class="line">                    list.add(predicate);</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span>(label.getState()!=<span class="keyword">null</span>&amp;&amp;!<span class="string">""</span>.equals(label.getState())){</span><br><span class="line">                    Predicate predicate = cb.equal(root.get(<span class="string">"state"</span>).as(String<span class="class">.<span class="keyword">class</span>),  <span class="title">label</span>.<span class="title">getState</span>())</span>;</span><br><span class="line">                    list.add(predicate);</span><br><span class="line">                }</span><br><span class="line">                Predicate[] parr=<span class="keyword">new</span> Predicate[list.size()];</span><br><span class="line">                list.toArray(parr);</span><br><span class="line">                <span class="keyword">return</span> cb.and(parr);</span><br><span class="line">            }</span><br><span class="line">        },pageable);</span><br><span class="line">    }</span><br><span class="line"><span class="comment">//controller层</span></span><br><span class="line"> <span class="meta">@RequestMapping</span>(value = <span class="string">"/search/{page}/{size}"</span>,method = RequestMethod.POST)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">findSearchAndPageQuery</span><span class="params">(@RequestBody Label label,@PathVariable <span class="keyword">int</span> page,@PathVariable <span class="keyword">int</span> size)</span></span>{</span><br><span class="line">        Page&lt;Label&gt; pageData=labelService.findSearchAndPageQuery(label,page,size);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Result(<span class="keyword">true</span>,StatusCode.OK,<span class="string">"查询成功"</span>,<span class="keyword">new</span> PageResult&lt;Label&gt;(pageData.getTotalElements(),pageData.getContent()));</span><br><span class="line">    }</span><br><span class="line"><span class="comment">//用来封装pageResult的类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PageResult</span>&lt;<span class="title">T</span>&gt; </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> total;</span><br><span class="line">    <span class="keyword">private</span> List&lt;T&gt; rows;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getTotal</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> total;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTotal</span><span class="params">(<span class="keyword">long</span> total)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.total = total;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;T&gt; <span class="title">getRows</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> rows;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRows</span><span class="params">(List&lt;T&gt; rows)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.rows = rows;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PageResult</span><span class="params">()</span> </span>{</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PageResult</span><span class="params">(<span class="keyword">long</span> total, List&lt;T&gt; rows)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.total = total;</span><br><span class="line">        <span class="keyword">this</span>.rows = rows;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="在Dao层通过方法命名方式生成sql语句"><a href="#在Dao层通过方法命名方式生成sql语句" class="headerlink" title="在Dao层通过方法命名方式生成sql语句"></a>在Dao层通过方法命名方式生成sql语句</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">EnterpriseDao</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">Enterprise</span>,<span class="title">String</span>&gt;,<span class="title">JpaSpecificationExecutor</span>&lt;<span class="title">Enterprise</span>&gt;</span>{</span><br><span class="line">      <span class="comment">//相当于where ishot=? </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Enterprise&gt; <span class="title">findByIshot</span><span class="params">(String ishot)</span></span>; </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RecruitDao</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">Recruit</span>,<span class="title">String</span>&gt;,<span class="title">JpaSpecificationExecutor</span>&lt;<span class="title">Recruit</span>&gt;</span>{</span><br><span class="line"><span class="comment">//相当于where state=？ order by Createtime，并且取前6个</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Recruit&gt; <span class="title">findTop6ByStateOrderByCreatetimeDesc</span><span class="params">(String state)</span></span>;</span><br><span class="line">    <span class="comment">//相当于where state！=？order by createtime。并且取前6个</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Recruit&gt; <span class="title">findTop6ByStateNotOrderByCreatetimeDesc</span><span class="params">(String state)</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>具体命名规则参考<a href="https://www.cnblogs.com/oxygenG/p/10057525.html。" target="_blank" rel="noopener">https://www.cnblogs.com/oxygenG/p/10057525.html。</a></p><h4 id="处理多对多关系"><a href="#处理多对多关系" class="headerlink" title="处理多对多关系"></a>处理多对多关系</h4><p>在数据库端处理多对多的关系，必须需要借助中间表。而在java端，只需要在一个对象中放入另一个对象的list集合即可。如果不创建实体类，则需要通过原生的sql语句执行</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//通过这个查询语句，才能够实现pageable的分页功能</span></span><br><span class="line"><span class="meta">@Query</span>(value=<span class="string">"SELECT *  FROM tb_problem,tb_pl WHERE id=problemid AND labelid=:labelid ORDER BY ?#{#pageable}"</span>,</span><br><span class="line">       countQuery = <span class="string">"select count(*) from tb_problem ,tb_pl where id=problemid AND labelid=:labelid"</span>,nativeQuery = <span class="keyword">true</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Page&lt;Problem&gt; <span class="title">newList</span><span class="params">(@Param(<span class="string">"labelid"</span>)</span> String labelid, Pageable pageable)</span>;</span><br></pre></td></tr></tbody></table></figure><p>参考：<a href="https://blog.csdn.net/tt____tt/article/details/81027269?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase" target="_blank" rel="noopener">https://blog.csdn.net/tt____tt/article/details/81027269?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase</a></p><h4 id="事务支持"><a href="#事务支持" class="headerlink" title="事务支持"></a>事务支持</h4><p>1、Dao层，在可能产生线程问题的语句上添加@Modifying</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Modifying</span></span><br><span class="line"><span class="meta">@Query</span>(value = <span class="string">"update tb_article set state='1' where id=?1"</span>,nativeQuery = <span class="keyword">true</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateState</span><span class="params">(String id)</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>2、Service层开启注解支持@Transactional</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArticleService</span> </span>{</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="缓存的应用"><a href="#缓存的应用" class="headerlink" title="缓存的应用"></a>缓存的应用</h4><h5 id="Redis–有过期时间限制"><a href="#Redis–有过期时间限制" class="headerlink" title="Redis–有过期时间限制"></a>Redis–有过期时间限制</h5><p>1、添加SpringDataRedis依赖</p><figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>2、服务端Docker开启Redis镜像，生成redis容器</p><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">[root@pinyoyougou-docker ~]# docker run -di --name=tensquare_redis -p 6379:6379 redis</span><br></pre></td></tr></tbody></table></figure><p>3、application.ymal配置host</p><figure class="highlight yaml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="string">.*.*</span></span><br></pre></td></tr></tbody></table></figure><p>4、业务逻辑调用</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArticleService</span> </span>{</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> ArticleDao articleDao;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Article <span class="title">findById</span><span class="params">(String id)</span> </span>{</span><br><span class="line"><span class="comment">//先从缓存中查询当前对象</span></span><br><span class="line">Article article= (Article) redisTemplate.opsForValue().get(<span class="string">"article_"</span>+id);</span><br><span class="line"><span class="comment">//如果没有渠道</span></span><br><span class="line"><span class="keyword">if</span>(article==<span class="keyword">null</span>){</span><br><span class="line">article = articleDao.findById(id).get();</span><br><span class="line"><span class="comment">//存入缓存</span></span><br><span class="line">redisTemplate.opsForValue().set(<span class="string">"article_"</span>+id,article);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> article;</span><br><span class="line">}</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteById</span><span class="params">(String id)</span> </span>{</span><br><span class="line">        <span class="comment">//删除缓存</span></span><br><span class="line">redisTemplate.delete(<span class="string">"article_"</span>+id);</span><br><span class="line">articleDao.deleteById(id);</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>redisTemplate用法</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">stringRedisTemplate.opsForValue().set(<span class="string">"test"</span>, <span class="string">"100"</span>,<span class="number">60</span>*<span class="number">10</span>,TimeUnit.SECONDS);<span class="comment">//向redis里存入数据和设置缓存时间</span></span><br><span class="line">stringRedisTemplate.opsForValue().get(<span class="string">"test"</span>)<span class="comment">//根据key获取缓存中的val</span></span><br><span class="line">stringRedisTemplate.delete(<span class="string">"test"</span>);<span class="comment">//根据key删除缓存</span></span><br><span class="line">stringRedisTemplate.hasKey(<span class="string">"546545"</span>);<span class="comment">//检查key是否存在，返回boolean值</span></span><br></pre></td></tr></tbody></table></figure><h5 id="SpringCache–无过期时间限制"><a href="#SpringCache–无过期时间限制" class="headerlink" title="SpringCache–无过期时间限制"></a>SpringCache–无过期时间限制</h5><p>1、SpringApplication开启SpringCache</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableCaching</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GatApplication</span> </span>{</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>2、业务层调用，@Cacheable为存，@CacheEvict为删</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">   <span class="meta">@Cacheable</span>(value = <span class="string">"gathering"</span>,key = <span class="string">"#id"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Gathering <span class="title">findById</span><span class="params">(String id)</span> </span>{</span><br><span class="line"><span class="keyword">return</span> gatheringDao.findById(id).get();</span><br><span class="line">}</span><br><span class="line"><span class="meta">@CacheEvict</span>(value = <span class="string">"gathering"</span>,key = <span class="string">"#gathering.id"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Gathering gathering)</span> </span>{</span><br><span class="line">gatheringDao.save(gathering);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="第二天总结"><a href="#第二天总结" class="headerlink" title="第二天总结"></a>第二天总结</h3><p>掌握了条件与分页查询，Dao层方法命名规则，事务支持，缓存</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;SpringDataJpa&quot;&gt;&lt;a href=&quot;#SpringDataJpa&quot; class=&quot;headerlink&quot; title=&quot;SpringDataJpa&quot;&gt;&lt;/a&gt;SpringDataJpa&lt;/h3&gt;&lt;h4 id=&quot;通过new-Specification实现
      
    
    </summary>
    
    
      <category term="十次方项目" scheme="https://xulilei.github.io/categories/%E5%8D%81%E6%AC%A1%E6%96%B9%E9%A1%B9%E7%9B%AE/"/>
    
    
      <category term="SpringDataJPA" scheme="https://xulilei.github.io/tags/SpringDataJPA/"/>
    
      <category term="项目" scheme="https://xulilei.github.io/tags/%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>Docker入门篇</title>
    <link href="https://xulilei.github.io/2020/06/05/Docker%E5%85%A5%E9%97%A8/"/>
    <id>https://xulilei.github.io/2020/06/05/Docker%E5%85%A5%E9%97%A8/</id>
    <published>2020-06-05T07:57:43.000Z</published>
    <updated>2020-06-15T09:09:13.173Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker入门"><a href="#Docker入门" class="headerlink" title="Docker入门"></a>Docker入门</h1><h4 id="Dokcer为什么会出现？"><a href="#Dokcer为什么会出现？" class="headerlink" title="Dokcer为什么会出现？"></a>Dokcer为什么会出现？</h4><p>一款产品从开发到上线，一般都需要两套环境。而环境的配置十分麻烦，Docker给出了解决方案</p><h4 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h4><p>java–jar（环境）–打包项目带上环境（即Docker镜像）–Docker仓库–下载我们发布的镜像–直接运行即可。</p><h4 id="虚拟机技术特点"><a href="#虚拟机技术特点" class="headerlink" title="虚拟机技术特点"></a>虚拟机技术特点</h4><p>1、资源占用十分多</p><p>2、冗余步骤多</p><p>3、启动很慢</p><p>如下图所示，多个APP共享一个lib环境，可能会造成端口冲突等环境冲突的问题</p><p><img src="https://gitee.com/xulilei/pic/raw/master/TIM%E5%9B%BE%E7%89%8720200603160240.png" alt=""></p><h4 id="容器化技术"><a href="#容器化技术" class="headerlink" title="容器化技术"></a>容器化技术</h4><p>如下图所示，每个模块拥有独属于自己运行的环境，各个模块之间相互隔离</p><p><img src="https://gitee.com/xulilei/pic/raw/master/20200603160535.png" alt=""></p><h4 id="Docker的相关概念"><a href="#Docker的相关概念" class="headerlink" title="Docker的相关概念"></a>Docker的相关概念</h4><h5 id="Docker架构图"><a href="#Docker架构图" class="headerlink" title="Docker架构图"></a>Docker架构图</h5><p><img src="https://gitee.com/xulilei/pic/raw/master/20200603161527.png" alt=""></p><h5 id="相关术语"><a href="#相关术语" class="headerlink" title="相关术语"></a>相关术语</h5><h6 id="镜像：images"><a href="#镜像：images" class="headerlink" title="镜像：images"></a>镜像：images</h6><p>​    通过这个模版来创建容器服务，比如Mysql镜像–通过Docker运行后，便成为了一个提供服务的容器,一个镜像可以创建多个容器</p><h5 id="容器：container"><a href="#容器：container" class="headerlink" title="容器：container"></a>容器：container</h5><p>​    提供服务，可以启动、停止、删除等，可类比为一个简单的linux系统</p><h5 id="仓库：repository"><a href="#仓库：repository" class="headerlink" title="仓库：repository"></a>仓库：repository</h5><p>​    存放镜像的地方，分为共有仓库和私有仓库</p><h4 id="Docker安装Nginx"><a href="#Docker安装Nginx" class="headerlink" title="Docker安装Nginx"></a>Docker安装Nginx</h4><p>1、search：可在命令行和dockerHub上搜索对应版本</p><p>2、pull：拉去下载该镜像</p><p>3、docker images：查看本机上的镜像</p><p>3、运行该镜像 </p><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">docker run -d --name nginx01 -p 3344:80 nginx </span><br><span class="line"><span class="meta">#</span><span class="bash">新建一个名字为nginx01的nginx镜像，公网访问地址为3344，内部地址为80，并运行该镜像</span></span><br><span class="line"><span class="meta">#</span><span class="bash">-d 后台运行、--name 命名、-p 端口号</span></span><br></pre></td></tr></tbody></table></figure><p>4、内部测试</p><p>​    curl localhost:3344</p><h4 id="容器数据卷"><a href="#容器数据卷" class="headerlink" title="容器数据卷"></a>容器数据卷</h4><h5 id="结构示意图如下"><a href="#结构示意图如下" class="headerlink" title="结构示意图如下"></a>结构示意图如下</h5><p><img src="https://gitee.com/xulilei/pic/raw/master/20200605154253.png" alt=""></p><p>防止容器删除后数据丢失，通过实现容器间数据共享，并将产生的数据备份到linux的文件系统上</p><p>总结一句话就是：容器的持久化和容器间的同步操作。</p><h5 id="使用数据卷"><a href="#使用数据卷" class="headerlink" title="使用数据卷"></a>使用数据卷</h5><p>​    -v 主机目录:容器内目录  —&gt;映射容器内的目录到主机上</p><p>​    参考<a href="https://xulilei.github.io/2020/06/12/elasticSearch入门/">https://xulilei.github.io/2020/06/12/elasticSearch%E5%85%A5%E9%97%A8/</a> </p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Docker入门&quot;&gt;&lt;a href=&quot;#Docker入门&quot; class=&quot;headerlink&quot; title=&quot;Docker入门&quot;&gt;&lt;/a&gt;Docker入门&lt;/h1&gt;&lt;h4 id=&quot;Dokcer为什么会出现？&quot;&gt;&lt;a href=&quot;#Dokcer为什么会出现？&quot; c
      
    
    </summary>
    
    
      <category term="微服务" scheme="https://xulilei.github.io/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    
      <category term="Docker" scheme="https://xulilei.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>DayOne-架构</title>
    <link href="https://xulilei.github.io/2020/06/02/%E5%8D%81%E6%AC%A1%E6%96%B9%E7%A4%BE%E4%BA%A4%E5%B9%B3%E5%8F%B0%E9%A1%B9%E7%9B%AE/"/>
    <id>https://xulilei.github.io/2020/06/02/%E5%8D%81%E6%AC%A1%E6%96%B9%E7%A4%BE%E4%BA%A4%E5%B9%B3%E5%8F%B0%E9%A1%B9%E7%9B%AE/</id>
    <published>2020-06-02T11:02:13.000Z</published>
    <updated>2020-06-22T03:48:48.432Z</updated>
    
    <content type="html"><![CDATA[<h2 id="DayOne"><a href="#DayOne" class="headerlink" title="DayOne"></a>DayOne</h2><h3 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h3><p>SpringBoot+SpringCloud+SpringMVC+SpringData，也称这种架构模式为spring全家桶</p><h3 id="系统模块"><a href="#系统模块" class="headerlink" title="系统模块"></a>系统模块</h3><p>不再采取按dao，service层划分模块，而是基于每个微服务，再将每个模块封装成一个镜像，再通过springCloud连接起来。因此在每个微服务中便不需要再写接口，因为每个微服务就是最小模块 </p><p><img src="https://gitee.com/xulilei/pic/raw/master/image-20200602161001068.png" alt=""></p><h3 id="开发API"><a href="#开发API" class="headerlink" title="开发API"></a>开发API</h3><p>通过swagger封装，Nginx代理，形成的API开发文档</p><p><img src="https://gitee.com/xulilei/pic/raw/master/image-20200602154755423.png" alt=""></p><h3 id="Restful开发风格"><a href="#Restful开发风格" class="headerlink" title="Restful开发风格"></a>Restful开发风格</h3><p>我们在项目中经常用到增删改查：get/post/put/delete四种方法，安全：操作不会出现脏读、幻读等操作。幂等：查询成功后不会对数据库造成影响</p><ul><li>Get查询是安全且幂等的</li><li>Post是不安全且不幂等的</li><li>Put改是不安全且幂等的</li><li>Delete删是不安全且幂等的</li></ul><h3 id="主要工作"><a href="#主要工作" class="headerlink" title="主要工作"></a>主要工作</h3><h4 id="Mysql环境搭建"><a href="#Mysql环境搭建" class="headerlink" title="Mysql环境搭建"></a>Mysql环境搭建</h4><p>创建虚拟机，安装docker，下载Mysql镜像，在服务器(192.168.152.128)运行并从本地连接完成建表</p><h4 id="创建父工程"><a href="#创建父工程" class="headerlink" title="创建父工程"></a>创建父工程</h4><p>主要是一些子模块都需要的依赖配置在这里</p><figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--SpringCloud全家桶父工程推荐默认配置--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>spring-snapshots<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>Spring Snapshots<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://repo.spring.io/snapshot<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>spring-milestones<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>Spring Milestones<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://repo.spring.io/milestone<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>false<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">pluginRepositories</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>spring-snapshots<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>Spring Snapshots<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://repo.spring.io/snapshot<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>spring-milestones<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>Spring Milestones<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://repo.spring.io/milestone<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>false<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">pluginRepositories</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h4 id="模块搭建"><a href="#模块搭建" class="headerlink" title="模块搭建"></a>模块搭建</h4><h5 id="公共模块搭建，根据swagger约定，封装数据传输到前端。其中utils包下的idWoker根据雪花算法，可以生成不同的ID，吞吐量为20W-。"><a href="#公共模块搭建，根据swagger约定，封装数据传输到前端。其中utils包下的idWoker根据雪花算法，可以生成不同的ID，吞吐量为20W-。" class="headerlink" title="公共模块搭建，根据swagger约定，封装数据传输到前端。其中utils包下的idWoker根据雪花算法，可以生成不同的ID，吞吐量为20W+。"></a>公共模块搭建，根据swagger约定，封装数据传输到前端。其中utils包下的idWoker根据雪花算法，可以生成不同的ID，吞吐量为20W+。</h5><p><img src="https://gitee.com/xulilei/pic/raw/master/20200608145934.png" alt=""></p><h5 id="基础模块搭建，数据的CRUD操作"><a href="#基础模块搭建，数据的CRUD操作" class="headerlink" title="基础模块搭建，数据的CRUD操作"></a>基础模块搭建，数据的CRUD操作</h5><p><img src="https://gitee.com/xulilei/pic/raw/master/20200608150627.png" alt=""></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.tensquare.base.pojo.Label;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.jpa.repository.JpaRepository;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.jpa.repository.JpaSpecificationExecutor;</span><br><span class="line"><span class="comment">//SpringDataJpa封装了CRUD操作，以及一些复杂的条件查询</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LabelDao</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">Label</span>,<span class="title">String</span>&gt;, <span class="title">JpaSpecificationExecutor</span>&lt;<span class="title">Label</span>&gt; </span>{</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="Day01总结"><a href="#Day01总结" class="headerlink" title="Day01总结"></a>Day01总结</h3><h4 id="在服务器端，通过Docker创建了Mysql镜像"><a href="#在服务器端，通过Docker创建了Mysql镜像" class="headerlink" title="在服务器端，通过Docker创建了Mysql镜像"></a>在服务器端，通过Docker创建了Mysql镜像</h4><p><img src="https://gitee.com/xulilei/pic/raw/master/20200608151611.png" alt=""></p><h4 id="通过本地IDEA的DataSource连接上去。"><a href="#通过本地IDEA的DataSource连接上去。" class="headerlink" title="通过本地IDEA的DataSource连接上去。"></a>通过本地IDEA的DataSource连接上去。</h4><p><img src="https://gitee.com/xulilei/pic/raw/master/20200608151109.png" alt=""></p><h4 id="通过PostMan检查当天的CRUD操作"><a href="#通过PostMan检查当天的CRUD操作" class="headerlink" title="通过PostMan检查当天的CRUD操作"></a>通过PostMan检查当天的CRUD操作</h4><p><img src="https://gitee.com/xulilei/pic/raw/master/20200608151349.png" alt=""></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;DayOne&quot;&gt;&lt;a href=&quot;#DayOne&quot; class=&quot;headerlink&quot; title=&quot;DayOne&quot;&gt;&lt;/a&gt;DayOne&lt;/h2&gt;&lt;h3 id=&quot;系统架构&quot;&gt;&lt;a href=&quot;#系统架构&quot; class=&quot;headerlink&quot; title=&quot;系
      
    
    </summary>
    
    
      <category term="十次方项目" scheme="https://xulilei.github.io/categories/%E5%8D%81%E6%AC%A1%E6%96%B9%E9%A1%B9%E7%9B%AE/"/>
    
    
      <category term="项目" scheme="https://xulilei.github.io/tags/%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
</feed>
