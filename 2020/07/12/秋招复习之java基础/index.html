<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>秋招复习之java基础 | Humble</title><meta name="description" content="秋招复习之java基础1、面对对象的理解面向对象易维护，易复用，易扩展。因为面向对象有封装、继承、多态三大特性，所以基于面对对象思想构建的程序具有低耦合、更灵活、易维护等特点 封装、继承、多态封装：也就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。 继承：是指可以让某个类型的对象获得另一个类型的对象的属性的方法。 所态：就是指一个类实例的"><meta name="keywords" content="java基础"><meta name="author" content="Mr.Xu"><meta name="copyright" content="Mr.Xu"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="dns-prefetch" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="dns-prefetch" href="https://fonts.googleapis.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="dns-prefetch" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="秋招复习之java基础"><meta name="twitter:description" content="秋招复习之java基础1、面对对象的理解面向对象易维护，易复用，易扩展。因为面向对象有封装、继承、多态三大特性，所以基于面对对象思想构建的程序具有低耦合、更灵活、易维护等特点 封装、继承、多态封装：也就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。 继承：是指可以让某个类型的对象获得另一个类型的对象的属性的方法。 所态：就是指一个类实例的"><meta name="twitter:image" content="https://gitee.com/xulilei/pic/raw/master/qiuzhao.jpg"><meta property="og:type" content="article"><meta property="og:title" content="秋招复习之java基础"><meta property="og:url" content="https://xulilei.github.io/2020/07/12/%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%E4%B9%8Bjava%E5%9F%BA%E7%A1%80/"><meta property="og:site_name" content="Humble"><meta property="og:description" content="秋招复习之java基础1、面对对象的理解面向对象易维护，易复用，易扩展。因为面向对象有封装、继承、多态三大特性，所以基于面对对象思想构建的程序具有低耦合、更灵活、易维护等特点 封装、继承、多态封装：也就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。 继承：是指可以让某个类型的对象获得另一个类型的对象的属性的方法。 所态：就是指一个类实例的"><meta property="og:image" content="https://gitee.com/xulilei/pic/raw/master/qiuzhao.jpg"><meta property="article:published_time" content="2020-07-12T08:15:47.000Z"><meta property="article:modified_time" content="2020-07-14T12:37:43.740Z"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="https://xulilei.github.io/2020/07/12/%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%E4%B9%8Bjava%E5%9F%BA%E7%A1%80/"><link rel="prev" title="秋招基础复习之IO" href="https://xulilei.github.io/2020/07/14/%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%E4%B9%8BIO/"><link rel="next" title="秋招基础复习之多线程（二）" href="https://xulilei.github.io/2020/07/11/%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B2/"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5/js/md5.min.js"></script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  bookmark: {
    message_prev: 'Press',
    message_next: 'to bookmark this page'
  },
  runtime_unit: 'days',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'false',
  isFontAwesomeV5: false,
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="Humble" type="application/atom+xml">
</head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">Articles</div><div class="length_num">26</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">Tags</div><div class="length_num">34</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">Categories</div><div class="length_num">3</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 档案</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#秋招复习之java基础"><span class="toc-number">1.</span> <span class="toc-text">秋招复习之java基础</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1、面对对象的理解"><span class="toc-number">1.0.1.</span> <span class="toc-text">1、面对对象的理解</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#封装、继承、多态"><span class="toc-number">1.0.1.1.</span> <span class="toc-text">封装、继承、多态</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2、JVM、JRE、JDK"><span class="toc-number">1.0.2.</span> <span class="toc-text">2、JVM、JRE、JDK</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3、基本数据类型"><span class="toc-number">1.0.3.</span> <span class="toc-text">3、基本数据类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4、重载、重写与重构的区别"><span class="toc-number">1.0.4.</span> <span class="toc-text">4、重载、重写与重构的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5、StringBuffer、StringBuilder、String"><span class="toc-number">1.0.5.</span> <span class="toc-text">5、StringBuffer、StringBuilder、String</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6、自动装箱与拆箱"><span class="toc-number">1.0.6.</span> <span class="toc-text">6、自动装箱与拆箱</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7、静态方法和非静态方法的区别"><span class="toc-number">1.0.7.</span> <span class="toc-text">7、静态方法和非静态方法的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#一、静态方法"><span class="toc-number">1.0.7.1.</span> <span class="toc-text">一、静态方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#二、非静态方法"><span class="toc-number">1.0.7.2.</span> <span class="toc-text">二、非静态方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#静态方法和非静态方法的区别（生命周期不同）"><span class="toc-number">1.0.7.3.</span> <span class="toc-text">静态方法和非静态方法的区别（生命周期不同）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8、空构造函数的作用"><span class="toc-number">1.0.8.</span> <span class="toc-text">8、空构造函数的作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9、接口和抽象类"><span class="toc-number">1.0.9.</span> <span class="toc-text">9、接口和抽象类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10、静态变量、成员变量和局部变量的区别"><span class="toc-number">1.0.10.</span> <span class="toc-text">10、静态变量、成员变量和局部变量的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#一、静态变量和成员变量的区别："><span class="toc-number">1.0.10.1.</span> <span class="toc-text">一、静态变量和成员变量的区别：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12、直接引用与符号引用"><span class="toc-number">1.0.11.</span> <span class="toc-text">12、直接引用与符号引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11、-与equals方法"><span class="toc-number">1.0.12.</span> <span class="toc-text">11、&#x3D;&#x3D;与equals方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12、重写equals方法为什么要重写hashcode"><span class="toc-number">1.0.13.</span> <span class="toc-text">12、重写equals方法为什么要重写hashcode()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13、java复制"><span class="toc-number">1.0.14.</span> <span class="toc-text">13、java复制</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#为什么说java只有值传递"><span class="toc-number">1.0.14.1.</span> <span class="toc-text">为什么说java只有值传递</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#浅拷贝"><span class="toc-number">1.0.14.2.</span> <span class="toc-text">浅拷贝</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#深拷贝"><span class="toc-number">1.0.14.3.</span> <span class="toc-text">深拷贝</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14、final关键字"><span class="toc-number">1.0.15.</span> <span class="toc-text">14、final关键字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#15、java异常体系"><span class="toc-number">1.0.16.</span> <span class="toc-text">15、java异常体系</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#异常分类"><span class="toc-number">1.0.16.1.</span> <span class="toc-text">异常分类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#处理方式"><span class="toc-number">1.0.16.2.</span> <span class="toc-text">处理方式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#try-catch"><span class="toc-number">1.0.16.3.</span> <span class="toc-text">try-catch</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16、java语言的反射机制"><span class="toc-number">1.0.17.</span> <span class="toc-text">16、java语言的反射机制</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#获取calss对象的三种方法"><span class="toc-number">1.0.17.1.</span> <span class="toc-text">获取calss对象的三种方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#获取类方法属性信息"><span class="toc-number">1.0.17.2.</span> <span class="toc-text">获取类方法属性信息</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#通过反射创建对象的方法"><span class="toc-number">1.0.17.3.</span> <span class="toc-text">通过反射创建对象的方法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#17、对象的序列化和反序列化"><span class="toc-number">1.0.18.</span> <span class="toc-text">17、对象的序列化和反序列化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#18、java泛型"><span class="toc-number">1.0.19.</span> <span class="toc-text">18、java泛型</span></a></li></ol></li></ol></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(https://gitee.com/xulilei/pic/raw/master/qiuzhao.jpg)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Humble</a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 档案</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">秋招复习之java基础</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="Created 2020-07-12 16:15:47"><i class="fa fa-calendar" aria-hidden="true"></i> Created 2020-07-12</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="Updated 2020-07-14 20:37:43"><i class="fa fa-history" aria-hidden="true"></i> Updated 2020-07-14</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E7%A7%8B%E6%8B%9B%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0/">秋招基础复习</a></span></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>Post View:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"><span class="post-meta__separator">|</span><i class="post-meta__icon fa fa-comment-o" aria-hidden="true"></i><span>Comments:</span><a href="/2020/07/12/%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%E4%B9%8Bjava%E5%9F%BA%E7%A1%80/#post-comment"><span class="gitalk-comment-count comment-count"></span></a></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h2 id="秋招复习之java基础"><a href="#秋招复习之java基础" class="headerlink" title="秋招复习之java基础"></a>秋招复习之java基础</h2><h4 id="1、面对对象的理解"><a href="#1、面对对象的理解" class="headerlink" title="1、面对对象的理解"></a>1、面对对象的理解</h4><p>面向对象易维护，易复用，易扩展。因为面向对象有封装、继承、多态三大特性，所以基于面对对象思想构建的程序具有低耦合、更灵活、易维护等特点</p>
<h5 id="封装、继承、多态"><a href="#封装、继承、多态" class="headerlink" title="封装、继承、多态"></a>封装、继承、多态</h5><p>封装：也就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。</p>
<p>继承：是指可以让某个类型的对象获得另一个类型的对象的属性的方法。</p>
<p>所态：就是指一个类实例的相同方法在不同情形有不同表现形式</p>
<h4 id="2、JVM、JRE、JDK"><a href="#2、JVM、JRE、JDK" class="headerlink" title="2、JVM、JRE、JDK"></a>2、JVM、JRE、JDK</h4><p>JVM：被称为java虚拟机，是运行java字节码的虚拟机</p>
<p>JRE：java运行时环境，包括JVM，Java类库，Java命令和其他一些基础组件</p>
<p>JDK：拥有JRE所拥有的一切，还有java编译器javac和工具</p>
<h4 id="3、基本数据类型"><a href="#3、基本数据类型" class="headerlink" title="3、基本数据类型"></a>3、基本数据类型</h4><p><img src="https://gitee.com/xulilei/pic/raw/master/6N89T@$E%60R3PM6%60_0GDV_AC.png" alt=""></p>
<h4 id="4、重载、重写与重构的区别"><a href="#4、重载、重写与重构的区别" class="headerlink" title="4、重载、重写与重构的区别"></a>4、重载、重写与重构的区别</h4><p>重载：发生在同一个类中，方法名必须相同，参数类型，个数，顺序，返回值类型，访问修饰符等都可以不同</p>
<p>重写：是子类对父类允许访问的方法的实现过程进行重新编写，发生在子类中，方法名、参数列表必须相同，返回值范围小于等于父类，访问修饰符范围大于等于父类，如果父类是private修饰的就不能重写该方法。也就是说方法提供的行为改变，而方法的外貌并没有改变</p>
<p>重构：是重写的一种特殊方式，子类与父类的成员方法的返回值、方法名称、参数类型及个数完全相同，唯一不同的是方法实现内容，这种特殊重写方式被称为重构。</p>
<h4 id="5、StringBuffer、StringBuilder、String"><a href="#5、StringBuffer、StringBuilder、String" class="headerlink" title="5、StringBuffer、StringBuilder、String"></a>5、StringBuffer、StringBuilder、String</h4><p>String：由final关键字修饰，即String对象是不可变的，线程安全</p>
<p>StringBuffer：对象可变，线程安全</p>
<p>StringBuilder：对象可变，线程不安全</p>
<h4 id="6、自动装箱与拆箱"><a href="#6、自动装箱与拆箱" class="headerlink" title="6、自动装箱与拆箱"></a>6、自动装箱与拆箱</h4><p>装箱：将基本数据类型用他们对应的引用类型包装起来</p>
<p>拆箱：将包装类型转换为基本数据类型</p>
<p>一种机制，使得这些基本类型在一般的编程中被当作非对象的简单类型处理，在另一些场合，又允许它们被视作是一个对象</p>
<h4 id="7、静态方法和非静态方法的区别"><a href="#7、静态方法和非静态方法的区别" class="headerlink" title="7、静态方法和非静态方法的区别"></a>7、静态方法和非静态方法的区别</h4><h5 id="一、静态方法"><a href="#一、静态方法" class="headerlink" title="一、静态方法"></a>一、静态方法</h5><p>是使用static关键字修饰的方法，又叫类方法。属于类的，不属于对象，在实例化对象之前就可以通过类名.方法名调用静态方法。<br>A.在静态方法中，可以调用静态方法。<br>B.在静态方法中，不能调用非静态方法。<br>C.在静态方法中，可以引用类变量（即，static修饰的变量）。<br>D.在静态方法中，不能引用成员变量（即，没有static修饰的变量）。<br>E.在静态方法中，不能使用super和this关键字</p>
<h5 id="二、非静态方法"><a href="#二、非静态方法" class="headerlink" title="二、非静态方法"></a>二、非静态方法</h5><p>是不含有static关键字修饰的普通方法，又称为实例方法，成员方法。属于对象的，不属于类的。成员方法是属于对象的，必须通过new关键字创建对象后，再通过对象调用<br>A.在普通方法中，可以调用普通方法。<br>B.在普通方法中，可以调用静态方法<br>C.在普通方法中，可以引用类变量和成员变量<br>D.在普通方法中，可以使用super和this关键字</p>
<h5 id="静态方法和非静态方法的区别（生命周期不同）"><a href="#静态方法和非静态方法的区别（生命周期不同）" class="headerlink" title="静态方法和非静态方法的区别（生命周期不同）"></a>静态方法和非静态方法的区别（生命周期不同）</h5><p>静态方法的生命周期跟相应的类一样长，静态方法和静态变量会随着类的定义而被分配和装载入内存中。一直到线程结束，静态属性和方法才会被销毁。（也就是静态方法属于类）<br>非静态方法的生命周期和类的实例化对象一样长，只有当类实例化了一个对象，非静态方法才会被创建，而当这个对象被销毁时，非静态方法也马上被销毁。（也就是非静态方法属于对象）</p>
<h4 id="8、空构造函数的作用"><a href="#8、空构造函数的作用" class="headerlink" title="8、空构造函数的作用"></a>8、空构造函数的作用</h4><p>构造函数的作用：当new一个对象的时候，调用构造函数完成对象的初始化</p>
<p>在类中如果没有参构造函数，系统会默认一个无参构造函数，此时写不写空构造没有影响。但如果父类只定义了有参构造，在子类的构造函数中，又没有通过super()来调用父类特定有参构造函数的情况下，将会发生编译错误。</p>
<h4 id="9、接口和抽象类"><a href="#9、接口和抽象类" class="headerlink" title="9、接口和抽象类"></a>9、接口和抽象类</h4><p>抽象类：抽象类不能实例化，即不能使用new关键字来实例化对象；抽象类可以含有抽象方法，也可以不包含抽象方法，抽象类中可以有具体的方法；抽象类中的抽象方法只有方法体，没有具体实现；</p>
<p>接口：接口不能被实例化；一个类只能继承一个类，但是可以实现多个接口；接口中方法可以为抽象方法，java8后接口也可以定义静态方法，可以直接通过接口名.方法调用</p>
<h4 id="10、静态变量、成员变量和局部变量的区别"><a href="#10、静态变量、成员变量和局部变量的区别" class="headerlink" title="10、静态变量、成员变量和局部变量的区别"></a>10、静态变量、成员变量和局部变量的区别</h4><h5 id="一、静态变量和成员变量的区别："><a href="#一、静态变量和成员变量的区别：" class="headerlink" title="一、静态变量和成员变量的区别："></a>一、静态变量和成员变量的区别：</h5><p>(1)所属不同：<br>　　　　静态变量：属于类，也称为类变量。<br>　　　　成员变量：属于对象，也称为对象变量或实例变量。<br>(2)在内存中的位置不同：<br>　　　　静态变量：存储于方法区/元空间。<br>　　　　成员变量：存储于堆内存。<br>(3)生命周期不同：<br>　　　　静态变量：静态变量是随着类的加载而加载，随着类的消失而消失。<br>　　　　成员变量：成员变量是随着对象的创建而存在，随着对象的消失而消失。<br>(4)调用不同：<br>　　　　静态变量：可以通过对象名调用，也可以通过类名调用。<br>　　　　成员变量：只能通过对象名调用。</p>
<p>二、成员变量和局部变量的区别：<br>(1)在类中的位置不同：<br>　　　　成员变量：在类中方法外。<br>　　　　局部变量：在方法定义中或者方法声明上(即形参)。<br>(2)在内存中的位置不同：<br>　　　　成员变量：在堆中。<br>　　　　局部变量：在栈中。<br>(3)生命周期不同：<br>　　　　成员变量：随着对象的创建而存在，随着对象的消失而消失。<br>　　　　局部变量：随着方法的调用而存在，随着方法的调用完毕而消失。<br>(4)初始化值不同：<br>　　　　成员变量：有默认值。<br>　　　　局部变量：没有默认值，必须定义，赋值，然后才能使用。</p>
<h4 id="12、直接引用与符号引用"><a href="#12、直接引用与符号引用" class="headerlink" title="12、直接引用与符号引用"></a>12、直接引用与符号引用</h4><p>符号引用：在编译时，java类并不知道所引用的类的实际地址，因此只能使用符号引用来代替。</p>
<p>直接引用：直接引用可以是直接指向目标的指针</p>
<h4 id="11、-与equals方法"><a href="#11、-与equals方法" class="headerlink" title="11、==与equals方法"></a>11、==与equals方法</h4><p>==：判断两个对象的地址是不是相等，即判断两个对象是不是同一个对象，基本数据类型比较的是值，引用数据类型比较的是内存地址</p>
<p>equals：若没有重写equals方法，则比较对象时，等价于“==”，若重写了equals，则等价于重写的相等的逻辑</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>{</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">            String a = <span class="keyword">new</span> String(<span class="string">"ab"</span>); <span class="comment">// a 为⼀个引⽤</span></span><br><span class="line">            String b = <span class="keyword">new</span> String(<span class="string">"ab"</span>); <span class="comment">// b为另⼀个引⽤,对象的内容⼀样</span></span><br><span class="line">            String aa = <span class="string">"ab"</span>; <span class="comment">// 放在常量池中</span></span><br><span class="line">            String bb = <span class="string">"ab"</span>; <span class="comment">// 从常量池中查找</span></span><br><span class="line">            <span class="comment">//true，同一对象</span></span><br><span class="line">            System.out.println(aa==bb);</span><br><span class="line">            <span class="comment">//false，非同一对象</span></span><br><span class="line">            System.out.println(a == b);</span><br><span class="line">            <span class="comment">//String对equals方法进行了重写，a的值与b的值相等</span></span><br><span class="line">            System.out.println(a.equals(b))；</span><br><span class="line">        }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="12、重写equals方法为什么要重写hashcode"><a href="#12、重写equals方法为什么要重写hashcode" class="headerlink" title="12、重写equals方法为什么要重写hashcode()"></a>12、重写equals方法为什么要重写hashcode()</h4><p>equals方法在没有被重写前，比较的是对象的内存地址，而重写后，可能不是同一对象的equals方法也相等</p>
<p>hashcode的作用是为了获取hash码，定位哈希表中索引的位置，是一个基于内存地址的int整数，而当重写了equals方法后，即使equals方法相等，hashcode也极大概率不等，这时如果我们用重写了equals方法的object作为hash表的key，那么会造成一个从hash表中取值为null的现象，因此需要重写equals方法，使得两者保持一致性</p>
<h4 id="13、java复制"><a href="#13、java复制" class="headerlink" title="13、java复制"></a>13、java复制</h4><h5 id="为什么说java只有值传递"><a href="#为什么说java只有值传递" class="headerlink" title="为什么说java只有值传递"></a>为什么说java只有值传递</h5><p>Java程序设计语言总是采用按值调用。也就是说，方法得到的是所有参数值的一个拷贝，方法不能修改传递给它的任何参数变量的内容。</p>
<p>值调用表示方法接收的是调用者提供的值，这种情况下方法引用的是该值的副本，在方法形成的栈中进行相关操作，而按引用调用表示方法接收的是被调用对象的地址的副本，对该副本的修改由于指向了原对象的地址，因此可以修改原对象的内容，但其本质仍然是操作副本，对副本进行的修改</p>
<h5 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h5><p>对基本数据类型进行值传递；如果该字段是引用类型的话，则复制引用但不复制引用的对象  ，因此原始对象及其副本引用同一个对象  </p>
<h5 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h5><p>对基本数据类型进行值传递；如果该字段是引用类型的话，则创建一个新的对象，并复制其内容，返回这个新的对象</p>
<h4 id="14、final关键字"><a href="#14、final关键字" class="headerlink" title="14、final关键字"></a>14、final关键字</h4><p>修饰变量：如果是基本数据类型，则其数值一旦在初始化后就不能更改；如果是引用类型的变量，则对齐初始化后边不能再指向另一个对象</p>
<p>修饰类：表明这个类不能被继承</p>
<p>修饰方法：防止该方法被继承，private方法都隐式都指定为final</p>
<h4 id="15、java异常体系"><a href="#15、java异常体系" class="headerlink" title="15、java异常体系"></a>15、java异常体系</h4><p><img src="https://gitee.com/xulilei/pic/raw/master/20200713160928.png" alt=""></p>
<p>如果某个方法不能按照正常的途径完成任务，就可以通过另一种路径退出方法。在这种情况下会抛出一个封装了错误信息的对象。此时，这个方法会立刻退出同时不返回任何值。另外，调用这个方法的其他代码也无法继续执行，异常处理机制会将代码执行交给异常处理器  </p>
<h5 id="异常分类"><a href="#异常分类" class="headerlink" title="异常分类"></a>异常分类</h5><p>Error：类是指 java 运行时系统的内部错误和资源耗尽错误。应用程序不会抛出该类对象。如果出现了这样的错误，除了告知用户，剩下的就是尽力使程序安全的终止。<br>Exception（RuntimeException、 CheckedException）：RuntimeException 如 ： NullPointerException、ClassCastException； 一个是检查异常CheckedException，如 I/O 错误导致的 IOException、 SQLException。</p>
<h5 id="处理方式"><a href="#处理方式" class="headerlink" title="处理方式"></a>处理方式</h5><p>抛出异常有三种形式，一是 throw,一个 throws，还有一种系统自动抛异常 ：</p>
<p>throws 用在函数上，后面跟的是异常类，可以跟多个； 而 throw 用在函数内，后面跟的是异常对象 </p>
<h5 id="try-catch"><a href="#try-catch" class="headerlink" title="try-catch"></a>try-catch</h5><p>try块：用于捕获异常，其后可跟0或多个catch块，如果没有catch块，则必须跟一个finally块</p>
<p>catch块：用于处理try捕获到的异常</p>
<p>finally块：无论是否捕获到或者处理了异常，finally块里的语句都会被执行,弱try或者catch语句有return语句时，finally中的语句会被执行，若有返回值会覆盖原始的返回值，如下例子，最终返回0</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> value)</span> </span>{</span><br><span class="line">   <span class="keyword">try</span> {</span><br><span class="line">      <span class="keyword">return</span> value * value;</span><br><span class="line">   } <span class="keyword">finally</span> {</span><br><span class="line">      <span class="keyword">if</span> (value == <span class="number">2</span>) {</span><br><span class="line">         <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      }</span><br><span class="line">     }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="16、java语言的反射机制"><a href="#16、java语言的反射机制" class="headerlink" title="16、java语言的反射机制"></a>16、java语言的反射机制</h4><p>指在运行状态中，对于任意一个类都能够知道这个类所有的属性和方法；并且对于任意一个对象，都能够调用它的任意一个方法；这种动态获取信息以及动态调用对象方法的功能称为 Java 语言的反射机制  </p>
<h5 id="获取calss对象的三种方法"><a href="#获取calss对象的三种方法" class="headerlink" title="获取calss对象的三种方法"></a>获取calss对象的三种方法</h5><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//1、调用某个对象的getClass()方法：</span></span><br><span class="line">    Person p=<span class="keyword">new</span> Person(); </span><br><span class="line">    Class clazz=p.getClass();</span><br><span class="line"><span class="comment">//2、调用某个类的 class 属性来获取该类对应的 Class 对象：如</span></span><br><span class="line">    Class clazz=Person<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line"><span class="comment">//3、使用 Class 类中的 forName()静态方法(最安全/性能最好/最常用) ：如</span></span><br><span class="line">    Class clazz=Class.forName(<span class="string">"类的全路径"</span>);</span><br></pre></td></tr></tbody></table></figure>

<h5 id="获取类方法属性信息"><a href="#获取类方法属性信息" class="headerlink" title="获取类方法属性信息"></a>获取类方法属性信息</h5><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//Field 类：Java.lang.reflec 包中的类，表示类的成员变量，可以用来获取和设置类之中的属性值</span></span><br><span class="line">Field[] field=clazz.getDeclaredFields(); </span><br><span class="line"><span class="keyword">for</span>(Field f:field){ </span><br><span class="line">    System.out.println(f.toString());</span><br><span class="line">}</span><br><span class="line"><span class="comment">//Method 类：Java.lang.reflec 包中的类，表示类的方法，它可以用来获取类中的方法信息或者执行方法</span></span><br><span class="line">Method[] method=clazz.getDeclaredMethods();</span><br><span class="line"><span class="keyword">for</span>(Method m:method){ </span><br><span class="line">    System.out.println(m.toString()); </span><br><span class="line">}</span><br><span class="line"><span class="comment">//Constructor 类：Java.lang.reflec 包中的类，表示类的构造方法</span></span><br><span class="line">Constructor[] constructor=clazz.getDeclaredConstructors(); </span><br><span class="line"><span class="keyword">for</span>(Constructor c:constructor){ </span><br><span class="line">    System.out.println(c.toString()); </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h5 id="通过反射创建对象的方法"><a href="#通过反射创建对象的方法" class="headerlink" title="通过反射创建对象的方法"></a>通过反射创建对象的方法</h5><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//1、使用 Class 对象的 newInstance()方法来创建该 Class 对象对应类的实例，但是这种方法要求 该 Class 对象对应的类有默认的空构造器</span></span><br><span class="line">Person p=(Person) clazz.newInstance();</span><br><span class="line"><span class="comment">//2、先使用 Class 对象获取指定的 Constructor 对象，再调用 Constructor 对象的 newInstance() 方法来创建 Class 对象对应类的实例</span></span><br><span class="line">Constructor c=clazz.getDeclaredConstructor(String<span class="class">.<span class="keyword">class</span>,<span class="title">String</span>.<span class="title">class</span>,<span class="title">int</span>.<span class="title">class</span>)</span>;</span><br><span class="line">Person p1=(Person) c.newInstance(<span class="string">"李四"</span>,<span class="string">"男"</span>,<span class="number">20</span>);</span><br></pre></td></tr></tbody></table></figure>

<h4 id="17、对象的序列化和反序列化"><a href="#17、对象的序列化和反序列化" class="headerlink" title="17、对象的序列化和反序列化"></a>17、对象的序列化和反序列化</h4><p>序列化：把对象转换为字节序列的过程称为对象的序列化。保存(持久化)指定的对象，并在将来重新读取被保存的对象。  </p>
<p>反序列化：把字节序列恢复为对象的过程称为对象的反序列化</p>
<p>对于不想序列化的变量，使用transient关键词修饰</p>
<h4 id="18、java泛型"><a href="#18、java泛型" class="headerlink" title="18、java泛型"></a>18、java泛型</h4><p>泛型，即“参数化类型”。就是将类型由原来的具体的类型参数化</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script></div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Mr.Xu</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://xulilei.github.io/2020/07/12/%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%E4%B9%8Bjava%E5%9F%BA%E7%A1%80/">https://xulilei.github.io/2020/07/12/%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%E4%B9%8Bjava%E5%9F%BA%E7%A1%80/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/java%E5%9F%BA%E7%A1%80/">java基础</a></div><div class="post_share"><div class="social-share" data-image="https://gitee.com/xulilei/pic/raw/master/qiuzhao.jpg" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> Donate<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="post-qr-code__img" src="/img/wechat.jpg" alt="微信"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="post-qr-code__img" src="/img/alipay.jpg" alt="支付寶"/><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/07/14/%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%E4%B9%8BIO/"><img class="prev_cover" src="https://gitee.com/xulilei/pic/raw/master/qiuzhao.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">秋招基础复习之IO</div></div></a></div><div class="next-post pull_right"><a href="/2020/07/11/%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B2/"><img class="next_cover" src="https://gitee.com/xulilei/pic/raw/master/qiuzhao.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">秋招基础复习之多线程（二）</div></div></a></div></nav><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> Comment</span></div><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: '6110470d5d42e0d5f62f',
  clientSecret: '7bdc5cd9b7ddf22caed3be7d9c05afecb628c90f',
  repo: 'xulilei.github.io',
  owner: 'xulilei',
  admin: ['xulilei'],
  id: md5(decodeURI(location.pathname)),
  language: 'zh-CN',
  perPage: 10,
  distractionFreeMode: true,
  pagerDirection: 'last',
  createIssueManually: true,
  updateCountCallback: commentCount
})
gitalk.render('gitalk-container')

function commentCount(n){
  try {
    document.getElementsByClassName('gitalk-comment-count')[0].innerHTML= n
  } catch (e) {
    return false
  }
}</script></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 By Mr.Xu</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="Read Mode"></i><i class="fa fa-plus" id="font_plus" title="Increase font size"></i><i class="fa fa-minus" id="font_minus" title="Decrease font size"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="Traditional Chinese and Simplified Chinese Conversion" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="Dark Mode"></i></div><div id="rightside-config-show"><div id="rightside_config" title="Setting"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="Scroll to comment"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="Table of Contents" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="Back to top" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script defer id="ribbon" src="/js/third-party/canvas-ribbon.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@3/instantpage.min.js" type="module"></script></body></html>