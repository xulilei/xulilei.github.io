<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>java基础（一） | Humble</title><meta name="description" content="秋招复习之java基础JAVA概述1、JVM、JRE、JDKJVM：被称为java虚拟机，是运行java字节码的虚拟机 JRE：java运行时环境，包括JVM，Java类库，Java命令和其他一些基础组件 JDK：拥有JRE所拥有的一切，还有java编译器javac和工具 2、什么是字节码？好处是什么？字节码是经过java虚拟机编译后形成的.class文件，不面向平台，只面向对应的虚拟机，因此ja"><meta name="keywords" content="java基础"><meta name="author" content="Mr.Xu"><meta name="copyright" content="Mr.Xu"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="dns-prefetch" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="dns-prefetch" href="https://fonts.googleapis.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="dns-prefetch" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="java基础（一）"><meta name="twitter:description" content="秋招复习之java基础JAVA概述1、JVM、JRE、JDKJVM：被称为java虚拟机，是运行java字节码的虚拟机 JRE：java运行时环境，包括JVM，Java类库，Java命令和其他一些基础组件 JDK：拥有JRE所拥有的一切，还有java编译器javac和工具 2、什么是字节码？好处是什么？字节码是经过java虚拟机编译后形成的.class文件，不面向平台，只面向对应的虚拟机，因此ja"><meta name="twitter:image" content="https://gitee.com/xulilei/pic/raw/master/qiuzhao.jpg"><meta property="og:type" content="article"><meta property="og:title" content="java基础（一）"><meta property="og:url" content="https://xulilei.github.io/2020/07/12/%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%E4%B9%8Bjava%E5%9F%BA%E7%A1%80/"><meta property="og:site_name" content="Humble"><meta property="og:description" content="秋招复习之java基础JAVA概述1、JVM、JRE、JDKJVM：被称为java虚拟机，是运行java字节码的虚拟机 JRE：java运行时环境，包括JVM，Java类库，Java命令和其他一些基础组件 JDK：拥有JRE所拥有的一切，还有java编译器javac和工具 2、什么是字节码？好处是什么？字节码是经过java虚拟机编译后形成的.class文件，不面向平台，只面向对应的虚拟机，因此ja"><meta property="og:image" content="https://gitee.com/xulilei/pic/raw/master/qiuzhao.jpg"><meta property="article:published_time" content="2020-07-12T08:15:47.000Z"><meta property="article:modified_time" content="2020-09-16T13:11:08.245Z"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="https://xulilei.github.io/2020/07/12/%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%E4%B9%8Bjava%E5%9F%BA%E7%A1%80/"><link rel="prev" title="IO模型" href="https://xulilei.github.io/2020/07/14/%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%E4%B9%8BIO/"><link rel="next" title="多线程（二）" href="https://xulilei.github.io/2020/07/11/%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B2/"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5/js/md5.min.js"></script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  bookmark: {
    message_prev: 'Press',
    message_next: 'to bookmark this page'
  },
  runtime_unit: 'days',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'false',
  isFontAwesomeV5: false,
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="Humble" type="application/atom+xml">
</head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">Articles</div><div class="length_num">40</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">Tags</div><div class="length_num">44</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">Categories</div><div class="length_num">4</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 档案</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#秋招复习之java基础"><span class="toc-number">1.</span> <span class="toc-text">秋招复习之java基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JAVA概述"><span class="toc-number">1.1.</span> <span class="toc-text">JAVA概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1、JVM、JRE、JDK"><span class="toc-number">1.1.1.</span> <span class="toc-text">1、JVM、JRE、JDK</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2、什么是字节码？好处是什么？"><span class="toc-number">1.1.2.</span> <span class="toc-text">2、什么是字节码？好处是什么？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3、java中的编译器和解释器"><span class="toc-number">1.2.</span> <span class="toc-text">3、java中的编译器和解释器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4、java和c-的区别"><span class="toc-number">1.2.1.</span> <span class="toc-text">4、java和c++的区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#基础语法"><span class="toc-number">1.3.</span> <span class="toc-text">基础语法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1、数据类型"><span class="toc-number">1.3.1.</span> <span class="toc-text">1、数据类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2、switch-是否能作用在-byte-上，是否能作用在-long-上，是否能作用在-String-上"><span class="toc-number">1.3.2.</span> <span class="toc-text">2、switch 是否能作用在 byte 上，是否能作用在 long 上，是否能作用在 String 上</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3、Math-round-11-5-等于多少？Math-round-11-5-等于多少"><span class="toc-number">1.3.3.</span> <span class="toc-text">3、Math.round(11.5) 等于多少？Math.round(-11.5)等于多少</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4、float-3-4是否正确？"><span class="toc-number">1.3.4.</span> <span class="toc-text">4、float&#x3D;3.4是否正确？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5、short-s1-1-s1-s1-1有错吗-short-s1-1-s1-1有错吗？"><span class="toc-number">1.3.5.</span> <span class="toc-text">5、short s1 &#x3D; 1; s1 &#x3D; s1 + 1有错吗?short s1 &#x3D; 1; s1 +&#x3D; 1有错吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6、JAVA采用何种编码？特点？"><span class="toc-number">1.3.6.</span> <span class="toc-text">6、JAVA采用何种编码？特点？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7、访问修饰符"><span class="toc-number">1.3.7.</span> <span class="toc-text">7、访问修饰符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8、-amp-和-amp-amp-的区别"><span class="toc-number">1.3.8.</span> <span class="toc-text">8、&amp;和&amp;&amp;的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9、final关键字"><span class="toc-number">1.3.9.</span> <span class="toc-text">9、final关键字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10、final、finally、finalize区别"><span class="toc-number">1.3.10.</span> <span class="toc-text">10、final、finally、finalize区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11、this和super"><span class="toc-number">1.3.11.</span> <span class="toc-text">11、this和super</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12、break、continue、return"><span class="toc-number">1.3.12.</span> <span class="toc-text">12、break、continue、return</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13、自动装箱与拆箱"><span class="toc-number">1.3.13.</span> <span class="toc-text">13、自动装箱与拆箱</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#面向对象"><span class="toc-number">1.4.</span> <span class="toc-text">面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1、面对对象的理解"><span class="toc-number">1.4.1.</span> <span class="toc-text">1、面对对象的理解</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#封装、继承、多态"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">封装、继承、多态</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2、面对过程"><span class="toc-number">1.4.2.</span> <span class="toc-text">2、面对过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3、面对对象的五大原则"><span class="toc-number">1.4.3.</span> <span class="toc-text">3、面对对象的五大原则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4、重载、重写与重构的区别"><span class="toc-number">1.4.4.</span> <span class="toc-text">4、重载、重写与重构的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5、接口和抽象类"><span class="toc-number">1.4.5.</span> <span class="toc-text">5、接口和抽象类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6、对象实例和对象引用的区别"><span class="toc-number">1.4.6.</span> <span class="toc-text">6、对象实例和对象引用的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7、static静态"><span class="toc-number">1.4.7.</span> <span class="toc-text">7、static静态</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#主要意义"><span class="toc-number">1.4.7.1.</span> <span class="toc-text">主要意义</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#用法"><span class="toc-number">1.4.7.2.</span> <span class="toc-text">用法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8、静态变量、成员变量和局部变量的区别"><span class="toc-number">1.4.8.</span> <span class="toc-text">8、静态变量、成员变量和局部变量的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9、空构造函数的作用"><span class="toc-number">1.4.9.</span> <span class="toc-text">9、空构造函数的作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10、内部类"><span class="toc-number">1.4.10.</span> <span class="toc-text">10、内部类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#静态内部类"><span class="toc-number">1.4.10.1.</span> <span class="toc-text">静态内部类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#成员内部类"><span class="toc-number">1.4.10.2.</span> <span class="toc-text">成员内部类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#局部内部类"><span class="toc-number">1.4.10.3.</span> <span class="toc-text">局部内部类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#匿名内部类"><span class="toc-number">1.4.10.4.</span> <span class="toc-text">匿名内部类</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11、为什么要使用内部类，哪些应用场景"><span class="toc-number">1.4.11.</span> <span class="toc-text">11、为什么要使用内部类，哪些应用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12、-与equals方法"><span class="toc-number">1.4.12.</span> <span class="toc-text">12、&#x3D;&#x3D;与equals方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13、重写equals方法为什么要重写hashcode"><span class="toc-number">1.4.13.</span> <span class="toc-text">13、重写equals方法为什么要重写hashcode()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14、为什么说java只有值传递"><span class="toc-number">1.4.14.</span> <span class="toc-text">14、为什么说java只有值传递</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#15、浅拷贝、深拷贝"><span class="toc-number">1.4.15.</span> <span class="toc-text">15、浅拷贝、深拷贝</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16、直接引用与符号引用"><span class="toc-number">1.4.16.</span> <span class="toc-text">16、直接引用与符号引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#17、对象的序列化和反序列化"><span class="toc-number">1.4.17.</span> <span class="toc-text">17、对象的序列化和反序列化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#18、java泛型"><span class="toc-number">1.4.18.</span> <span class="toc-text">18、java泛型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#19、Comparator和Comparable的区别"><span class="toc-number">1.4.19.</span> <span class="toc-text">19、Comparator和Comparable的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#20、泛型"><span class="toc-number">1.4.20.</span> <span class="toc-text">20、泛型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#21、静态内部类"><span class="toc-number">1.4.21.</span> <span class="toc-text">21、静态内部类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String相关"><span class="toc-number">1.5.</span> <span class="toc-text">String相关</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1、StringBuffer、StringBuilder、String"><span class="toc-number">1.5.1.</span> <span class="toc-text">1、StringBuffer、StringBuilder、String</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2、字符串常量池"><span class="toc-number">1.5.2.</span> <span class="toc-text">2、字符串常量池</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3、String-str-”i”与-String-str-new-String-“i”-一样吗？"><span class="toc-number">1.5.3.</span> <span class="toc-text">3、String str&#x3D;”i”与 String str&#x3D;new String(“i”)一样吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4、String-s-new-String-“xyz”-创建了几个字符串对象"><span class="toc-number">1.5.4.</span> <span class="toc-text">4、String s &#x3D; new String(“xyz”);创建了几个字符串对象</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#异常反射机制"><span class="toc-number">1.6.</span> <span class="toc-text">异常反射机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1、java异常体系"><span class="toc-number">1.6.1.</span> <span class="toc-text">1、java异常体系</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#异常分类"><span class="toc-number">1.6.1.1.</span> <span class="toc-text">异常分类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#处理方式"><span class="toc-number">1.6.1.2.</span> <span class="toc-text">处理方式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#try-catch"><span class="toc-number">1.6.1.3.</span> <span class="toc-text">try-catch</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2、java语言的反射机制"><span class="toc-number">1.6.2.</span> <span class="toc-text">2、java语言的反射机制</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#获取calss对象的三种方法"><span class="toc-number">1.6.2.1.</span> <span class="toc-text">获取calss对象的三种方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#获取类方法属性信息"><span class="toc-number">1.6.2.2.</span> <span class="toc-text">获取类方法属性信息</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#通过反射创建对象的方法"><span class="toc-number">1.6.2.3.</span> <span class="toc-text">通过反射创建对象的方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JAVA8新特性"><span class="toc-number">1.7.</span> <span class="toc-text">JAVA8新特性</span></a></li></ol></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(https://gitee.com/xulilei/pic/raw/master/qiuzhao.jpg)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Humble</a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 档案</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">java基础（一）</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="Created 2020-07-12 16:15:47"><i class="fa fa-calendar" aria-hidden="true"></i> Created 2020-07-12</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="Updated 2020-09-16 21:11:08"><i class="fa fa-history" aria-hidden="true"></i> Updated 2020-09-16</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0/">秋招复习</a></span></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>Post View:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"><span class="post-meta__separator">|</span><i class="post-meta__icon fa fa-comment-o" aria-hidden="true"></i><span>Comments:</span><a href="/2020/07/12/%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%E4%B9%8Bjava%E5%9F%BA%E7%A1%80/#post-comment"><span class="gitalk-comment-count comment-count"></span></a></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h2 id="秋招复习之java基础"><a href="#秋招复习之java基础" class="headerlink" title="秋招复习之java基础"></a>秋招复习之java基础</h2><h3 id="JAVA概述"><a href="#JAVA概述" class="headerlink" title="JAVA概述"></a>JAVA概述</h3><h4 id="1、JVM、JRE、JDK"><a href="#1、JVM、JRE、JDK" class="headerlink" title="1、JVM、JRE、JDK"></a>1、JVM、JRE、JDK</h4><p>JVM：被称为java虚拟机，是运行java字节码的虚拟机</p>
<p>JRE：java运行时环境，包括JVM，Java类库，Java命令和其他一些基础组件</p>
<p>JDK：拥有JRE所拥有的一切，还有java编译器javac和工具</p>
<h4 id="2、什么是字节码？好处是什么？"><a href="#2、什么是字节码？好处是什么？" class="headerlink" title="2、什么是字节码？好处是什么？"></a>2、什么是字节码？好处是什么？</h4><p>字节码是经过java虚拟机编译后形成的.class文件，不面向平台，只面向对应的虚拟机，因此java程序无需重新编译即可在不同的平台运行</p>
<h3 id="3、java中的编译器和解释器"><a href="#3、java中的编译器和解释器" class="headerlink" title="3、java中的编译器和解释器"></a>3、java中的编译器和解释器</h3><p>java源代码先经过编译器编译成虚拟机能够理解的代码，再由解释器解析在特定的环境中运行</p>
<h4 id="4、java和c-的区别"><a href="#4、java和c-的区别" class="headerlink" title="4、java和c++的区别"></a>4、java和c++的区别</h4><p>1、都是面向对象的语言，都支持继承封装，多态三大特性</p>
<p>2、java不提供指针直接操作内存，相比C++更加安全</p>
<p>3、java类是单继承原则，c++可以多继承</p>
<h3 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h3><h4 id="1、数据类型"><a href="#1、数据类型" class="headerlink" title="1、数据类型"></a>1、数据类型</h4><p>引用数据类型：类，接口，数组</p>
<p>基本数据类型：整型4个，浮点型2个，字符型1个，布尔型1个。</p>
<p><img src="https://gitee.com/xulilei/pic/raw/master/6N89T@$E%60R3PM6%60_0GDV_AC.png" alt=""></p>
<h4 id="2、switch-是否能作用在-byte-上，是否能作用在-long-上，是否能作用在-String-上"><a href="#2、switch-是否能作用在-byte-上，是否能作用在-long-上，是否能作用在-String-上" class="headerlink" title="2、switch 是否能作用在 byte 上，是否能作用在 long 上，是否能作用在 String 上"></a>2、switch 是否能作用在 byte 上，是否能作用在 long 上，是否能作用在 String 上</h4><p>switch语句可以执行byte，short，int，char，string，枚举类型，但是目前为止不支持长整形</p>
<h4 id="3、Math-round-11-5-等于多少？Math-round-11-5-等于多少"><a href="#3、Math-round-11-5-等于多少？Math-round-11-5-等于多少" class="headerlink" title="3、Math.round(11.5) 等于多少？Math.round(-11.5)等于多少"></a>3、Math.round(11.5) 等于多少？Math.round(-11.5)等于多少</h4><p>计算规则，+0.5取整，因此前者为12，后者为-11</p>
<h4 id="4、float-3-4是否正确？"><a href="#4、float-3-4是否正确？" class="headerlink" title="4、float=3.4是否正确？"></a>4、float=3.4是否正确？</h4><p>3.4是双精度型，双精度型赋值给单精度型是向下赋值，会造成精度丢失，因此需要强转，float f =(float)3.4或者float f =3.4F</p>
<h4 id="5、short-s1-1-s1-s1-1有错吗-short-s1-1-s1-1有错吗？"><a href="#5、short-s1-1-s1-s1-1有错吗-short-s1-1-s1-1有错吗？" class="headerlink" title="5、short s1 = 1; s1 = s1 + 1有错吗?short s1 = 1; s1 += 1有错吗？"></a>5、short s1 = 1; s1 = s1 + 1有错吗?short s1 = 1; s1 += 1有错吗？</h4><p>s1=1，1+1位int型，因此需要强转，错误</p>
<p>s1+=1，隐含了s1=（short）（s1+1），因此正确</p>
<h4 id="6、JAVA采用何种编码？特点？"><a href="#6、JAVA采用何种编码？特点？" class="headerlink" title="6、JAVA采用何种编码？特点？"></a>6、JAVA采用何种编码？特点？</h4><p>java采用Unicode标准码编码，为每个字符指定了唯一的数值，因此可以在任意平台放心使用</p>
<h4 id="7、访问修饰符"><a href="#7、访问修饰符" class="headerlink" title="7、访问修饰符"></a>7、访问修饰符</h4><p>private：在同一类内可见，可以修饰方法，变量，内部类（外部类不可以）</p>
<p>protected：同一包可见，外包子类可见，修饰方法，变量，内部类（不能修饰外部类）</p>
<p>default（即缺省，不加关键字修饰）：在同一包中可见，外包子类不可见，修饰方法，变量，类，接口</p>
<p>public：所有可见</p>
<h4 id="8、-amp-和-amp-amp-的区别"><a href="#8、-amp-和-amp-amp-的区别" class="headerlink" title="8、&amp;和&amp;&amp;的区别"></a>8、&amp;和&amp;&amp;的区别</h4><p>逻辑与(&amp;)和短路与(&amp;&amp;)在运算上对条件的结果判断不会产生影响,但会对条件判断的运算有影响</p>
<p>关键在于,逻辑与(&amp;)在运算时会连续运算所有需要判断的命令.但短路与当遇到false时就会停止运算</p>
<p>同样的，逻辑或运算符（|）和短路或运算符（||）的差别也是如此。</p>
<h4 id="9、final关键字"><a href="#9、final关键字" class="headerlink" title="9、final关键字"></a>9、final关键字</h4><p>修饰变量：如果是基本数据类型，则其数值一旦在初始化后就不能更改；如果是引用类型的变量，则对其初始化后就不能再指向另一个对象</p>
<p>修饰类：表明这个类不能被继承</p>
<p>修饰方法：防止该方法被重写，private方法都隐式都指定为final</p>
<h4 id="10、final、finally、finalize区别"><a href="#10、final、finally、finalize区别" class="headerlink" title="10、final、finally、finalize区别"></a>10、final、finally、finalize区别</h4><p>final：看9</p>
<p>finally：一般用作try-catch块中，通常将一定要执行的代码方法finally代码块中，表示不管有没有异常，该部分逻辑都要执行</p>
<p>finalize：是垃圾回收期在GC时调用</p>
<h4 id="11、this和super"><a href="#11、this和super" class="headerlink" title="11、this和super"></a>11、this和super</h4><p>this是代表指向自身的对象，可以理解为一个指向本身的一个指针</p>
<p>super是指向离自己最近的父类对象</p>
<p>在构造函数中使用时，都需放在构造函数的第一行，且不能在同一个构造函数中同时使用super和this</p>
<p>静态方法中不能使用super和this关键字</p>
<h4 id="12、break、continue、return"><a href="#12、break、continue、return" class="headerlink" title="12、break、continue、return"></a>12、break、continue、return</h4><p>break：跳传当前的循环体，要退出多层嵌套循环，可以在循环外定一个标志位，使用break+标志位退出到标志点</p>
<p>continue：跳传本次循环，继续执行下次循环</p>
<p>return：程序返回，不再执行下面的代码</p>
<h4 id="13、自动装箱与拆箱"><a href="#13、自动装箱与拆箱" class="headerlink" title="13、自动装箱与拆箱"></a>13、自动装箱与拆箱</h4><p>装箱：将基本数据类型用他们对应的引用类型包装起来</p>
<p>拆箱：将包装类型转换为基本数据类型</p>
<p>一种机制，使得这些基本类型在一般的编程中被当作非对象的简单类型处理，在另一些场合，又允许它们被视作是一个对象</p>
<h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><h4 id="1、面对对象的理解"><a href="#1、面对对象的理解" class="headerlink" title="1、面对对象的理解"></a>1、面对对象的理解</h4><p>面向对象易维护，易复用，易扩展。因为面向对象有封装、继承、多态三大特性，所以基于面对对象思想构建的程序具有低耦合、更灵活、易维护等特点</p>
<h5 id="封装、继承、多态"><a href="#封装、继承、多态" class="headerlink" title="封装、继承、多态"></a>封装、继承、多态</h5><p>封装：把一个对象的属性私有化，同时提供一些可以被外界访问属性的方法</p>
<p>继承：是指可以让某个类型的对象获得另一个类型的对象的属性的方法。</p>
<p>多态：就是指一个类实例的相同方法在不同情形有不同表现形式，多态的三个必要条件：继承、重写、向上转型</p>
<h4 id="2、面对过程"><a href="#2、面对过程" class="headerlink" title="2、面对过程"></a>2、面对过程</h4><p>优点：由于面向对象需要实例化对象，维护对象之间的关系，因此面对过程效率比面向对象高，开销少，比如linux，单片机等都是面对过程开发</p>
<p>缺点：面对对象的优点就是面对过程的缺点，比如不易复用，不易维护，不易扩展</p>
<h4 id="3、面对对象的五大原则"><a href="#3、面对对象的五大原则" class="headerlink" title="3、面对对象的五大原则"></a>3、面对对象的五大原则</h4><p>单一职责原则：类的功能要单一</p>
<p>开闭原则：对于拓展是开放的，对于修改是封闭的</p>
<p>里氏替换原则：子类可以替换父类出现在父类能够出现的任何地方、</p>
<p>依赖倒置原则：低层次模块要依赖高层次模块，具体依赖抽象</p>
<p>接口分离原则：拆分不同功能到不同的接口中</p>
<h4 id="4、重载、重写与重构的区别"><a href="#4、重载、重写与重构的区别" class="headerlink" title="4、重载、重写与重构的区别"></a>4、重载、重写与重构的区别</h4><p>重载：发生在同一个类中，方法名必须相同，参数类型，个数，顺序，返回值类型，访问修饰符等都可以不同</p>
<p>重写：是子类对父类允许访问的方法的实现过程进行重新编写，发生在子类中，方法名、参数列表必须相同，返回值范围小于等于父类，访问修饰符范围大于等于父类，如果父类是private修饰的就不能重写该方法。也就是说方法提供的行为改变，而方法的外貌并没有改变</p>
<p>重构：是重写的一种特殊方式，子类与父类的成员方法的返回值、方法名称、参数类型及个数完全相同，唯一不同的是方法实现内容，这种特殊重写方式被称为重构。</p>
<h4 id="5、接口和抽象类"><a href="#5、接口和抽象类" class="headerlink" title="5、接口和抽象类"></a>5、接口和抽象类</h4><p>以JDK1.8为基准</p>
<p>相同点：二者都不能被实例化，只能实例化实现或者继承他们的类，接口可以有静态方法，抽象类一直都可以有</p>
<p>不同点：1、接口中变量只能是publis static final类型的，而抽象类中的变量可以任意修饰 2、接口中不能有构造函数，抽象类中可以有 3、抽象类可以用除了private之外的修饰符修饰，而接口只能使用public4、类只能继承一个类，但可以实现多个接口</p>
<h4 id="6、对象实例和对象引用的区别"><a href="#6、对象实例和对象引用的区别" class="headerlink" title="6、对象实例和对象引用的区别"></a>6、对象实例和对象引用的区别</h4><p>对象实例存放在堆内存中，可以有n个引用指向他。而对象引用存放在栈内存中，可以指向0或者1个对象实例</p>
<h4 id="7、static静态"><a href="#7、static静态" class="headerlink" title="7、static静态"></a>7、static静态</h4><h5 id="主要意义"><a href="#主要意义" class="headerlink" title="主要意义"></a>主要意义</h5><p>用于创立独立于具体对象之外的变量和方法，以至于不实例化对象，就可以使用属性和方法</p>
<p>由于生命周期从属于类，因此static修饰的代码只会被执行一次，可用于优化代码</p>
<p>static修饰的变量属于类变量，存放在方法区/元空间中，被该类的对象共享</p>
<h5 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h5><p>静态只能访问静态，非静态可以访问静态也可以访问非静态</p>
<p>静态可以不用实例化，直接通过类名.属性名或者方法名调用，生命周期从属于类</p>
<p>非静态必须要实例化对象后，通过对象调用，生命周期从属于对象</p>
<h4 id="8、静态变量、成员变量和局部变量的区别"><a href="#8、静态变量、成员变量和局部变量的区别" class="headerlink" title="8、静态变量、成员变量和局部变量的区别"></a>8、静态变量、成员变量和局部变量的区别</h4><ul>
<li>所属不同：<ul>
<li>静态变量：属于类，也称为类变量</li>
<li>成员变量：属于对象，也称为对象变量或实例变量。</li>
<li>局部变量：属于方法      </li>
</ul>
</li>
<li>在内存中的位置不同：<ul>
<li>静态变量：存储于方法区/元空间。</li>
<li>成员变量：存储于堆内存</li>
<li>局部变量：存储于栈，随着方法结束自动回收                                                                                    </li>
</ul>
</li>
<li>生命周期不同：<ul>
<li>静态变量：随着类的加载而加载，随着类的消失而消失。</li>
<li>成员变量：存在于类中方法外，随着对象的创建而存在，随着对象的消失而消失。</li>
<li>局部变量：存在于方法内部，随着方法的调用而存在，随着方法的调用完毕而消失</li>
</ul>
</li>
<li>调用不同：<ul>
<li>静态变量：可以通过对象名调用，也可以通过类名调用</li>
<li>成员变量：只能通过对象名调用</li>
<li>局部变量：方法外部无法调用</li>
</ul>
</li>
<li>初始值不同：<ul>
<li>静态变量：有默认值</li>
<li>成员变量：有默认值</li>
<li>局部变量：么有默认值，必须先赋值</li>
</ul>
</li>
</ul>
<h4 id="9、空构造函数的作用"><a href="#9、空构造函数的作用" class="headerlink" title="9、空构造函数的作用"></a>9、空构造函数的作用</h4><p>构造函数的作用：当new一个对象的时候，调用构造函数完成对象的初始化</p>
<p>在类中如果没有参构造函数，系统会默认一个无参构造函数，此时写不写空构造没有影响。但如果父类只定义了有参构造，在子类的构造函数中，又没有通过super()来调用父类特定有参构造函数的情况下，将会发生编译错误。</p>
<h4 id="10、内部类"><a href="#10、内部类" class="headerlink" title="10、内部类"></a>10、内部类</h4><h5 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h5><p>类内部由static修饰的类，需要通过outer.inner inner=new outer.inner();实例化</p>
<h5 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h5><p>类内部非static类，需要先实例化外部类，在通过外部类对象outer.inner inner=outer.new inner()实例化</p>
<h5 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h5><p>定义在方法中的内部类，就是局部内部类。需要在方法中实例化这个类，并调用这个类的方法</p>
<h5 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h5><p>匿名内部类就是没有名字的内部类，匿名内部类必须继承一个抽象类或者实现一个接口。</p>
<h4 id="11、为什么要使用内部类，哪些应用场景"><a href="#11、为什么要使用内部类，哪些应用场景" class="headerlink" title="11、为什么要使用内部类，哪些应用场景"></a>11、为什么要使用内部类，哪些应用场景</h4><p>1、内部类可以访问创建它的外部类的属性</p>
<p>2、内部类不为同一包的其他类所见，有很好的封装性</p>
<p>3、内部类拓展了多重继承，优化了类单继承的缺陷</p>
<p>使用场景是某个类只会被它的外部类调用的时候</p>
<h4 id="12、-与equals方法"><a href="#12、-与equals方法" class="headerlink" title="12、==与equals方法"></a>12、==与equals方法</h4><p>==：判断两个对象的地址是不是相等，即判断两个对象是不是同一个对象，基本数据类型比较的是值，引用数据类型比较的是内存地址</p>
<p>equals：若没有重写equals方法，则比较对象时，等价于“==”，若重写了equals，则等价于重写的相等的逻辑</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">            String a = <span class="keyword">new</span> String(<span class="string">"ab"</span>); <span class="comment">// a 为⼀个引⽤</span></span><br><span class="line">            String b = <span class="keyword">new</span> String(<span class="string">"ab"</span>); <span class="comment">// b为另⼀个引⽤,对象的内容⼀样</span></span><br><span class="line">            String aa = <span class="string">"ab"</span>; <span class="comment">// 放在常量池中</span></span><br><span class="line">            String bb = <span class="string">"ab"</span>; <span class="comment">// 从常量池中查找</span></span><br><span class="line">            <span class="comment">//true，同一对象</span></span><br><span class="line">            System.out.println(aa==bb);</span><br><span class="line">            <span class="comment">//false，非同一对象</span></span><br><span class="line">            System.out.println(a == b);</span><br><span class="line">            <span class="comment">//String对equals方法进行了重写，a的值与b的值相等</span></span><br><span class="line">            System.out.println(a.equals(b))；</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="13、重写equals方法为什么要重写hashcode"><a href="#13、重写equals方法为什么要重写hashcode" class="headerlink" title="13、重写equals方法为什么要重写hashcode()"></a>13、重写equals方法为什么要重写hashcode()</h4><p>hashcode值是基于对象内存地址和内容得到的值，作用是获取hash码定位哈希表中索引的位置</p>
<p>如果两个对象相等，那么他们的hashcode值一定是相同的，而如果两个对象不相同那么他们的hashcode也有可能相等</p>
<p>以hashmap为例，首先获得对象的hashcode定位到要加入的位置，再通过equals方法判断两个对象是否真的相同</p>
<p>如果重写了euqals方法，而不重写hashcode方法，那么就会导致相同的对象equals不相等，这样一来，就会导致get出的值为null</p>
<h4 id="14、为什么说java只有值传递"><a href="#14、为什么说java只有值传递" class="headerlink" title="14、为什么说java只有值传递"></a>14、为什么说java只有值传递</h4><p>Java总是采用按值调用。也就是说，方法得到的是所有参数值的一个拷贝，方法不能修改传递给它的任何参数变量的内容。</p>
<ul>
<li><p>第一种是int之类的基本数据类型，值的副本不会改变</p>
</li>
<li><p>第二种是数组之类的引用数据类型，传递的引用的副本，由于引用副本也是指向的同一个对象,所以方法可以改变对象参数，但其本质仍然是按值调用</p>
</li>
</ul>
<p>值调用表示方法接收的是调用者提供的值</p>
<p>按引用调用表示方法接收的是被调用对象的地址</p>
<h4 id="15、浅拷贝、深拷贝"><a href="#15、浅拷贝、深拷贝" class="headerlink" title="15、浅拷贝、深拷贝"></a>15、浅拷贝、深拷贝</h4><p>浅拷贝：对基本数据类型进行值传递；如果该字段是引用类型的话，则复制引用但不复制引用的对象  ，因此原始对象及其副本引用同一个对象  </p>
<p>深拷贝：对基本数据类型进行值传递；如果该字段是引用类型的话，则创建一个新的对象，并复制其内容，赋值给这个新的对象</p>
<h4 id="16、直接引用与符号引用"><a href="#16、直接引用与符号引用" class="headerlink" title="16、直接引用与符号引用"></a>16、直接引用与符号引用</h4><p>符号引用：在编译时，java类并不知道所引用的类的实际地址，因此只能使用符号引用来代替。</p>
<p>直接引用：直接引用可以是直接指向目标的指针</p>
<h4 id="17、对象的序列化和反序列化"><a href="#17、对象的序列化和反序列化" class="headerlink" title="17、对象的序列化和反序列化"></a>17、对象的序列化和反序列化</h4><p>序列化：把对象转换为字节序列的过程称为对象的序列化。保存(持久化)指定的对象，并在将来重新读取被保存的对象。  </p>
<p>反序列化：把字节序列恢复为对象的过程称为对象的反序列化</p>
<p>对于不想序列化的变量，使用transient关键词修饰</p>
<h4 id="18、java泛型"><a href="#18、java泛型" class="headerlink" title="18、java泛型"></a>18、java泛型</h4><p>泛型，即“参数化类型”。就是将类型由原来的具体的类型参数化</p>
<h4 id="19、Comparator和Comparable的区别"><a href="#19、Comparator和Comparable的区别" class="headerlink" title="19、Comparator和Comparable的区别"></a>19、Comparator和Comparable的区别</h4><p>二者都可以用来实现集合中元素的比较，排序</p>
<p>comparable将比较逻辑封装在实现了comparable接口对象的内部，通过compareTo方法实现，可以直接使用collection.sort排序</p>
<p>comparator则在另一个实现了comparator接口的实体类compare方法中实现比较逻辑，使用collection.sort时需要传入这个实体类</p>
<p>因此，comparable耦合性比较强</p>
<h4 id="20、泛型"><a href="#20、泛型" class="headerlink" title="20、泛型"></a>20、泛型</h4><p>泛型，即参数化类型。就是将类型由原来的类型参数化，类似于方法中变量参数，在使用调用时，传入具体的类型</p>
<p>泛型中的类型在使用时指定，不需要强制类型转换，编译器会为我们检查是否符合类型要求</p>
<h4 id="21、静态内部类"><a href="#21、静态内部类" class="headerlink" title="21、静态内部类"></a>21、静态内部类</h4><p>内部类作用：1、内部类一般只为外部类使用，对于一些敏感信息有很好的保护作用  2、内部类扩展了java单继承的缺点</p>
<p>区别：静态内部类只能够访问外部类的静态变量和方法，而非静态内部类可以访问所有成员，这个层面上讲其实就相当于静态方法</p>
<p>自然地，静态内部类可以定义静态成员变量，而非静态内部类不可以</p>
<h3 id="String相关"><a href="#String相关" class="headerlink" title="String相关"></a>String相关</h3><h4 id="1、StringBuffer、StringBuilder、String"><a href="#1、StringBuffer、StringBuilder、String" class="headerlink" title="1、StringBuffer、StringBuilder、String"></a>1、StringBuffer、StringBuilder、String</h4><p>String：由final关键字修饰，即String对象是不可变的，线程安全</p>
<p>StringBuffer：对象可变，线程安全</p>
<p>StringBuilder：对象可变，线程不安全</p>
<h4 id="2、字符串常量池"><a href="#2、字符串常量池" class="headerlink" title="2、字符串常量池"></a>2、字符串常量池</h4><p>字符串常量池位于堆内存中，专门用于存储字符串常量，可以提高内存的使用率，避免开辟多块内存存储相同字符串</p>
<h4 id="3、String-str-”i”与-String-str-new-String-“i”-一样吗？"><a href="#3、String-str-”i”与-String-str-new-String-“i”-一样吗？" class="headerlink" title="3、String str=”i”与 String str=new String(“i”)一样吗？"></a>3、String str=”i”与 String str=new String(“i”)一样吗？</h4><p>不一样因为，前者会将其分配到常量池中，存储于元空间中。而后者会存放在字符串常量池中，存在于堆中</p>
<h4 id="4、String-s-new-String-“xyz”-创建了几个字符串对象"><a href="#4、String-s-new-String-“xyz”-创建了几个字符串对象" class="headerlink" title="4、String s = new String(“xyz”);创建了几个字符串对象"></a>4、String s = new String(“xyz”);创建了几个字符串对象</h4><p>两个对象，一个是静态区的”xyz”，一个是用new创建在堆上的对象。</p>
<h3 id="异常反射机制"><a href="#异常反射机制" class="headerlink" title="异常反射机制"></a>异常反射机制</h3><h4 id="1、java异常体系"><a href="#1、java异常体系" class="headerlink" title="1、java异常体系"></a>1、java异常体系</h4><p><img src="https://gitee.com/xulilei/pic/raw/master/20200713160928.png" alt=""></p>
<p>如果某个方法不能按照正常的途径完成任务，就可以通过另一种路径退出方法。在这种情况下会抛出一个封装了错误信息的对象。此时，这个方法会立刻退出同时不返回任何值。另外，调用这个方法的其他代码也无法继续执行，异常处理机制会将代码执行交给异常处理器  </p>
<h5 id="异常分类"><a href="#异常分类" class="headerlink" title="异常分类"></a>异常分类</h5><p>Error：类是指 java 运行时系统的内部错误和资源耗尽错误。应用程序不会抛出该类对象。如果出现了这样的错误，除了告知用户，剩下的就是尽力使程序安全的终止。<br>Exception（RuntimeException、 CheckedException）：RuntimeException 如 ： NullPointerException、ClassCastException； 一个是检查异常CheckedException，如 I/O 错误导致的 IOException、 SQLException。</p>
<h5 id="处理方式"><a href="#处理方式" class="headerlink" title="处理方式"></a>处理方式</h5><p>抛出异常有三种形式，一是 throw,一个 throws，还有一种系统自动抛异常 ：</p>
<p>throws 用在函数上，后面跟的是异常类，可以跟多个； 而 throw 用在函数内，后面跟的是异常对象 </p>
<h5 id="try-catch"><a href="#try-catch" class="headerlink" title="try-catch"></a>try-catch</h5><p>try块：用于捕获异常，其后可跟0或多个catch块，如果没有catch块，则必须跟一个finally块</p>
<p>catch块：用于处理try捕获到的异常</p>
<p>finally块：无论是否捕获到或者处理了异常，finally块里的语句都会被执行,弱try或者catch语句有return语句时，finally中的语句会被执行，若有返回值会覆盖原始的返回值，如下例子，最终返回0</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> value * value;</span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (value == <span class="number">2</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2、java语言的反射机制"><a href="#2、java语言的反射机制" class="headerlink" title="2、java语言的反射机制"></a>2、java语言的反射机制</h4><p>指在运行状态中，对于任意一个类都能够知道这个类所有的属性和方法；并且对于任意一个对象，都能够调用它的任意一个方法；这种动态获取信息以及动态调用对象方法的功能称为 Java 语言的反射机制  </p>
<h5 id="获取calss对象的三种方法"><a href="#获取calss对象的三种方法" class="headerlink" title="获取calss对象的三种方法"></a>获取calss对象的三种方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1、调用某个对象的getClass()方法：</span></span><br><span class="line">    Person p=<span class="keyword">new</span> Person(); </span><br><span class="line">    Class clazz=p.getClass();</span><br><span class="line"><span class="comment">//2、调用某个类的 class 属性来获取该类对应的 Class 对象：如</span></span><br><span class="line">    Class clazz=Person<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line"><span class="comment">//3、使用 Class 类中的 forName()静态方法(最安全/性能最好/最常用) ：如</span></span><br><span class="line">    Class clazz=Class.forName(<span class="string">"类的全路径"</span>);</span><br></pre></td></tr></table></figure>

<h5 id="获取类方法属性信息"><a href="#获取类方法属性信息" class="headerlink" title="获取类方法属性信息"></a>获取类方法属性信息</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Field 类：Java.lang.reflec 包中的类，表示类的成员变量，可以用来获取和设置类之中的属性值</span></span><br><span class="line">Field[] field=clazz.getDeclaredFields(); </span><br><span class="line"><span class="keyword">for</span>(Field f:field)&#123; </span><br><span class="line">    System.out.println(f.toString());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Method 类：Java.lang.reflec 包中的类，表示类的方法，它可以用来获取类中的方法信息或者执行方法</span></span><br><span class="line">Method[] method=clazz.getDeclaredMethods();</span><br><span class="line"><span class="keyword">for</span>(Method m:method)&#123; </span><br><span class="line">    System.out.println(m.toString()); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Constructor 类：Java.lang.reflec 包中的类，表示类的构造方法</span></span><br><span class="line">Constructor[] constructor=clazz.getDeclaredConstructors(); </span><br><span class="line"><span class="keyword">for</span>(Constructor c:constructor)&#123; </span><br><span class="line">    System.out.println(c.toString()); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="通过反射创建对象的方法"><a href="#通过反射创建对象的方法" class="headerlink" title="通过反射创建对象的方法"></a>通过反射创建对象的方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1、使用 Class 对象的 newInstance()方法来创建该 Class 对象对应类的实例，但是这种方法要求 该 Class 对象对应的类有默认的空构造器</span></span><br><span class="line">Person p=(Person) clazz.newInstance();</span><br><span class="line"><span class="comment">//2、先使用 Class 对象获取指定的 Constructor 对象，再调用 Constructor 对象的 newInstance() 方法来创建 Class 对象对应类的实例</span></span><br><span class="line">Constructor c=clazz.getDeclaredConstructor(String<span class="class">.<span class="keyword">class</span>,<span class="title">String</span>.<span class="title">class</span>,<span class="title">int</span>.<span class="title">class</span>)</span>;</span><br><span class="line">Person p1=(Person) c.newInstance(<span class="string">"李四"</span>,<span class="string">"男"</span>,<span class="number">20</span>);</span><br></pre></td></tr></table></figure>



<h3 id="JAVA8新特性"><a href="#JAVA8新特性" class="headerlink" title="JAVA8新特性"></a>JAVA8新特性</h3><ul>
<li><p>速度更快 – <strong>红黑树</strong>：HashMap数据结构由数组+链表改成数组+链表+红黑树</p>
</li>
<li><p>代码更少 – <strong>Lambda</strong>：允许把函数作为一个方法的参数</p>
</li>
<li><p>强大的Stream API – <strong>Stream</strong>： 支持链式编程，为集合类和数组提供了一些方便的操作方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; collected1 = Arrays.asList(<span class="string">"alpha"</span>,<span class="string">"beta"</span>);</span><br><span class="line">        <span class="comment">//对collected1中的元素进行toUpperCase()</span></span><br><span class="line">        <span class="comment">//将一个集合转换成stream后，通过Filter，map对流进行一些操作，最后再转回对应的ji</span></span><br><span class="line">        collected1 = collected1.stream().map(string -&gt; string.toUpperCase()).collect(Collectors.toList());</span><br><span class="line">        System.out.println(collected1);</span><br><span class="line">        String ids = <span class="string">"1,2,3,4,5"</span>;</span><br><span class="line">        List&lt;String&gt; listIds = Arrays.asList(ids.split(<span class="string">","</span>)).stream().filter(e -&gt; Integer.parseInt(e)&gt;<span class="number">3</span>).collect(Collectors.toList());</span><br><span class="line">        listIds.forEach(e-&gt; System.out.println(e));</span><br><span class="line">        <span class="comment">//System.out.println(listIds);</span></span><br><span class="line">        <span class="keyword">int</span>[] arr=&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">        <span class="comment">//对arr筛选</span></span><br><span class="line">        <span class="keyword">int</span>[]arr1= Arrays.stream(arr).filter(e-&gt;e&gt;<span class="number">3</span>).toArray();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>最大化减少空指针异常 – <strong>Optional</strong>： 是一个容器类，代表一个值存在或不存在，原来用null 表示一个值不存在，现在Optional 可以更好的表达这个概念，并且可以避免空指针异常</p>
</li>
</ul>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Mr.Xu</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://xulilei.github.io/2020/07/12/%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%E4%B9%8Bjava%E5%9F%BA%E7%A1%80/">https://xulilei.github.io/2020/07/12/%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%E4%B9%8Bjava%E5%9F%BA%E7%A1%80/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/java%E5%9F%BA%E7%A1%80/">java基础</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> Donate<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="post-qr-code__img" src="/img/wechat.jpg" alt="微信"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="post-qr-code__img" src="/img/alipay.jpg" alt="支付寶"/><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/07/14/%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%E4%B9%8BIO/"><img class="prev_cover" src="https://gitee.com/xulilei/pic/raw/master/qiuzhao.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">IO模型</div></div></a></div><div class="next-post pull_right"><a href="/2020/07/11/%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B2/"><img class="next_cover" src="https://gitee.com/xulilei/pic/raw/master/qiuzhao.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">多线程（二）</div></div></a></div></nav><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> Comment</span></div><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: '6110470d5d42e0d5f62f',
  clientSecret: '7bdc5cd9b7ddf22caed3be7d9c05afecb628c90f',
  repo: 'xulilei.github.io',
  owner: 'xulilei',
  admin: ['xulilei'],
  id: md5(decodeURI(location.pathname)),
  language: 'zh-CN',
  perPage: 10,
  distractionFreeMode: true,
  pagerDirection: 'last',
  createIssueManually: true,
  updateCountCallback: commentCount
})
gitalk.render('gitalk-container')

function commentCount(n){
  try {
    document.getElementsByClassName('gitalk-comment-count')[0].innerHTML= n
  } catch (e) {
    return false
  }
}</script></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By Mr.Xu</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="Read Mode"></i><i class="fa fa-plus" id="font_plus" title="Increase font size"></i><i class="fa fa-minus" id="font_minus" title="Decrease font size"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="Traditional Chinese and Simplified Chinese Conversion" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="Dark Mode"></i></div><div id="rightside-config-show"><div id="rightside_config" title="Setting"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="Scroll to comment"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="Table of Contents" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="Back to top" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script defer id="ribbon" src="/js/third-party/canvas-ribbon.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@3/instantpage.min.js" type="module"></script></body></html>