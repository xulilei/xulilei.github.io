<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>redis28问 | Humble</title><meta name="description" content="秋招复习redis之28问1、为什么要用redis&#x2F;缓存高性能：对于热点数据，如果不做缓存，每次都要通过硬盘读取数据，会造成性能降低。 高并发：直接操作内存中数据的并发量是远远大于操作数据库的，添加缓存可以提升系统的并发度 2、redis数据类型String：包括数字，主要用于统计数据 Hash：包含键值对的散列表，适合存储对象，比如用户信息，订单信息等 List：双向链表，比如消息列表，还可以做"><meta name="keywords" content="redis"><meta name="author" content="Mr.Xu"><meta name="copyright" content="Mr.Xu"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="dns-prefetch" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="dns-prefetch" href="https://fonts.googleapis.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="dns-prefetch" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="redis28问"><meta name="twitter:description" content="秋招复习redis之28问1、为什么要用redis&#x2F;缓存高性能：对于热点数据，如果不做缓存，每次都要通过硬盘读取数据，会造成性能降低。 高并发：直接操作内存中数据的并发量是远远大于操作数据库的，添加缓存可以提升系统的并发度 2、redis数据类型String：包括数字，主要用于统计数据 Hash：包含键值对的散列表，适合存储对象，比如用户信息，订单信息等 List：双向链表，比如消息列表，还可以做"><meta name="twitter:image" content="https://gitee.com/xulilei/pic/raw/master/qiuzhao.jpg"><meta property="og:type" content="article"><meta property="og:title" content="redis28问"><meta property="og:url" content="https://xulilei.github.io/2020/07/19/%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0redis/"><meta property="og:site_name" content="Humble"><meta property="og:description" content="秋招复习redis之28问1、为什么要用redis&#x2F;缓存高性能：对于热点数据，如果不做缓存，每次都要通过硬盘读取数据，会造成性能降低。 高并发：直接操作内存中数据的并发量是远远大于操作数据库的，添加缓存可以提升系统的并发度 2、redis数据类型String：包括数字，主要用于统计数据 Hash：包含键值对的散列表，适合存储对象，比如用户信息，订单信息等 List：双向链表，比如消息列表，还可以做"><meta property="og:image" content="https://gitee.com/xulilei/pic/raw/master/qiuzhao.jpg"><meta property="article:published_time" content="2020-07-19T10:27:57.000Z"><meta property="article:modified_time" content="2020-09-16T10:45:07.348Z"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="https://xulilei.github.io/2020/07/19/%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0redis/"><link rel="prev" title="中间件MQ" href="https://xulilei.github.io/2020/07/22/%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%E4%B9%8B%E4%B8%AD%E9%97%B4%E4%BB%B6/"><link rel="next" title="mysql之底层原理" href="https://xulilei.github.io/2020/07/18/%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0mysql%E4%B9%8B%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5/js/md5.min.js"></script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  bookmark: {
    message_prev: 'Press',
    message_next: 'to bookmark this page'
  },
  runtime_unit: 'days',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'false',
  isFontAwesomeV5: false,
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="Humble" type="application/atom+xml">
</head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">Articles</div><div class="length_num">39</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">Tags</div><div class="length_num">44</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">Categories</div><div class="length_num">4</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 档案</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#秋招复习redis之28问"><span class="toc-number">1.</span> <span class="toc-text">秋招复习redis之28问</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1、为什么要用redis-缓存"><span class="toc-number">1.0.1.</span> <span class="toc-text">1、为什么要用redis&#x2F;缓存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2、redis数据类型"><span class="toc-number">1.0.2.</span> <span class="toc-text">2、redis数据类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3、为什么使用redis而不使用map-guava-cache等本地缓存"><span class="toc-number">1.0.3.</span> <span class="toc-text">3、为什么使用redis而不使用map&#x2F;guava&#x2F;cache等本地缓存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4、redis为什么这么快"><span class="toc-number">1.0.4.</span> <span class="toc-text">4、redis为什么这么快</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5、RDB持久化"><span class="toc-number">1.0.5.</span> <span class="toc-text">5、RDB持久化</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#触发方式"><span class="toc-number">1.0.5.1.</span> <span class="toc-text">触发方式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#过程："><span class="toc-number">1.0.5.2.</span> <span class="toc-text">过程：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6、AOF持久化"><span class="toc-number">1.0.6.</span> <span class="toc-text">6、AOF持久化</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#触发方式："><span class="toc-number">1.0.6.1.</span> <span class="toc-text">触发方式：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#AOF重写"><span class="toc-number">1.0.6.2.</span> <span class="toc-text">AOF重写</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#过程"><span class="toc-number">1.0.6.3.</span> <span class="toc-text">过程</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7、AOF-RDB对比"><span class="toc-number">1.0.7.</span> <span class="toc-text">7、AOF&#x2F;RDB对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8、混合持久化"><span class="toc-number">1.0.8.</span> <span class="toc-text">8、混合持久化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9、redis数据过期删除策略"><span class="toc-number">1.0.9.</span> <span class="toc-text">9、redis数据过期删除策略</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#立即删除"><span class="toc-number">1.0.9.1.</span> <span class="toc-text">立即删除</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#惰性删除"><span class="toc-number">1.0.9.2.</span> <span class="toc-text">惰性删除</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#定时删除"><span class="toc-number">1.0.9.3.</span> <span class="toc-text">定时删除</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10、redis内存淘汰机制"><span class="toc-number">1.0.10.</span> <span class="toc-text">10、redis内存淘汰机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11、redis如何保证数据都是热点数据"><span class="toc-number">1.0.11.</span> <span class="toc-text">11、redis如何保证数据都是热点数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12、redis线程模型"><span class="toc-number">1.0.12.</span> <span class="toc-text">12、redis线程模型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#单线程多路复用模型"><span class="toc-number">1.0.12.1.</span> <span class="toc-text">单线程多路复用模型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#消息处理流程"><span class="toc-number">1.0.12.2.</span> <span class="toc-text">消息处理流程</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13、redis内存优化"><span class="toc-number">1.0.13.</span> <span class="toc-text">13、redis内存优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14、redis事务特性"><span class="toc-number">1.0.14.</span> <span class="toc-text">14、redis事务特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#15、redis事务实现"><span class="toc-number">1.0.15.</span> <span class="toc-text">15、redis事务实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16、redis主从模式"><span class="toc-number">1.0.16.</span> <span class="toc-text">16、redis主从模式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#目的"><span class="toc-number">1.0.16.1.</span> <span class="toc-text">目的</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#同步策略"><span class="toc-number">1.0.16.2.</span> <span class="toc-text">同步策略</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#同步过程"><span class="toc-number">1.0.16.3.</span> <span class="toc-text">同步过程</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#17、redis哨兵模式"><span class="toc-number">1.0.17.</span> <span class="toc-text">17、redis哨兵模式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#工作流程"><span class="toc-number">1.0.17.1.</span> <span class="toc-text">工作流程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#详细工作"><span class="toc-number">1.0.17.2.</span> <span class="toc-text">详细工作</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#18、集群cluster模式"><span class="toc-number">1.0.18.</span> <span class="toc-text">18、集群cluster模式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#为什么采用分布式集群"><span class="toc-number">1.0.18.1.</span> <span class="toc-text">为什么采用分布式集群</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#哈希槽具体方案"><span class="toc-number">1.0.18.2.</span> <span class="toc-text">哈希槽具体方案</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#节点间的内部通信"><span class="toc-number">1.0.18.3.</span> <span class="toc-text">节点间的内部通信</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#问题："><span class="toc-number">1.0.18.4.</span> <span class="toc-text">问题：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#一致性哈希具体方案"><span class="toc-number">1.0.18.5.</span> <span class="toc-text">一致性哈希具体方案</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#19、缓存雪崩"><span class="toc-number">1.0.19.</span> <span class="toc-text">19、缓存雪崩</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#解决方案"><span class="toc-number">1.0.19.1.</span> <span class="toc-text">解决方案</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#20、缓存穿透"><span class="toc-number">1.0.20.</span> <span class="toc-text">20、缓存穿透</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#解决方案："><span class="toc-number">1.0.20.1.</span> <span class="toc-text">解决方案：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#布隆过滤器原理"><span class="toc-number">1.0.20.2.</span> <span class="toc-text">布隆过滤器原理</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#21、缓存击穿"><span class="toc-number">1.0.21.</span> <span class="toc-text">21、缓存击穿</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#解决方案：-1"><span class="toc-number">1.0.21.1.</span> <span class="toc-text">解决方案：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#22、缓存预热"><span class="toc-number">1.0.22.</span> <span class="toc-text">22、缓存预热</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#23、缓存降级"><span class="toc-number">1.0.23.</span> <span class="toc-text">23、缓存降级</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#24-redis分布式锁"><span class="toc-number">1.0.24.</span> <span class="toc-text">24.redis分布式锁</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#什么情况下使用分布式锁"><span class="toc-number">1.0.24.1.</span> <span class="toc-text">什么情况下使用分布式锁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#为什么不能用syncronized锁"><span class="toc-number">1.0.24.2.</span> <span class="toc-text">为什么不能用syncronized锁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#redis锁为什么可以用？"><span class="toc-number">1.0.24.3.</span> <span class="toc-text">redis锁为什么可以用？</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#25、redis分布式锁基本实现发生的问题和可以优化的点"><span class="toc-number">1.0.25.</span> <span class="toc-text">25、redis分布式锁基本实现发生的问题和可以优化的点</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1、死锁问题"><span class="toc-number">1.0.25.1.</span> <span class="toc-text">1、死锁问题</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2、但是会造成新的问题–无法保证互斥性"><span class="toc-number">1.0.25.2.</span> <span class="toc-text">2、但是会造成新的问题–无法保证互斥性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3、又会回到死锁的问题（自己乱猜的，问到再说）"><span class="toc-number">1.0.25.3.</span> <span class="toc-text">3、又会回到死锁的问题（自己乱猜的，问到再说）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#26、主从架构下的redis分布式锁"><span class="toc-number">1.0.26.</span> <span class="toc-text">26、主从架构下的redis分布式锁</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1、单点局限性"><span class="toc-number">1.0.26.1.</span> <span class="toc-text">1、单点局限性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2、锁丢失的情况"><span class="toc-number">1.0.26.2.</span> <span class="toc-text">2、锁丢失的情况</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#27、基于reddison的redLock实现分布式锁"><span class="toc-number">1.0.27.</span> <span class="toc-text">27、基于reddison的redLock实现分布式锁</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#基本原理"><span class="toc-number">1.0.27.1.</span> <span class="toc-text">基本原理</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#28、缓存是数据库双写一致性的问题"><span class="toc-number">1.0.28.</span> <span class="toc-text">28、缓存是数据库双写一致性的问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#29、redis实现延迟队列"><span class="toc-number">1.0.29.</span> <span class="toc-text">29、redis实现延迟队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#30、redis实现异步队列"><span class="toc-number">1.0.30.</span> <span class="toc-text">30、redis实现异步队列</span></a></li></ol></li></ol></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(https://gitee.com/xulilei/pic/raw/master/qiuzhao.jpg)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Humble</a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 档案</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">redis28问</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="Created 2020-07-19 18:27:57"><i class="fa fa-calendar" aria-hidden="true"></i> Created 2020-07-19</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="Updated 2020-09-16 18:45:07"><i class="fa fa-history" aria-hidden="true"></i> Updated 2020-09-16</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0/">秋招复习</a></span></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>Post View:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"><span class="post-meta__separator">|</span><i class="post-meta__icon fa fa-comment-o" aria-hidden="true"></i><span>Comments:</span><a href="/2020/07/19/%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0redis/#post-comment"><span class="gitalk-comment-count comment-count"></span></a></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h2 id="秋招复习redis之28问"><a href="#秋招复习redis之28问" class="headerlink" title="秋招复习redis之28问"></a>秋招复习redis之28问</h2><h4 id="1、为什么要用redis-缓存"><a href="#1、为什么要用redis-缓存" class="headerlink" title="1、为什么要用redis/缓存"></a>1、为什么要用redis/缓存</h4><p>高性能：对于热点数据，如果不做缓存，每次都要通过硬盘读取数据，会造成性能降低。</p>
<p>高并发：直接操作内存中数据的并发量是远远大于操作数据库的，添加缓存可以提升系统的并发度</p>
<h4 id="2、redis数据类型"><a href="#2、redis数据类型" class="headerlink" title="2、redis数据类型"></a>2、redis数据类型</h4><p><strong>String</strong>：包括数字，主要用于统计数据</p>
<p><strong>Hash</strong>：包含键值对的散列表，适合存储对象，比如用户信息，订单信息等</p>
<p><strong>List</strong>：双向链表，比如消息列表，还可以做分页</p>
<p><strong>Set</strong>：不重复，自然序的列表数据，可判断一个成员是否在一个set内，比如好友列表</p>
<p><strong>Sorted Set</strong>：按照一个权重参数score进行有序排列，多用于自定义的排行列表</p>
<h4 id="3、为什么使用redis而不使用map-guava-cache等本地缓存"><a href="#3、为什么使用redis而不使用map-guava-cache等本地缓存" class="headerlink" title="3、为什么使用redis而不使用map/guava/cache等本地缓存"></a>3、为什么使用redis而不使用map/guava/cache等本地缓存</h4><p>首先缓存分为分布式缓存和本地缓存：</p>
<p>1、map/guava/cache等属于本地缓存，每个jvm实例都对应一份本地缓存，生命周期随着jvm的结束而结束，多个JVM实例会导致缓存不一致</p>
<p>2、redis是一种分布式缓存，多实例共享redis缓存，具有缓存一致性，并且redis支持的数据结构也优于本地缓存</p>
<h4 id="4、redis为什么这么快"><a href="#4、redis为什么这么快" class="headerlink" title="4、redis为什么这么快"></a>4、redis为什么这么快</h4><p>1、redis完全基于内存，内存的读写速度远超硬盘</p>
<p>2、redis采用的是单线程epoll多路复用模型，是一种非阻塞I/O</p>
<p>3、redis单线程模型没有切换线程带来的开小</p>
<h4 id="5、RDB持久化"><a href="#5、RDB持久化" class="headerlink" title="5、RDB持久化"></a>5、RDB持久化</h4><p>通过创建快照获取内存中数据某个时间点的副本，并将其存储到磁盘中，持久化的是数据</p>
<h5 id="触发方式"><a href="#触发方式" class="headerlink" title="触发方式"></a>触发方式</h5><p>1、save 900 1：900秒后至少一个数据发生变化</p>
<p>2、save 300 10：300秒后至少10个数据放生变化</p>
<p>3、save 60 10000：60秒后至少10000个数据发生变化</p>
<h5 id="过程："><a href="#过程：" class="headerlink" title="过程："></a><strong>过程</strong>：</h5><p>1、则父进程会fork一个子进程，fork期间父进程是阻塞的，无法处理其他命令</p>
<p>2、父进程fork完成后，不再阻塞，可以继续处理请求</p>
<p>3、子进程开始执行创建快照文件，并对原来的RDB文件进行替换，替换完成告知父进程，并自动结束</p>
<h4 id="6、AOF持久化"><a href="#6、AOF持久化" class="headerlink" title="6、AOF持久化"></a>6、AOF持久化</h4><p>相比于RDB的数据持久化，AOF持久化的是操作redis的命令，在需要时通过命令恢复数据</p>
<h5 id="触发方式："><a href="#触发方式：" class="headerlink" title="触发方式："></a>触发方式：</h5><p>appendSync-always：即每次有数据修改就写入</p>
<p>appendSync-everySec：每秒钟写入一次</p>
<p>appendsync no ：交由操作系统决定</p>
<h5 id="AOF重写"><a href="#AOF重写" class="headerlink" title="AOF重写"></a>AOF重写</h5><p>由于存储的是操作redis的命令，随着redis的运行，aof文件会越来越大，此时会触发AOF重写</p>
<h5 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h5><p>1、父进程会fork一个子进程，这段期间父进程是阻塞的</p>
<p>2、父进程接触阻塞，并维护一个缓冲区，记录子进程重写期间对数据改动的命令</p>
<p>3、子进程执行AOF重写没有读取上一个aof文件，而是将当前内存中的数据通过命令重新写入新的AOF文件</p>
<p>4、子进程AOF重写结束后，父进程将缓冲区的命令追加到aof的末尾，使得数据状态一致</p>
<h4 id="7、AOF-RDB对比"><a href="#7、AOF-RDB对比" class="headerlink" title="7、AOF/RDB对比"></a>7、AOF/RDB对比</h4><table>
<thead>
<tr>
<th></th>
<th>RDB</th>
<th>AOF</th>
</tr>
</thead>
<tbody><tr>
<td>内容</td>
<td>全量备份所有数据</td>
<td>增量备份修改命令</td>
</tr>
<tr>
<td>体积</td>
<td>小</td>
<td>大</td>
</tr>
<tr>
<td>恢复速度</td>
<td>快</td>
<td>慢</td>
</tr>
<tr>
<td>安全性</td>
<td>丢失数据</td>
<td>根据策略，every sec可能会丢失一秒数据</td>
</tr>
</tbody></table>
<h4 id="8、混合持久化"><a href="#8、混合持久化" class="headerlink" title="8、混合持久化"></a>8、混合持久化</h4><p>重写时，这一刻的内存rdb快照数据和AOF修改命令日志文件存在一起，都写入新的aof文件，快速加载的时候优先加载aof，避免丢失过多的数据</p>
<p>由于AOF文件中不单是AOF格式还有RDB的部分，因此可读性较差，</p>
<h4 id="9、redis数据过期删除策略"><a href="#9、redis数据过期删除策略" class="headerlink" title="9、redis数据过期删除策略"></a>9、redis数据过期删除策略</h4><h5 id="立即删除"><a href="#立即删除" class="headerlink" title="立即删除"></a>立即删除</h5><p>立即删除能保证内存中数据的最大新鲜度，因为它保证过期键值会在过期后马上被删除，其所占用的内存也会随之释放。但是立即删除对cpu是最不友好的。因为删除操作会占用cpu的时间，如果刚好碰上了cpu很忙的时候，会给cpu造成额外的压力,所以并不适合用来处理大量的时间事件。</p>
<h5 id="惰性删除"><a href="#惰性删除" class="headerlink" title="惰性删除"></a>惰性删除</h5><p>惰性删除是指，某个键值过期后，此键值不会马上被删除，而是等到下次被使用的时候，才会被检查到过期，此时才能得到删除。所以惰性删除的缺点很明显，浪费内存。</p>
<h5 id="定时删除"><a href="#定时删除" class="headerlink" title="定时删除"></a>定时删除</h5><p>从上面分析来看，立即删除会短时间内占用大量cpu，惰性删除会在一段时间内浪费内存，所以定时删除是一个折中的办法。<br>定时删除是：每隔一段时间扫描部分设置了过期时间的key，删除已经过期的数据。此种做法可以减少删除操作对cpu的影响。也有效的减少了因惰性删除带来的内存浪费。</p>
<h4 id="10、redis内存淘汰机制"><a href="#10、redis内存淘汰机制" class="headerlink" title="10、redis内存淘汰机制"></a>10、redis内存淘汰机制</h4><p>内存淘汰策略的选取并不会影响删除策略的执行，是在内存空间不足时采取的申请空间的策略</p>
<p><strong>volatile-lru</strong>：从已设置过期时间中，淘汰最近最少使用的least recently used</p>
<p><strong>volatile-lfu</strong>：从已设置过期时间中，淘汰最不经常的数据least frequently used</p>
<p><strong>allkeys-lru</strong>：在全局键空间中，淘汰最近最少使用的key</p>
<p><strong>allkeys-lfu</strong>：在全局键空间中，淘汰最不经常使用的key</p>
<h4 id="11、redis如何保证数据都是热点数据"><a href="#11、redis如何保证数据都是热点数据" class="headerlink" title="11、redis如何保证数据都是热点数据"></a>11、redis如何保证数据都是热点数据</h4><p>删除策略和内存淘汰策略结合使用</p>
<h4 id="12、redis线程模型"><a href="#12、redis线程模型" class="headerlink" title="12、redis线程模型"></a>12、redis线程模型</h4><h5 id="单线程多路复用模型"><a href="#单线程多路复用模型" class="headerlink" title="单线程多路复用模型"></a>单线程多路复用模型</h5><p>多个套接字、IO多路复用程序、事件队列、文件事件分派器、事件处理器</p>
<p><img src="https://gitee.com/xulilei/pic/raw/master/20200721145219.png" alt=""></p>
<h5 id="消息处理流程"><a href="#消息处理流程" class="headerlink" title="消息处理流程"></a>消息处理流程</h5><ul>
<li>通过epoll多路复用程序来同时监听多个套接字</li>
<li>当被监听的套接字准备好执行连接应答(accept)、读取(read)、写入(write)、关闭(close)等操作时，与操作相对应的文件事件就会产生</li>
<li>尽管多个文件事件可能会并发地出现，但redis会将所有产生事件的套接字都推到一个有序队列里面</li>
<li>然后通过这个队列，以有序、同步、每次一个套接字的方式向文件事件分派器传送套接字，当上一个套接字产生的事件被处理完毕之后才会继续向文件事件分派器传送下一个套接字</li>
</ul>
<h4 id="13、redis内存优化"><a href="#13、redis内存优化" class="headerlink" title="13、redis内存优化"></a>13、redis内存优化</h4><p>用好redis的几种基本数据类型，让数据更紧凑的放置在一起</p>
<p>比如一个对象有几种属性，不要为每个属性设置单独的key，而是应该把这个对象的属性存储到这个对象的hash中去</p>
<h4 id="14、redis事务特性"><a href="#14、redis事务特性" class="headerlink" title="14、redis事务特性"></a>14、redis事务特性</h4><p>1、redis不支持回滚，而是继续执行余下的任务，因此事务没有原子性，但是事务中的命令是原子操作</p>
<p>2、如果某个事务中的命令错误，那么所有命令都不会执行，具有一致性</p>
<p>3、如果某个事务出现运行错误，那么正确的命令仍然会得到执行</p>
<p>4、由于redis同一时间只能执行一个事物，因此具有隔离性</p>
<h4 id="15、redis事务实现"><a href="#15、redis事务实现" class="headerlink" title="15、redis事务实现"></a>15、redis事务实现</h4><p>1、watch：相当于java中的cas是一个乐观锁机制，当一个事务开始执行，其他事务就不会执行</p>
<p>2、multi：用于开启一个事务，当multi执行后，redis继续接受消息，并将这些命令放入一个事务块队列</p>
<p>3、exec：执行事务队列中的命令</p>
<p>4、discard：清空事务队列，放弃执行事务，退出事务模式</p>
<h4 id="16、redis主从模式"><a href="#16、redis主从模式" class="headerlink" title="16、redis主从模式"></a>16、redis主从模式</h4><h5 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h5><p>将数据复制给从服务器，写命令发送给主服务器，读命令则发送给从服务器，从而实现读写分离</p>
<h5 id="同步策略"><a href="#同步策略" class="headerlink" title="同步策略"></a>同步策略</h5><p>主从刚刚连接时执行全量同步，全同步完成后执行增量同步</p>
<h5 id="同步过程"><a href="#同步过程" class="headerlink" title="同步过程"></a>同步过程</h5><p>1、从服务器连接主服务器，发送sync同步命令</p>
<p>2、主服务器接收到从服务的sync命令后，开始RDB持久化，并通过缓存区保存持久化期间写命令</p>
<p>3、主服务器完成RDB持久化后，向所有从服务器发送RDB快照文件，并继续保存期间写命令</p>
<p>4、从服务器受到RDB快照后，载入快照文件，并继续使用旧数据提供读服务</p>
<p>5、主服务器发送完快照文件后开始向从服务器发送缓冲区的写命令</p>
<p>6、从服务器完成对快照文件的载入后丢弃旧数据，并增量同步来自主服务器的写命令</p>
<p><strong>Tips</strong>：<em>具体搭建过程见项目实操部分</em></p>
<h4 id="17、redis哨兵模式"><a href="#17、redis哨兵模式" class="headerlink" title="17、redis哨兵模式"></a>17、redis哨兵模式</h4><h5 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h5><p>哨兵是一个独立的进程，也是一个redis服务器，但是并不提供数据服务，端口号默认为26379，而是<strong>监控</strong>提供数据服务的主从服务器，当发现主服务器宕机会自动的将从服务器切换成主服务器，并<strong>通知</strong>其他的从服务器，实现<strong>自动故障转移</strong></p>
<h5 id="详细工作"><a href="#详细工作" class="headerlink" title="详细工作"></a>详细工作</h5><p><strong>监测</strong>：第一个哨兵获取master状态后，会根据master的信息获取该master主机下的从服务器，接着第二个哨兵以同样的方式获取信息，并与第一个哨兵共享信息，并检测哨兵是否咋子先，依次类推</p>
<p><strong>自动故障转移</strong>：当一个哨兵认为master挂掉后，会通知其他哨兵，并将服务器状态设置为s_down。此时会触发哨兵投票机制，当半数以上的哨兵发现服务器挂了，会将master状态设置为o_down，并下线这个master，选取响应快的slave作为新的主节点并告知其他从服务器</p>
<p><strong>Tips</strong>：<em>具体搭建过程见项目实操部分</em></p>
<h4 id="18、集群cluster模式"><a href="#18、集群cluster模式" class="headerlink" title="18、集群cluster模式"></a>18、集群cluster模式</h4><h5 id="为什么采用分布式集群"><a href="#为什么采用分布式集群" class="headerlink" title="为什么采用分布式集群"></a>为什么采用分布式集群</h5><p>即使是哨兵模式，也是一种全量存储模式，每个redis服务器存储的都是完整的数据，浪费内存</p>
<p>分布式集群每个节点存储一定哈希槽区间的数据，通过哈希的方式，将数据分片到这些槽中，解决了哨兵模式下内存浪费的情况</p>
<h5 id="哈希槽具体方案"><a href="#哈希槽具体方案" class="headerlink" title="哈希槽具体方案"></a>哈希槽具体方案</h5><p>1、通过一个散列性良好哈希算法，将数据均匀的分散到16384个哈希槽中，至少需要3主3从</p>
<p>2、每个主从节点均匀分片存储一定哈希槽区间的数据</p>
<p>3、数据先写入该数据所在哈希槽的主节点，再同步到从节点</p>
<p>4、读取数据时，每个节点会将key指向正确的节点</p>
<p>5、每个节点之间通过16379端口通信</p>
<h5 id="节点间的内部通信"><a href="#节点间的内部通信" class="headerlink" title="节点间的内部通信"></a>节点间的内部通信</h5><p>节点间通过cluster bus来通信，基于gossip流言协议，就是节点间彼此不断交换信息，一段时间后每个节点都知道其他节点的详细信息，用以进行监测，自动故障转移</p>
<p>gossip协议：meet（加入），ping（发送信息），pong（回复信息），fail（下线消息）</p>
<h5 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h5><p>哈希槽的存储是对服务器的数量取模，使得每个服务器均匀分片存储一定区间的哈希槽。这样的问题在于当服务器的数量发生改变的时候，数据的位置就会相应的发生改变，会导致缓存雪崩</p>
<h5 id="一致性哈希具体方案"><a href="#一致性哈希具体方案" class="headerlink" title="一致性哈希具体方案"></a>一致性哈希具体方案</h5><p>使用的哈希值对2的32次方进行取模，将整个哈希值空间组织成一个顺时针的虚拟的圆环，即0和2^32-1会在0点钟方向会和</p>
<p>根据各个服务器的ip或者主机名等关键字作一个哈希，确定在哈希环上的位置</p>
<p>再对数据key以同样的方式进行哈希，并确定数据在哈希环上的位置，从此位置沿顺时针行走，遇到的第一个服务器就是数据存储的服务器</p>
<p>当服务器数量发生变化时，只会影响存储在这个服务器上的数据，其他不受影响</p>
<h4 id="19、缓存雪崩"><a href="#19、缓存雪崩" class="headerlink" title="19、缓存雪崩"></a>19、缓存雪崩</h4><p>指缓存同一时间大面积的失效，请求直接落到数据库上，造成数据库短时间内承受大量请求而崩掉</p>
<h5 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h5><p><strong>事前</strong>：尽量保证redis服务的稳定，宕机尽快补上，这是防止缓存雪崩的根本，比如通过主从，哨兵，集群等方式。如果是因为短时间内大量key失效导致的缓存雪崩，则通过离散化失效时间来防止</p>
<p><strong>事中</strong>：通过hystrix限流保证不会有大量线程对数据库进行一次性读写，以及临时时间本地缓存对热点数据作二级缓存</p>
<p><strong>事后</strong>：如果发生了缓存雪崩，则利用redis持久化尽快恢复</p>
<h4 id="20、缓存穿透"><a href="#20、缓存穿透" class="headerlink" title="20、缓存穿透"></a>20、缓存穿透</h4><p>指缓存和数据库中都没有的数据，穿透了过去，导致所有的请求都落在数据库上，造成数据库短时间承受大量请求而崩掉</p>
<h5 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h5><p>提前做好<strong>参数校验</strong>，比如用户身份的鉴权，满足条件好再给予发送请求的权利，其次就是规定参数格式，拒绝不合法的参数</p>
<p>对于同一个key的反复攻击，设置<strong>key-null</strong>在缓存中存储，但对于key快速变化的意义不大</p>
<p><strong>布隆过滤器</strong>：由hash函数和位数组构成的一个可以快速查询数据是否存在或者一定不存在的过滤器，会拦截一个一定不存在的数据</p>
<h5 id="布隆过滤器原理"><a href="#布隆过滤器原理" class="headerlink" title="布隆过滤器原理"></a>布隆过滤器原理</h5><p>底层是一个bit数组，对于每个映射到过滤器中的值，都通过多个哈希函数生成多个哈希值，并将哈希值对应的位置都值为1.查询时，如果值对应的多个哈希函数的值位置都为1，则判断该值可能存在，反之如果有一个不为0则判断这个值一定不存在</p>
<h4 id="21、缓存击穿"><a href="#21、缓存击穿" class="headerlink" title="21、缓存击穿"></a>21、缓存击穿</h4><p>指缓存中没有，但数据库中由的数据。与缓存雪崩不同的是，缓存击穿是大量请求查询同一数据</p>
<h5 id="解决方案：-1"><a href="#解决方案：-1" class="headerlink" title="解决方案："></a>解决方案：</h5><p>1、对热点数据设置长时间不过期</p>
<p>2、对于热点数据采用加锁的形式，比如semaphore等</p>
<p><strong>Tips</strong>：<em>具体搭建过程见项目实操部分</em></p>
<h4 id="22、缓存预热"><a href="#22、缓存预热" class="headerlink" title="22、缓存预热"></a>22、缓存预热</h4><p>系统上线后，将相关的热点数据直接加载进入缓存系统。用户就不用在第一次查询时，先走数据库而是直接查询缓存</p>
<h4 id="23、缓存降级"><a href="#23、缓存降级" class="headerlink" title="23、缓存降级"></a>23、缓存降级</h4><p>目的是为了防止redis发生的故障导致数据库跟着一起发生雪崩问题，是一种保护数据库的机制</p>
<p>比较常见的做法是redis出现问题，不去查询数据库而是直接返回默认值给用户</p>
<h4 id="24-redis分布式锁"><a href="#24-redis分布式锁" class="headerlink" title="24.redis分布式锁"></a>24.redis分布式锁</h4><h5 id="什么情况下使用分布式锁"><a href="#什么情况下使用分布式锁" class="headerlink" title="什么情况下使用分布式锁"></a>什么情况下使用分布式锁</h5><p>分布式架构下对数据有精确控制的情况，比如商品秒杀</p>
<h5 id="为什么不能用syncronized锁"><a href="#为什么不能用syncronized锁" class="headerlink" title="为什么不能用syncronized锁"></a>为什么不能用syncronized锁</h5><p>在分布式架构下，存在多个服务实例时，由于一个对应对应一个JVM，而syncronized是JVM级别的锁，因此可能会发生超卖的问题</p>
<h5 id="redis锁为什么可以用？"><a href="#redis锁为什么可以用？" class="headerlink" title="redis锁为什么可以用？"></a>redis锁为什么可以用？</h5><p>1、redis是单线程模型，采用一个队列将并发访问变成串行访问</p>
<p>2、基于redis的setnx命令，如果key存在不作任何操作，key不存在才可以添加，key可以设置成这个商品的名称</p>
<p>3、添加成功后获取锁，执行逻辑代码，最后删除key</p>
<h4 id="25、redis分布式锁基本实现发生的问题和可以优化的点"><a href="#25、redis分布式锁基本实现发生的问题和可以优化的点" class="headerlink" title="25、redis分布式锁基本实现发生的问题和可以优化的点"></a>25、redis分布式锁基本实现发生的问题和可以优化的点</h4><h5 id="1、死锁问题"><a href="#1、死锁问题" class="headerlink" title="1、死锁问题"></a>1、死锁问题</h5><p><strong>原因</strong>：获得锁后，执行代码逻辑过程遇到长时间等待等错误导致key无法删除而造成其他请求无法执行造成死锁，</p>
<p><strong>解决方法</strong>：是对key设置一个过期时间，并且用try catch包围加锁过程</p>
<h5 id="2、但是会造成新的问题–无法保证互斥性"><a href="#2、但是会造成新的问题–无法保证互斥性" class="headerlink" title="2、但是会造成新的问题–无法保证互斥性"></a>2、但是会造成新的问题–<strong>无法保证互斥性</strong></h5><p><strong>原因</strong>：已经超过key的过期时间，key已经被删除了，但是上一个逻辑代码由于某一些原因还没有执行结束，这时便存在多个进程操作一个资源，是去了互斥性</p>
<p><strong>解决方案</strong>：通过redisson提供的加锁机制，每隔1/3时间检查是否还持有锁，如果持有就延长锁的时间，保证了互斥性</p>
<h5 id="3、又会回到死锁的问题（自己乱猜的，问到再说）"><a href="#3、又会回到死锁的问题（自己乱猜的，问到再说）" class="headerlink" title="3、又会回到死锁的问题（自己乱猜的，问到再说）"></a>3、又会回到<strong>死锁</strong>的问题（自己乱猜的，问到再说）</h5><p><strong>原因</strong>：即一个进程一直持有这把锁，不释放。</p>
<p><strong>解决方案</strong>：那么就需要一个控制逻辑执行时间的事务，这个时间要略微小于key过期的时间，时间允许范围内，如果逻辑没有执行完毕那么就回滚并结束进程。</p>
<h4 id="26、主从架构下的redis分布式锁"><a href="#26、主从架构下的redis分布式锁" class="headerlink" title="26、主从架构下的redis分布式锁"></a>26、主从架构下的redis分布式锁</h4><h5 id="1、单点局限性"><a href="#1、单点局限性" class="headerlink" title="1、单点局限性"></a>1、单点局限性</h5><p><strong>原因</strong>：在单点模式下，如果这个redis实例挂了，那么整个服务就挂了</p>
<p><strong>解决方案</strong>：搭建主从模式，这样的话即使一个redis宕机了，其他也能提供服务</p>
<h5 id="2、锁丢失的情况"><a href="#2、锁丢失的情况" class="headerlink" title="2、锁丢失的情况"></a>2、锁丢失的情况</h5><p><strong>原因</strong>：在主节点向从节点写入lock key的过程中，如果恰好此刻主节点宕机，并且lock key还没有写入新主节点，那么就会使得其他进程仍然可以获得该锁</p>
<p><strong>解决方案</strong>：redlock方案</p>
<h4 id="27、基于reddison的redLock实现分布式锁"><a href="#27、基于reddison的redLock实现分布式锁" class="headerlink" title="27、基于reddison的redLock实现分布式锁"></a>27、基于reddison的redLock实现分布式锁</h4><p>抛弃主从模式，直接使用多个master，相互独立，这样就保证了在master宕机的情况下，不会出现从服务器数据丢失的情况</p>
<h5 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h5><p>1、设置两个时间，一个是锁失效时间。一个是请求超时时间这个时间要远小于超时时间，防止长时间等待redis服务器响应</p>
<p>2、依次尝试从n个实例，使用相同的key和value获取锁，当且仅当超过半数的锁获取成功，且时间小于锁失效的时间，锁才算获取成功</p>
<p>3、如果获取失败，则应该在已经添加了锁的服务器上解锁</p>
<p><strong>Tips</strong>：<em>具体搭建过程见项目实操部分</em></p>
<h4 id="28、缓存是数据库双写一致性的问题"><a href="#28、缓存是数据库双写一致性的问题" class="headerlink" title="28、缓存是数据库双写一致性的问题"></a>28、缓存是数据库双写一致性的问题</h4><p>1、如果一定要做到一致性，那么可以采用串行化的方式，但是开销太大，性能大幅降低</p>
<p>2、如果允许暂时不一致的情况，则遵循先写数据库的原则，因为如果缓存写入成功，而数据库没有写成功，那么之后高并发的读取都是错误的数据</p>
<p>3、正确的做法是先写入数据库，再将缓存中的key设置为无效，数据库修改成功后再返回来修改缓存，这样的话。最多在写入数据库时缓存短暂失效，但写回后即可重新生效。而不会发生误读的情况</p>
<h4 id="29、redis实现延迟队列"><a href="#29、redis实现延迟队列" class="headerlink" title="29、redis实现延迟队列"></a>29、redis实现延迟队列</h4><p>大概步骤为：</p>
<p>1、将整个redis当作消息池，以kv的形式存储消息</p>
<p>2、使用ZET作优先队列，按照score维持优先级</p>
<p>3、使用list结构，以先进先出的方式消费</p>
<p>4、ZSet和list存储消息地址（对应消息池的每个key）</p>
<p>5、还需要维持Zset和list的一个路由关系</p>
<p>6、使用TTL实现一个消息延迟</p>
<h4 id="30、redis实现异步队列"><a href="#30、redis实现异步队列" class="headerlink" title="30、redis实现异步队列"></a>30、redis实现异步队列</h4><p>使用redis中的list（列表）实现异步消息，使用rpush/lpush操作插入队列消息，使用lpop和rpop来出队消费消息</p>
<p>会出现队列空的情况，会造成一个空轮询的情况，此时可以使用命令blpop、brpop，当队列没有数据的时候，会立即进入休眠状态。</p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Mr.Xu</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://xulilei.github.io/2020/07/19/%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0redis/">https://xulilei.github.io/2020/07/19/%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0redis/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/redis/">redis</a></div><div class="post_share"><div class="social-share" data-image="https://gitee.com/xulilei/pic/raw/master/u=2022511002,2558506576&amp;fm=26&amp;gp=0.jpg" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> Donate<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="post-qr-code__img" src="/img/wechat.jpg" alt="微信"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="post-qr-code__img" src="/img/alipay.jpg" alt="支付寶"/><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/07/22/%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0%E4%B9%8B%E4%B8%AD%E9%97%B4%E4%BB%B6/"><img class="prev_cover" src="https://gitee.com/xulilei/pic/raw/master/qiuzhao.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">中间件MQ</div></div></a></div><div class="next-post pull_right"><a href="/2020/07/18/%E7%A7%8B%E6%8B%9B%E5%A4%8D%E4%B9%A0mysql%E4%B9%8B%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"><img class="next_cover" src="https://gitee.com/xulilei/pic/raw/master/qiuzhao.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">mysql之底层原理</div></div></a></div></nav><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> Comment</span></div><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: '6110470d5d42e0d5f62f',
  clientSecret: '7bdc5cd9b7ddf22caed3be7d9c05afecb628c90f',
  repo: 'xulilei.github.io',
  owner: 'xulilei',
  admin: ['xulilei'],
  id: md5(decodeURI(location.pathname)),
  language: 'zh-CN',
  perPage: 10,
  distractionFreeMode: true,
  pagerDirection: 'last',
  createIssueManually: true,
  updateCountCallback: commentCount
})
gitalk.render('gitalk-container')

function commentCount(n){
  try {
    document.getElementsByClassName('gitalk-comment-count')[0].innerHTML= n
  } catch (e) {
    return false
  }
}</script></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By Mr.Xu</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="Read Mode"></i><i class="fa fa-plus" id="font_plus" title="Increase font size"></i><i class="fa fa-minus" id="font_minus" title="Decrease font size"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="Traditional Chinese and Simplified Chinese Conversion" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="Dark Mode"></i></div><div id="rightside-config-show"><div id="rightside_config" title="Setting"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="Scroll to comment"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="Table of Contents" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="Back to top" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script defer id="ribbon" src="/js/third-party/canvas-ribbon.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@3/instantpage.min.js" type="module"></script></body></html>